/******/ ;(function(modules) {
  // webpackBootstrap
  /******/ function hotDisposeChunk(chunkId) {
    /******/ delete installedChunks[chunkId]
    /******/
  }
  /******/ var parentHotUpdateCallback = window['webpackHotUpdate']
  /******/ window[
    'webpackHotUpdate'
  ] = /******/ function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-next-line no-unused-vars
    /******/ hotAddUpdateChunk(chunkId, moreModules)
    /******/ if (parentHotUpdateCallback)
      parentHotUpdateCallback(chunkId, moreModules)
    /******/
  } // eslint-disable-next-line no-unused-vars
  /******/
  /******/ /******/ function hotDownloadUpdateChunk(chunkId) {
    /******/ var script = document.createElement('script')
    /******/ script.charset = 'utf-8'
    /******/ script.src =
      __webpack_require__.p +
      '' +
      chunkId +
      '.' +
      hotCurrentHash +
      '.hot-update.js'
    /******/ if (null) script.crossOrigin = null
    /******/ document.head.appendChild(script)
    /******/
  } // eslint-disable-next-line no-unused-vars
  /******/
  /******/ /******/ function hotDownloadManifest(requestTimeout) {
    /******/ requestTimeout = requestTimeout || 10000
    /******/ return new Promise(function(resolve, reject) {
      /******/ if (typeof XMLHttpRequest === 'undefined') {
        /******/ return reject(new Error('No browser support'))
        /******/
      }
      /******/ try {
        /******/ var request = new XMLHttpRequest()
        /******/ var requestPath =
          __webpack_require__.p + '' + hotCurrentHash + '.hot-update.json'
        /******/ request.open('GET', requestPath, true)
        /******/ request.timeout = requestTimeout
        /******/ request.send(null)
        /******/
      } catch (err) {
        /******/ return reject(err)
        /******/
      }
      /******/ request.onreadystatechange = function() {
        /******/ if (request.readyState !== 4) return
        /******/ if (request.status === 0) {
          /******/ // timeout
          /******/ reject(
            /******/ new Error(
              'Manifest request to ' + requestPath + ' timed out.'
            )
            /******/
          )
          /******/
        } else if (request.status === 404) {
          /******/ // no update available
          /******/ resolve()
          /******/
        } else if (request.status !== 200 && request.status !== 304) {
          /******/ // other failure
          /******/ reject(
            new Error('Manifest request to ' + requestPath + ' failed.')
          )
          /******/
        } else {
          /******/ // success
          /******/ try {
            /******/ var update = JSON.parse(request.responseText)
            /******/
          } catch (e) {
            /******/ reject(e)
            /******/ return
            /******/
          }
          /******/ resolve(update)
          /******/
        }
        /******/
      }
      /******/
    })
    /******/
  }
  /******/
  /******/ var hotApplyOnUpdate = true // eslint-disable-next-line no-unused-vars
  /******/ /******/ var hotCurrentHash = '17e8699ded2020d3673e'
  /******/ var hotRequestTimeout = 10000
  /******/ var hotCurrentModuleData = {}
  /******/ var hotCurrentChildModule // eslint-disable-next-line no-unused-vars
  /******/ /******/ var hotCurrentParents = [] // eslint-disable-next-line no-unused-vars
  /******/ /******/ var hotCurrentParentsTemp = [] // eslint-disable-next-line no-unused-vars
  /******/
  /******/ /******/ function hotCreateRequire(moduleId) {
    /******/ var me = installedModules[moduleId]
    /******/ if (!me) return __webpack_require__
    /******/ var fn = function(request) {
      /******/ if (me.hot.active) {
        /******/ if (installedModules[request]) {
          /******/ if (
            installedModules[request].parents.indexOf(moduleId) === -1
          ) {
            /******/ installedModules[request].parents.push(moduleId)
            /******/
          }
          /******/
        } else {
          /******/ hotCurrentParents = [moduleId]
          /******/ hotCurrentChildModule = request
          /******/
        }
        /******/ if (me.children.indexOf(request) === -1) {
          /******/ me.children.push(request)
          /******/
        }
        /******/
      } else {
        /******/ console.warn(
          /******/ '[HMR] unexpected require(' +
            /******/ request +
            /******/ ') from disposed module ' +
            /******/ moduleId
          /******/
        )
        /******/ hotCurrentParents = []
        /******/
      }
      /******/ return __webpack_require__(request)
      /******/
    }
    /******/ var ObjectFactory = function ObjectFactory(name) {
      /******/ return {
        /******/ configurable: true,
        /******/ enumerable: true,
        /******/ get: function() {
          /******/ return __webpack_require__[name]
          /******/
        },
        /******/ set: function(value) {
          /******/ __webpack_require__[name] = value
          /******/
        }
        /******/
      }
      /******/
    }
    /******/ for (var name in __webpack_require__) {
      /******/ if (
        /******/ Object.prototype.hasOwnProperty.call(
          __webpack_require__,
          name
        ) &&
        /******/ name !== 'e' &&
        /******/ name !== 't'
        /******/
      ) {
        /******/ Object.defineProperty(fn, name, ObjectFactory(name))
        /******/
      }
      /******/
    }
    /******/ fn.e = function(chunkId) {
      /******/ if (hotStatus === 'ready') hotSetStatus('prepare')
      /******/ hotChunksLoading++
      /******/ return __webpack_require__
        .e(chunkId)
        .then(finishChunkLoading, function(err) {
          /******/ finishChunkLoading()
          /******/ throw err
          /******/
        })
      /******/
      /******/ function finishChunkLoading() {
        /******/ hotChunksLoading--
        /******/ if (hotStatus === 'prepare') {
          /******/ if (!hotWaitingFilesMap[chunkId]) {
            /******/ hotEnsureUpdateChunk(chunkId)
            /******/
          }
          /******/ if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
            /******/ hotUpdateDownloaded()
            /******/
          }
          /******/
        }
        /******/
      }
      /******/
    }
    /******/ fn.t = function(value, mode) {
      /******/ if (mode & 1) value = fn(value)
      /******/ return __webpack_require__.t(value, mode & ~1)
      /******/
    }
    /******/ return fn
    /******/
  } // eslint-disable-next-line no-unused-vars
  /******/
  /******/ /******/ function hotCreateModule(moduleId) {
    /******/ var hot = {
      /******/ // private stuff
      /******/ _acceptedDependencies: {},
      /******/ _declinedDependencies: {},
      /******/ _selfAccepted: false,
      /******/ _selfDeclined: false,
      /******/ _selfInvalidated: false,
      /******/ _disposeHandlers: [],
      /******/ _main: hotCurrentChildModule !== moduleId, // Module API
      /******/
      /******/ /******/ active: true,
      /******/ accept: function(dep, callback) {
        /******/ if (dep === undefined) hot._selfAccepted = true
        /******/ else if (typeof dep === 'function') hot._selfAccepted = dep
        /******/ else if (typeof dep === 'object')
          /******/ for (var i = 0; i < dep.length; i++)
            /******/ hot._acceptedDependencies[dep[i]] =
              callback || function() {}
        /******/ else hot._acceptedDependencies[dep] = callback || function() {}
        /******/
      },
      /******/ decline: function(dep) {
        /******/ if (dep === undefined) hot._selfDeclined = true
        /******/ else if (typeof dep === 'object')
          /******/ for (var i = 0; i < dep.length; i++)
            /******/ hot._declinedDependencies[dep[i]] = true
        /******/ else hot._declinedDependencies[dep] = true
        /******/
      },
      /******/ dispose: function(callback) {
        /******/ hot._disposeHandlers.push(callback)
        /******/
      },
      /******/ addDisposeHandler: function(callback) {
        /******/ hot._disposeHandlers.push(callback)
        /******/
      },
      /******/ removeDisposeHandler: function(callback) {
        /******/ var idx = hot._disposeHandlers.indexOf(callback)
        /******/ if (idx >= 0) hot._disposeHandlers.splice(idx, 1)
        /******/
      },
      /******/ invalidate: function() {
        /******/ this._selfInvalidated = true
        /******/ switch (hotStatus) {
          /******/ case 'idle':
            /******/ hotUpdate = {}
            /******/ hotUpdate[moduleId] = modules[moduleId]
            /******/ hotSetStatus('ready')
            /******/ break
          /******/ case 'ready':
            /******/ hotApplyInvalidatedModule(moduleId)
            /******/ break
          /******/ case 'prepare':
          /******/ case 'check':
          /******/ case 'dispose':
          /******/ case 'apply':
            /******/ ;(hotQueuedInvalidatedModules =
              /******/ hotQueuedInvalidatedModules || []).push(moduleId)
            /******/ break
          /******/ default:
            /******/ // ignore requests in error states
            /******/ break
          /******/
        }
        /******/
      }, // Management API
      /******/
      /******/ /******/ check: hotCheck,
      /******/ apply: hotApply,
      /******/ status: function(l) {
        /******/ if (!l) return hotStatus
        /******/ hotStatusHandlers.push(l)
        /******/
      },
      /******/ addStatusHandler: function(l) {
        /******/ hotStatusHandlers.push(l)
        /******/
      },
      /******/ removeStatusHandler: function(l) {
        /******/ var idx = hotStatusHandlers.indexOf(l)
        /******/ if (idx >= 0) hotStatusHandlers.splice(idx, 1)
        /******/
      }, //inherit from previous dispose call
      /******/
      /******/ /******/ data: hotCurrentModuleData[moduleId]
      /******/
    }
    /******/ hotCurrentChildModule = undefined
    /******/ return hot
    /******/
  }
  /******/
  /******/ var hotStatusHandlers = []
  /******/ var hotStatus = 'idle'
  /******/
  /******/ function hotSetStatus(newStatus) {
    /******/ hotStatus = newStatus
    /******/ for (var i = 0; i < hotStatusHandlers.length; i++)
      /******/ hotStatusHandlers[i].call(null, newStatus)
    /******/
  } // while downloading
  /******/
  /******/ /******/ var hotWaitingFiles = 0
  /******/ var hotChunksLoading = 0
  /******/ var hotWaitingFilesMap = {}
  /******/ var hotRequestedFilesMap = {}
  /******/ var hotAvailableFilesMap = {}
  /******/ var hotDeferred // The update info
  /******/
  /******/ /******/ var hotUpdate, hotUpdateNewHash, hotQueuedInvalidatedModules
  /******/
  /******/ function toModuleId(id) {
    /******/ var isNumber = +id + '' === id
    /******/ return isNumber ? +id : id
    /******/
  }
  /******/
  /******/ function hotCheck(apply) {
    /******/ if (hotStatus !== 'idle') {
      /******/ throw new Error('check() is only allowed in idle status')
      /******/
    }
    /******/ hotApplyOnUpdate = apply
    /******/ hotSetStatus('check')
    /******/ return hotDownloadManifest(hotRequestTimeout).then(function(
      update
    ) {
      /******/ if (!update) {
        /******/ hotSetStatus(hotApplyInvalidatedModules() ? 'ready' : 'idle')
        /******/ return null
        /******/
      }
      /******/ hotRequestedFilesMap = {}
      /******/ hotWaitingFilesMap = {}
      /******/ hotAvailableFilesMap = update.c
      /******/ hotUpdateNewHash = update.h
      /******/
      /******/ hotSetStatus('prepare')
      /******/ var promise = new Promise(function(resolve, reject) {
        /******/ hotDeferred = {
          /******/ resolve: resolve,
          /******/ reject: reject
          /******/
        }
        /******/
      })
      /******/ hotUpdate = {}
      /******/ var chunkId = 'main' // eslint-disable-next-line no-lone-blocks
      /******/ /******/ {
        /******/ hotEnsureUpdateChunk(chunkId)
        /******/
      }
      /******/ if (
        /******/ hotStatus === 'prepare' &&
        /******/ hotChunksLoading === 0 &&
        /******/ hotWaitingFiles === 0
        /******/
      ) {
        /******/ hotUpdateDownloaded()
        /******/
      }
      /******/ return promise
      /******/
    })
    /******/
  } // eslint-disable-next-line no-unused-vars
  /******/
  /******/ /******/ function hotAddUpdateChunk(chunkId, moreModules) {
    /******/ if (
      !hotAvailableFilesMap[chunkId] ||
      !hotRequestedFilesMap[chunkId]
    )
      /******/ return
    /******/ hotRequestedFilesMap[chunkId] = false
    /******/ for (var moduleId in moreModules) {
      /******/ if (
        Object.prototype.hasOwnProperty.call(moreModules, moduleId)
      ) {
        /******/ hotUpdate[moduleId] = moreModules[moduleId]
        /******/
      }
      /******/
    }
    /******/ if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
      /******/ hotUpdateDownloaded()
      /******/
    }
    /******/
  }
  /******/
  /******/ function hotEnsureUpdateChunk(chunkId) {
    /******/ if (!hotAvailableFilesMap[chunkId]) {
      /******/ hotWaitingFilesMap[chunkId] = true
      /******/
    } else {
      /******/ hotRequestedFilesMap[chunkId] = true
      /******/ hotWaitingFiles++
      /******/ hotDownloadUpdateChunk(chunkId)
      /******/
    }
    /******/
  }
  /******/
  /******/ function hotUpdateDownloaded() {
    /******/ hotSetStatus('ready')
    /******/ var deferred = hotDeferred
    /******/ hotDeferred = null
    /******/ if (!deferred) return
    /******/ if (hotApplyOnUpdate) {
      /******/ // Wrap deferred object in Promise to mark it as a well-handled Promise to
      /******/ // avoid triggering uncaught exception warning in Chrome.
      /******/ // See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
      /******/ Promise.resolve()
        /******/ .then(function() {
          /******/ return hotApply(hotApplyOnUpdate)
          /******/
        })
        /******/ .then(
          /******/ function(result) {
            /******/ deferred.resolve(result)
            /******/
          },
          /******/ function(err) {
            /******/ deferred.reject(err)
            /******/
          }
          /******/
        )
      /******/
    } else {
      /******/ var outdatedModules = []
      /******/ for (var id in hotUpdate) {
        /******/ if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
          /******/ outdatedModules.push(toModuleId(id))
          /******/
        }
        /******/
      }
      /******/ deferred.resolve(outdatedModules)
      /******/
    }
    /******/
  }
  /******/
  /******/ function hotApply(options) {
    /******/ if (hotStatus !== 'ready')
      /******/ throw new Error('apply() is only allowed in ready status')
    /******/ options = options || {}
    /******/ return hotApplyInternal(options)
    /******/
  }
  /******/
  /******/ function hotApplyInternal(options) {
    /******/ hotApplyInvalidatedModules()
    /******/
    /******/ var cb
    /******/ var i
    /******/ var j
    /******/ var module
    /******/ var moduleId
    /******/
    /******/ function getAffectedStuff(updateModuleId) {
      /******/ var outdatedModules = [updateModuleId]
      /******/ var outdatedDependencies = {}
      /******/
      /******/ var queue = outdatedModules.map(function(id) {
        /******/ return {
          /******/ chain: [id],
          /******/ id: id
          /******/
        }
        /******/
      })
      /******/ while (queue.length > 0) {
        /******/ var queueItem = queue.pop()
        /******/ var moduleId = queueItem.id
        /******/ var chain = queueItem.chain
        /******/ module = installedModules[moduleId]
        /******/ if (
          /******/ !module ||
          /******/ (module.hot._selfAccepted && !module.hot._selfInvalidated)
          /******/
        )
          /******/ continue
        /******/ if (module.hot._selfDeclined) {
          /******/ return {
            /******/ type: 'self-declined',
            /******/ chain: chain,
            /******/ moduleId: moduleId
            /******/
          }
          /******/
        }
        /******/ if (module.hot._main) {
          /******/ return {
            /******/ type: 'unaccepted',
            /******/ chain: chain,
            /******/ moduleId: moduleId
            /******/
          }
          /******/
        }
        /******/ for (var i = 0; i < module.parents.length; i++) {
          /******/ var parentId = module.parents[i]
          /******/ var parent = installedModules[parentId]
          /******/ if (!parent) continue
          /******/ if (parent.hot._declinedDependencies[moduleId]) {
            /******/ return {
              /******/ type: 'declined',
              /******/ chain: chain.concat([parentId]),
              /******/ moduleId: moduleId,
              /******/ parentId: parentId
              /******/
            }
            /******/
          }
          /******/ if (outdatedModules.indexOf(parentId) !== -1) continue
          /******/ if (parent.hot._acceptedDependencies[moduleId]) {
            /******/ if (!outdatedDependencies[parentId])
              /******/ outdatedDependencies[parentId] = []
            /******/ addAllToSet(outdatedDependencies[parentId], [moduleId])
            /******/ continue
            /******/
          }
          /******/ delete outdatedDependencies[parentId]
          /******/ outdatedModules.push(parentId)
          /******/ queue.push({
            /******/ chain: chain.concat([parentId]),
            /******/ id: parentId
            /******/
          })
          /******/
        }
        /******/
      }
      /******/
      /******/ return {
        /******/ type: 'accepted',
        /******/ moduleId: updateModuleId,
        /******/ outdatedModules: outdatedModules,
        /******/ outdatedDependencies: outdatedDependencies
        /******/
      }
      /******/
    }
    /******/
    /******/ function addAllToSet(a, b) {
      /******/ for (var i = 0; i < b.length; i++) {
        /******/ var item = b[i]
        /******/ if (a.indexOf(item) === -1) a.push(item)
        /******/
      }
      /******/
    } // at begin all updates modules are outdated // the "outdated" status can propagate to parents if they don't accept the children
    /******/
    /******/ /******/ /******/ var outdatedDependencies = {}
    /******/ var outdatedModules = []
    /******/ var appliedUpdate = {}
    /******/
    /******/ var warnUnexpectedRequire = function warnUnexpectedRequire() {
      /******/ console.warn(
        /******/ '[HMR] unexpected require(' +
          result.moduleId +
          ') to disposed module'
        /******/
      )
      /******/
    }
    /******/
    /******/ for (var id in hotUpdate) {
      /******/ if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
        /******/ moduleId = toModuleId(id) /** @type {TODO} */
        /******/ /******/ var result
        /******/ if (hotUpdate[id]) {
          /******/ result = getAffectedStuff(moduleId)
          /******/
        } else {
          /******/ result = {
            /******/ type: 'disposed',
            /******/ moduleId: id
            /******/
          }
          /******/
        } /** @type {Error|false} */
        /******/ /******/ var abortError = false
        /******/ var doApply = false
        /******/ var doDispose = false
        /******/ var chainInfo = ''
        /******/ if (result.chain) {
          /******/ chainInfo =
            '\nUpdate propagation: ' + result.chain.join(' -> ')
          /******/
        }
        /******/ switch (result.type) {
          /******/ case 'self-declined':
            /******/ if (options.onDeclined) options.onDeclined(result)
            /******/ if (!options.ignoreDeclined)
              /******/ abortError = new Error(
                /******/ 'Aborted because of self decline: ' +
                  /******/ result.moduleId +
                  /******/ chainInfo
                /******/
              )
            /******/ break
          /******/ case 'declined':
            /******/ if (options.onDeclined) options.onDeclined(result)
            /******/ if (!options.ignoreDeclined)
              /******/ abortError = new Error(
                /******/ 'Aborted because of declined dependency: ' +
                  /******/ result.moduleId +
                  /******/ ' in ' +
                  /******/ result.parentId +
                  /******/ chainInfo
                /******/
              )
            /******/ break
          /******/ case 'unaccepted':
            /******/ if (options.onUnaccepted) options.onUnaccepted(result)
            /******/ if (!options.ignoreUnaccepted)
              /******/ abortError = new Error(
                /******/ 'Aborted because ' +
                  moduleId +
                  ' is not accepted' +
                  chainInfo
                /******/
              )
            /******/ break
          /******/ case 'accepted':
            /******/ if (options.onAccepted) options.onAccepted(result)
            /******/ doApply = true
            /******/ break
          /******/ case 'disposed':
            /******/ if (options.onDisposed) options.onDisposed(result)
            /******/ doDispose = true
            /******/ break
          /******/ default:
            /******/ throw new Error('Unexception type ' + result.type)
          /******/
        }
        /******/ if (abortError) {
          /******/ hotSetStatus('abort')
          /******/ return Promise.reject(abortError)
          /******/
        }
        /******/ if (doApply) {
          /******/ appliedUpdate[moduleId] = hotUpdate[moduleId]
          /******/ addAllToSet(outdatedModules, result.outdatedModules)
          /******/ for (moduleId in result.outdatedDependencies) {
            /******/ if (
              /******/ Object.prototype.hasOwnProperty.call(
                /******/ result.outdatedDependencies,
                /******/ moduleId
                /******/
              )
              /******/
            ) {
              /******/ if (!outdatedDependencies[moduleId])
                /******/ outdatedDependencies[moduleId] = []
              /******/ addAllToSet(
                /******/ outdatedDependencies[moduleId],
                /******/ result.outdatedDependencies[moduleId]
                /******/
              )
              /******/
            }
            /******/
          }
          /******/
        }
        /******/ if (doDispose) {
          /******/ addAllToSet(outdatedModules, [result.moduleId])
          /******/ appliedUpdate[moduleId] = warnUnexpectedRequire
          /******/
        }
        /******/
      }
      /******/
    } // Store self accepted outdated modules to require them later by the module system
    /******/
    /******/ /******/ var outdatedSelfAcceptedModules = []
    /******/ for (i = 0; i < outdatedModules.length; i++) {
      /******/ moduleId = outdatedModules[i]
      /******/ if (
        /******/ installedModules[moduleId] &&
        /******/ installedModules[moduleId].hot._selfAccepted && // removed self-accepted modules should not be required
        /******/ /******/ appliedUpdate[moduleId] !== warnUnexpectedRequire && // when called invalidate self-accepting is not possible
        /******/ /******/ !installedModules[moduleId].hot._selfInvalidated
        /******/
      ) {
        /******/ outdatedSelfAcceptedModules.push({
          /******/ module: moduleId,
          /******/ parents: installedModules[moduleId].parents.slice(),
          /******/ errorHandler: installedModules[moduleId].hot._selfAccepted
          /******/
        })
        /******/
      }
      /******/
    } // Now in "dispose" phase
    /******/
    /******/ /******/ hotSetStatus('dispose')
    /******/ Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
      /******/ if (hotAvailableFilesMap[chunkId] === false) {
        /******/ hotDisposeChunk(chunkId)
        /******/
      }
      /******/
    })
    /******/
    /******/ var idx
    /******/ var queue = outdatedModules.slice()
    /******/ while (queue.length > 0) {
      /******/ moduleId = queue.pop()
      /******/ module = installedModules[moduleId]
      /******/ if (!module) continue
      /******/
      /******/ var data = {} // Call dispose handlers
      /******/
      /******/ /******/ var disposeHandlers = module.hot._disposeHandlers
      /******/ for (j = 0; j < disposeHandlers.length; j++) {
        /******/ cb = disposeHandlers[j]
        /******/ cb(data)
        /******/
      }
      /******/ hotCurrentModuleData[moduleId] = data // disable module (this disables requires from this module)
      /******/
      /******/ /******/ module.hot.active = false // remove module from cache
      /******/
      /******/ /******/ delete installedModules[moduleId] // when disposing there is no need to call dispose handler
      /******/
      /******/ /******/ delete outdatedDependencies[moduleId] // remove "parents" references from all children
      /******/
      /******/ /******/ for (j = 0; j < module.children.length; j++) {
        /******/ var child = installedModules[module.children[j]]
        /******/ if (!child) continue
        /******/ idx = child.parents.indexOf(moduleId)
        /******/ if (idx >= 0) {
          /******/ child.parents.splice(idx, 1)
          /******/
        }
        /******/
      }
      /******/
    } // remove outdated dependency from module children
    /******/
    /******/ /******/ var dependency
    /******/ var moduleOutdatedDependencies
    /******/ for (moduleId in outdatedDependencies) {
      /******/ if (
        /******/ Object.prototype.hasOwnProperty.call(
          outdatedDependencies,
          moduleId
        )
        /******/
      ) {
        /******/ module = installedModules[moduleId]
        /******/ if (module) {
          /******/ moduleOutdatedDependencies = outdatedDependencies[moduleId]
          /******/ for (j = 0; j < moduleOutdatedDependencies.length; j++) {
            /******/ dependency = moduleOutdatedDependencies[j]
            /******/ idx = module.children.indexOf(dependency)
            /******/ if (idx >= 0) module.children.splice(idx, 1)
            /******/
          }
          /******/
        }
        /******/
      }
      /******/
    } // Now in "apply" phase
    /******/
    /******/ /******/ hotSetStatus('apply')
    /******/
    /******/ if (hotUpdateNewHash !== undefined) {
      /******/ hotCurrentHash = hotUpdateNewHash
      /******/ hotUpdateNewHash = undefined
      /******/
    }
    /******/ hotUpdate = undefined // insert new code
    /******/
    /******/ /******/ for (moduleId in appliedUpdate) {
      /******/ if (
        Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)
      ) {
        /******/ modules[moduleId] = appliedUpdate[moduleId]
        /******/
      }
      /******/
    } // call accept handlers
    /******/
    /******/ /******/ var error = null
    /******/ for (moduleId in outdatedDependencies) {
      /******/ if (
        /******/ Object.prototype.hasOwnProperty.call(
          outdatedDependencies,
          moduleId
        )
        /******/
      ) {
        /******/ module = installedModules[moduleId]
        /******/ if (module) {
          /******/ moduleOutdatedDependencies = outdatedDependencies[moduleId]
          /******/ var callbacks = []
          /******/ for (i = 0; i < moduleOutdatedDependencies.length; i++) {
            /******/ dependency = moduleOutdatedDependencies[i]
            /******/ cb = module.hot._acceptedDependencies[dependency]
            /******/ if (cb) {
              /******/ if (callbacks.indexOf(cb) !== -1) continue
              /******/ callbacks.push(cb)
              /******/
            }
            /******/
          }
          /******/ for (i = 0; i < callbacks.length; i++) {
            /******/ cb = callbacks[i]
            /******/ try {
              /******/ cb(moduleOutdatedDependencies)
              /******/
            } catch (err) {
              /******/ if (options.onErrored) {
                /******/ options.onErrored({
                  /******/ type: 'accept-errored',
                  /******/ moduleId: moduleId,
                  /******/ dependencyId: moduleOutdatedDependencies[i],
                  /******/ error: err
                  /******/
                })
                /******/
              }
              /******/ if (!options.ignoreErrored) {
                /******/ if (!error) error = err
                /******/
              }
              /******/
            }
            /******/
          }
          /******/
        }
        /******/
      }
      /******/
    } // Load self accepted modules
    /******/
    /******/ /******/ for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
      /******/ var item = outdatedSelfAcceptedModules[i]
      /******/ moduleId = item.module
      /******/ hotCurrentParents = item.parents
      /******/ hotCurrentChildModule = moduleId
      /******/ try {
        /******/ __webpack_require__(moduleId)
        /******/
      } catch (err) {
        /******/ if (typeof item.errorHandler === 'function') {
          /******/ try {
            /******/ item.errorHandler(err)
            /******/
          } catch (err2) {
            /******/ if (options.onErrored) {
              /******/ options.onErrored({
                /******/ type: 'self-accept-error-handler-errored',
                /******/ moduleId: moduleId,
                /******/ error: err2,
                /******/ originalError: err
                /******/
              })
              /******/
            }
            /******/ if (!options.ignoreErrored) {
              /******/ if (!error) error = err2
              /******/
            }
            /******/ if (!error) error = err
            /******/
          }
          /******/
        } else {
          /******/ if (options.onErrored) {
            /******/ options.onErrored({
              /******/ type: 'self-accept-errored',
              /******/ moduleId: moduleId,
              /******/ error: err
              /******/
            })
            /******/
          }
          /******/ if (!options.ignoreErrored) {
            /******/ if (!error) error = err
            /******/
          }
          /******/
        }
        /******/
      }
      /******/
    } // handle errors in accept handlers and self accepted module load
    /******/
    /******/ /******/ if (error) {
      /******/ hotSetStatus('fail')
      /******/ return Promise.reject(error)
      /******/
    }
    /******/
    /******/ if (hotQueuedInvalidatedModules) {
      /******/ return hotApplyInternal(options).then(function(list) {
        /******/ outdatedModules.forEach(function(moduleId) {
          /******/ if (list.indexOf(moduleId) < 0) list.push(moduleId)
          /******/
        })
        /******/ return list
        /******/
      })
      /******/
    }
    /******/
    /******/ hotSetStatus('idle')
    /******/ return new Promise(function(resolve) {
      /******/ resolve(outdatedModules)
      /******/
    })
    /******/
  }
  /******/
  /******/ function hotApplyInvalidatedModules() {
    /******/ if (hotQueuedInvalidatedModules) {
      /******/ if (!hotUpdate) hotUpdate = {}
      /******/ hotQueuedInvalidatedModules.forEach(hotApplyInvalidatedModule)
      /******/ hotQueuedInvalidatedModules = undefined
      /******/ return true
      /******/
    }
    /******/
  }
  /******/
  /******/ function hotApplyInvalidatedModule(moduleId) {
    /******/ if (!Object.prototype.hasOwnProperty.call(hotUpdate, moduleId))
      /******/ hotUpdate[moduleId] = modules[moduleId]
    /******/
  } // The module cache
  /******/
  /******/ /******/ var installedModules = {} // The require function
  /******/
  /******/ /******/ function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports
      /******/
    } // Create a new module (and put it into the cache)
    /******/ /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId,
      /******/ l: false,
      /******/ exports: {},
      /******/ hot: hotCreateModule(moduleId),
      /******/ parents: ((hotCurrentParentsTemp = hotCurrentParents),
      (hotCurrentParents = []),
      hotCurrentParentsTemp),
      /******/ children: []
      /******/
    }) // Execute the module function
    /******/
    /******/ /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      hotCreateRequire(moduleId)
    ) // Flag the module as loaded
    /******/
    /******/ /******/ module.l = true // Return the exports of the module
    /******/
    /******/ /******/ return module.exports
    /******/
  } // expose the modules object (__webpack_modules__)
  /******/
  /******/
  /******/ /******/ __webpack_require__.m = modules // expose the module cache
  /******/
  /******/ /******/ __webpack_require__.c = installedModules // define getter function for harmony exports
  /******/
  /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      })
      /******/
    }
    /******/
  } // define __esModule on exports
  /******/
  /******/ /******/ __webpack_require__.r = function(exports) {
    /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      })
      /******/
    }
    /******/ Object.defineProperty(exports, '__esModule', { value: true })
    /******/
  } // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /******/
  /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
    value,
    mode
  ) {
    /******/ if (mode & 1) value = __webpack_require__(value)
    /******/ if (mode & 8) return value
    /******/ if (
      mode & 4 &&
      typeof value === 'object' &&
      value &&
      value.__esModule
    )
      return value
    /******/ var ns = Object.create(null)
    /******/ __webpack_require__.r(ns)
    /******/ Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    })
    /******/ if (mode & 2 && typeof value != 'string')
      for (var key in value)
        __webpack_require__.d(
          ns,
          key,
          function(key) {
            return value[key]
          }.bind(null, key)
        )
    /******/ return ns
    /******/
  } // getDefaultExport function for compatibility with non-harmony modules
  /******/
  /******/ /******/ __webpack_require__.n = function(module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module['default']
          }
        : /******/ function getModuleExports() {
            return module
          }
    /******/ __webpack_require__.d(getter, 'a', getter)
    /******/ return getter
    /******/
  } // Object.prototype.hasOwnProperty.call
  /******/
  /******/ /******/ __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property)
  } // __webpack_public_path__
  /******/
  /******/ /******/ __webpack_require__.p = '' // __webpack_hash__
  /******/
  /******/ /******/ __webpack_require__.h = function() {
    return hotCurrentHash
  } // Load entry module and return exports
  /******/
  /******/
  /******/ /******/ return hotCreateRequire(0)((__webpack_require__.s = 0))
  /******/
})(
  /************************************************************************/
  /******/ {
    /***/ './dist/vue.runtime.esm-browser.js':
      /*!*****************************************!*\
  !*** ./dist/vue.runtime.esm-browser.js ***!
  \*****************************************/
      /*! exports provided: BaseTransition, Comment, Fragment, KeepAlive, Static, Suspense, Teleport, Text, Transition, TransitionGroup, callWithAsyncErrorHandling, callWithErrorHandling, camelize, capitalize, cloneVNode, compile, computed, createApp, createBlock, createCommentVNode, createHydrationRenderer, createRenderer, createSSRApp, createSlots, createStaticVNode, createTextVNode, createVNode, customRef, defineAsyncComponent, defineComponent, defineEmit, defineProps, devtools, getCurrentInstance, getTransitionRawChildren, h, handleError, hydrate, initCustomFormatter, inject, isProxy, isReactive, isReadonly, isRef, isRuntimeOnly, isVNode, markRaw, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, openBlock, popScopeId, provide, proxyRefs, pushScopeId, queuePostFlushCb, reactive, readonly, ref, registerRuntimeCompiler, render, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, shallowReactive, shallowReadonly, shallowRef, ssrContextKey, ssrUtils, toDisplayString, toHandlerKey, toHandlers, toRaw, toRef, toRefs, transformVNodeArgs, triggerRef, unref, useContext, useCssModule, useCssVars, useSSRContext, useTransitionState, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, version, warn, watch, watchEffect, withCtx, withDirectives, withKeys, withModifiers, withScopeId */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        'use strict'
        __webpack_require__.r(__webpack_exports__)
        /* WEBPACK VAR INJECTION */ ;(function(global) {
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'BaseTransition',
            function() {
              return BaseTransition
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Comment',
            function() {
              return Comment
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Fragment',
            function() {
              return Fragment
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'KeepAlive',
            function() {
              return KeepAlive
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Static',
            function() {
              return Static
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Suspense',
            function() {
              return Suspense
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Teleport',
            function() {
              return Teleport
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Text',
            function() {
              return Text
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Transition',
            function() {
              return Transition
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'TransitionGroup',
            function() {
              return TransitionGroup
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'callWithAsyncErrorHandling',
            function() {
              return callWithAsyncErrorHandling
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'callWithErrorHandling',
            function() {
              return callWithErrorHandling
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'camelize',
            function() {
              return camelize
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'capitalize',
            function() {
              return capitalize
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'cloneVNode',
            function() {
              return cloneVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'compile',
            function() {
              return compile$1
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'computed',
            function() {
              return computed$1
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createApp',
            function() {
              return createApp
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createBlock',
            function() {
              return createBlock
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createCommentVNode',
            function() {
              return createCommentVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createHydrationRenderer',
            function() {
              return createHydrationRenderer
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createRenderer',
            function() {
              return createRenderer
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createSSRApp',
            function() {
              return createSSRApp
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createSlots',
            function() {
              return createSlots
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createStaticVNode',
            function() {
              return createStaticVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createTextVNode',
            function() {
              return createTextVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createVNode',
            function() {
              return createVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'customRef',
            function() {
              return customRef
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defineAsyncComponent',
            function() {
              return defineAsyncComponent
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defineComponent',
            function() {
              return defineComponent
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defineEmit',
            function() {
              return defineEmit
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defineProps',
            function() {
              return defineProps
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'devtools',
            function() {
              return devtools
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getCurrentInstance',
            function() {
              return getCurrentInstance
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getTransitionRawChildren',
            function() {
              return getTransitionRawChildren
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'h',
            function() {
              return h
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'handleError',
            function() {
              return handleError
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'hydrate',
            function() {
              return hydrate
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'initCustomFormatter',
            function() {
              return initCustomFormatter
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'inject',
            function() {
              return inject
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isProxy',
            function() {
              return isProxy
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isReactive',
            function() {
              return isReactive
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isReadonly',
            function() {
              return isReadonly
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isRef',
            function() {
              return isRef
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isRuntimeOnly',
            function() {
              return isRuntimeOnly
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isVNode',
            function() {
              return isVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'markRaw',
            function() {
              return markRaw
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'mergeProps',
            function() {
              return mergeProps
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'nextTick',
            function() {
              return nextTick
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onActivated',
            function() {
              return onActivated
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onBeforeMount',
            function() {
              return onBeforeMount
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onBeforeUnmount',
            function() {
              return onBeforeUnmount
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onBeforeUpdate',
            function() {
              return onBeforeUpdate
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onDeactivated',
            function() {
              return onDeactivated
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onErrorCaptured',
            function() {
              return onErrorCaptured
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onMounted',
            function() {
              return onMounted
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onRenderTracked',
            function() {
              return onRenderTracked
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onRenderTriggered',
            function() {
              return onRenderTriggered
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onUnmounted',
            function() {
              return onUnmounted
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onUpdated',
            function() {
              return onUpdated
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'openBlock',
            function() {
              return openBlock
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'popScopeId',
            function() {
              return popScopeId
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'provide',
            function() {
              return provide
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'proxyRefs',
            function() {
              return proxyRefs
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'pushScopeId',
            function() {
              return pushScopeId
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'queuePostFlushCb',
            function() {
              return queuePostFlushCb
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'reactive',
            function() {
              return reactive
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'readonly',
            function() {
              return readonly
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ref',
            function() {
              return ref
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'registerRuntimeCompiler',
            function() {
              return registerRuntimeCompiler
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'render',
            function() {
              return render
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'renderList',
            function() {
              return renderList
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'renderSlot',
            function() {
              return renderSlot
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resolveComponent',
            function() {
              return resolveComponent
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resolveDirective',
            function() {
              return resolveDirective
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resolveDynamicComponent',
            function() {
              return resolveDynamicComponent
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resolveTransitionHooks',
            function() {
              return resolveTransitionHooks
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'setBlockTracking',
            function() {
              return setBlockTracking
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'setDevtoolsHook',
            function() {
              return setDevtoolsHook
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'setTransitionHooks',
            function() {
              return setTransitionHooks
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'shallowReactive',
            function() {
              return shallowReactive
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'shallowReadonly',
            function() {
              return shallowReadonly
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'shallowRef',
            function() {
              return shallowRef
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ssrContextKey',
            function() {
              return ssrContextKey
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ssrUtils',
            function() {
              return ssrUtils
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toDisplayString',
            function() {
              return toDisplayString
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toHandlerKey',
            function() {
              return toHandlerKey
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toHandlers',
            function() {
              return toHandlers
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toRaw',
            function() {
              return toRaw
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toRef',
            function() {
              return toRef
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toRefs',
            function() {
              return toRefs
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'transformVNodeArgs',
            function() {
              return transformVNodeArgs
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'triggerRef',
            function() {
              return triggerRef
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'unref',
            function() {
              return unref
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'useContext',
            function() {
              return useContext
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'useCssModule',
            function() {
              return useCssModule
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'useCssVars',
            function() {
              return useCssVars
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'useSSRContext',
            function() {
              return useSSRContext
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'useTransitionState',
            function() {
              return useTransitionState
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'vModelCheckbox',
            function() {
              return vModelCheckbox
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'vModelDynamic',
            function() {
              return vModelDynamic
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'vModelRadio',
            function() {
              return vModelRadio
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'vModelSelect',
            function() {
              return vModelSelect
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'vModelText',
            function() {
              return vModelText
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'vShow',
            function() {
              return vShow
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'version',
            function() {
              return version
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'warn',
            function() {
              return warn
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'watch',
            function() {
              return watch
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'watchEffect',
            function() {
              return watchEffect
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'withCtx',
            function() {
              return withCtx
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'withDirectives',
            function() {
              return withDirectives
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'withKeys',
            function() {
              return withKeys
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'withModifiers',
            function() {
              return withModifiers
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'withScopeId',
            function() {
              return withScopeId
            }
          )
          var _ErrorTypeStrings

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i]
              descriptor.enumerable = descriptor.enumerable || false
              descriptor.configurable = true
              if ('value' in descriptor) descriptor.writable = true
              Object.defineProperty(target, descriptor.key, descriptor)
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps)
            if (staticProps) _defineProperties(Constructor, staticProps)
            return Constructor
          }

          function _typeof(obj) {
            '@babel/helpers - typeof'
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj
              }
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj
              }
            }
            return _typeof(obj)
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          function _slicedToArray(arr, i) {
            return (
              _arrayWithHoles(arr) ||
              _iterableToArrayLimit(arr, i) ||
              _unsupportedIterableToArray(arr, i) ||
              _nonIterableRest()
            )
          }

          function _nonIterableRest() {
            throw new TypeError(
              'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
            )
          }

          function _iterableToArrayLimit(arr, i) {
            if (
              typeof Symbol === 'undefined' ||
              !(Symbol.iterator in Object(arr))
            )
              return
            var _arr = []
            var _n = true
            var _d = false
            var _e = undefined
            try {
              for (
                var _i = arr[Symbol.iterator](), _s;
                !(_n = (_s = _i.next()).done);
                _n = true
              ) {
                _arr.push(_s.value)
                if (i && _arr.length === i) break
              }
            } catch (err) {
              _d = true
              _e = err
            } finally {
              try {
                if (!_n && _i['return'] != null) _i['return']()
              } finally {
                if (_d) throw _e
              }
            }
            return _arr
          }

          function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr
          }

          function _toConsumableArray(arr) {
            return (
              _arrayWithoutHoles(arr) ||
              _iterableToArray(arr) ||
              _unsupportedIterableToArray(arr) ||
              _nonIterableSpread()
            )
          }

          function _nonIterableSpread() {
            throw new TypeError(
              'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
            )
          }

          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return
            if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
            var n = Object.prototype.toString.call(o).slice(8, -1)
            if (n === 'Object' && o.constructor) n = o.constructor.name
            if (n === 'Map' || n === 'Set') return Array.from(o)
            if (
              n === 'Arguments' ||
              /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
            )
              return _arrayLikeToArray(o, minLen)
          }

          function _iterableToArray(iter) {
            if (
              typeof Symbol !== 'undefined' &&
              Symbol.iterator in Object(iter)
            )
              return Array.from(iter)
          }

          function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) return _arrayLikeToArray(arr)
          }

          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i]
            }
            return arr2
          }

          /**
           * Make a map and return a function for checking if a key
           * is in that map.
           * IMPORTANT: all calls of this function must be prefixed with
           * \/\*#\_\_PURE\_\_\*\/
           * So that rollup can tree-shake them if necessary.
           */
          function makeMap(str, expectsLowerCase) {
            var map = Object.create(null)
            var list = str.split(',')

            for (var i = 0; i < list.length; i++) {
              map[list[i]] = true
            }

            return expectsLowerCase
              ? function(val) {
                  return !!map[val.toLowerCase()]
                }
              : function(val) {
                  return !!map[val]
                }
          }

          var GLOBALS_WHITE_LISTED =
            'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
            'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
            'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'
          var isGloballyWhitelisted = /*#__PURE__*/ makeMap(
            GLOBALS_WHITE_LISTED
          )
          /**
           * On the client we only need to offer special cases for boolean attributes that
           * have different names from their corresponding dom properties:
           * - itemscope -> N/A
           * - allowfullscreen -> allowFullscreen
           * - formnovalidate -> formNoValidate
           * - ismap -> isMap
           * - nomodule -> noModule
           * - novalidate -> noValidate
           * - readonly -> readOnly
           */

          var specialBooleanAttrs =
            'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly'
          var isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)

          function normalizeStyle(value) {
            if (isArray(value)) {
              var res = {}

              for (var i = 0; i < value.length; i++) {
                var item = value[i]
                var normalized = normalizeStyle(
                  isString(item) ? parseStringStyle(item) : item
                )

                if (normalized) {
                  for (var key in normalized) {
                    res[key] = normalized[key]
                  }
                }
              }

              return res
            } else if (isObject(value)) {
              return value
            }
          }

          var listDelimiterRE = /;(?![^(]*\))/g
          var propertyDelimiterRE = /:(.+)/

          function parseStringStyle(cssText) {
            var ret = {}
            cssText.split(listDelimiterRE).forEach(function(item) {
              if (item) {
                var tmp = item.split(propertyDelimiterRE)
                tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())
              }
            })
            return ret
          }

          function normalizeClass(value) {
            var res = ''

            if (isString(value)) {
              res = value
            } else if (isArray(value)) {
              for (var i = 0; i < value.length; i++) {
                var normalized = normalizeClass(value[i])

                if (normalized) {
                  res += normalized + ' '
                }
              }
            } else if (isObject(value)) {
              for (var name in value) {
                if (value[name]) {
                  res += name + ' '
                }
              }
            }

            return res.trim()
          } // These tag configs are shared between compiler-dom and runtime-dom, so they
          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element

          var HTML_TAGS =
            'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
            'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
            'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
            'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
            'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
            'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
            'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
            'option,output,progress,select,textarea,details,dialog,menu,' +
            'summary,template,blockquote,iframe,tfoot' // https://developer.mozilla.org/en-US/docs/Web/SVG/Element

          var SVG_TAGS =
            'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
            'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
            'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
            'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
            'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
            'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
            'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
            'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
            'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
            'text,textPath,title,tspan,unknown,use,view'
          var isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)
          var isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)

          function looseCompareArrays(a, b) {
            if (a.length !== b.length) return false
            var equal = true

            for (var i = 0; equal && i < a.length; i++) {
              equal = looseEqual(a[i], b[i])
            }

            return equal
          }

          function looseEqual(a, b) {
            if (a === b) return true
            var aValidType = isDate(a)
            var bValidType = isDate(b)

            if (aValidType || bValidType) {
              return aValidType && bValidType
                ? a.getTime() === b.getTime()
                : false
            }

            aValidType = isArray(a)
            bValidType = isArray(b)

            if (aValidType || bValidType) {
              return aValidType && bValidType ? looseCompareArrays(a, b) : false
            }

            aValidType = isObject(a)
            bValidType = isObject(b)

            if (aValidType || bValidType) {
              /* istanbul ignore if: this if will probably never be called */
              if (!aValidType || !bValidType) {
                return false
              }

              var aKeysCount = Object.keys(a).length
              var bKeysCount = Object.keys(b).length

              if (aKeysCount !== bKeysCount) {
                return false
              }

              for (var key in a) {
                var aHasKey = a.hasOwnProperty(key)
                var bHasKey = b.hasOwnProperty(key)

                if (
                  (aHasKey && !bHasKey) ||
                  (!aHasKey && bHasKey) ||
                  !looseEqual(a[key], b[key])
                ) {
                  return false
                }
              }
            }

            return String(a) === String(b)
          }

          function looseIndexOf(arr, val) {
            return arr.findIndex(function(item) {
              return looseEqual(item, val)
            })
          }
          /**
           * For converting {{ interpolation }} values to displayed strings.
           * @private
           */

          var toDisplayString = function toDisplayString(val) {
            return val == null
              ? ''
              : isObject(val)
                ? JSON.stringify(val, replacer, 2)
                : String(val)
          }

          var replacer = function replacer(_key, val) {
            if (isMap(val)) {
              return _defineProperty(
                {},
                'Map('.concat(val.size, ')'),
                _toConsumableArray(val.entries()).reduce(function(
                  entries,
                  _ref
                ) {
                  var _ref2 = _slicedToArray(_ref, 2),
                    key = _ref2[0],
                    val = _ref2[1]

                  entries[''.concat(key, ' =>')] = val
                  return entries
                },
                {})
              )
            } else if (isSet(val)) {
              return _defineProperty(
                {},
                'Set('.concat(val.size, ')'),
                _toConsumableArray(val.values())
              )
            } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
              return String(val)
            }

            return val
          }

          var EMPTY_OBJ = Object.freeze({})
          var EMPTY_ARR = Object.freeze([])

          var NOOP = function NOOP() {}
          /**
           * Always return false.
           */

          var NO = function NO() {
            return false
          }

          var onRE = /^on[^a-z]/

          var isOn = function isOn(key) {
            return onRE.test(key)
          }

          var isModelListener = function isModelListener(key) {
            return key.startsWith('onUpdate:')
          }

          var extend = Object.assign

          var remove = function remove(arr, el) {
            var i = arr.indexOf(el)

            if (i > -1) {
              arr.splice(i, 1)
            }
          }

          var hasOwnProperty = Object.prototype.hasOwnProperty

          var hasOwn = function hasOwn(val, key) {
            return hasOwnProperty.call(val, key)
          }

          var isArray = Array.isArray

          var isMap = function isMap(val) {
            return toTypeString(val) === '[object Map]'
          }

          var isSet = function isSet(val) {
            return toTypeString(val) === '[object Set]'
          }

          var isDate = function isDate(val) {
            return val instanceof Date
          }

          var isFunction = function isFunction(val) {
            return typeof val === 'function'
          }

          var isString = function isString(val) {
            return typeof val === 'string'
          }

          var isSymbol = function isSymbol(val) {
            return _typeof(val) === 'symbol'
          }

          var isObject = function isObject(val) {
            return val !== null && _typeof(val) === 'object'
          }

          var isPromise = function isPromise(val) {
            return (
              isObject(val) && isFunction(val.then) && isFunction(val['catch'])
            )
          }

          var objectToString = Object.prototype.toString

          var toTypeString = function toTypeString(value) {
            return objectToString.call(value)
          }

          var toRawType = function toRawType(value) {
            // extract "RawType" from strings like "[object RawType]"
            return toTypeString(value).slice(8, -1)
          }

          var isPlainObject = function isPlainObject(val) {
            return toTypeString(val) === '[object Object]'
          }

          var isIntegerKey = function isIntegerKey(key) {
            return (
              isString(key) &&
              key !== 'NaN' &&
              key[0] !== '-' &&
              '' + parseInt(key, 10) === key
            )
          }

          var isReservedProp = /*#__PURE__*/ makeMap(
            // the leading comma is intentional so empty string "" is also included
            ',key,ref,' +
              'onVnodeBeforeMount,onVnodeMounted,' +
              'onVnodeBeforeUpdate,onVnodeUpdated,' +
              'onVnodeBeforeUnmount,onVnodeUnmounted'
          )

          var cacheStringFunction = function cacheStringFunction(fn) {
            var cache = Object.create(null)
            return function(str) {
              var hit = cache[str]
              return hit || (cache[str] = fn(str))
            }
          }

          var camelizeRE = /-(\w)/g
          /**
           * @private
           */

          var camelize = cacheStringFunction(function(str) {
            return str.replace(camelizeRE, function(_, c) {
              return c ? c.toUpperCase() : ''
            })
          })
          var hyphenateRE = /\B([A-Z])/g
          /**
           * @private
           */

          var hyphenate = cacheStringFunction(function(str) {
            return str.replace(hyphenateRE, '-$1').toLowerCase()
          })
          /**
           * @private
           */

          var capitalize = cacheStringFunction(function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1)
          })
          /**
           * @private
           */

          var toHandlerKey = cacheStringFunction(function(str) {
            return str ? 'on'.concat(capitalize(str)) : ''
          }) // compare whether a value has changed, accounting for NaN.

          var hasChanged = function hasChanged(value, oldValue) {
            return (
              value !== oldValue && (value === value || oldValue === oldValue)
            )
          }

          var invokeArrayFns = function invokeArrayFns(fns, arg) {
            for (var i = 0; i < fns.length; i++) {
              fns[i](arg)
            }
          }

          var def = function def(obj, key, value) {
            Object.defineProperty(obj, key, {
              configurable: true,
              enumerable: false,
              value: value
            })
          }

          var toNumber = function toNumber(val) {
            var n = parseFloat(val)
            return isNaN(n) ? val : n
          }

          var _globalThis

          var getGlobalThis = function getGlobalThis() {
            return (
              _globalThis ||
              (_globalThis =
                typeof globalThis !== 'undefined'
                  ? globalThis
                  : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                      ? window
                      : typeof global !== 'undefined'
                        ? global
                        : {})
            )
          }

          var targetMap = new WeakMap()
          var effectStack = []
          var activeEffect
          var ITERATE_KEY = Symbol('iterate')
          var MAP_KEY_ITERATE_KEY = Symbol('Map key iterate')

          function isEffect(fn) {
            return fn && fn._isEffect === true
          }

          function effect(fn) {
            var options =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : EMPTY_OBJ

            if (isEffect(fn)) {
              fn = fn.raw
            }

            var effect = createReactiveEffect(fn, options)

            if (!options.lazy) {
              effect()
            }

            return effect
          }

          function stop(effect) {
            if (effect.active) {
              cleanup(effect)

              if (effect.options.onStop) {
                effect.options.onStop()
              }

              effect.active = false
            }
          }

          var uid = 0

          function createReactiveEffect(fn, options) {
            var effect = function reactiveEffect() {
              if (!effect.active) {
                return options.scheduler ? undefined : fn()
              }

              if (!effectStack.includes(effect)) {
                cleanup(effect)

                try {
                  enableTracking()
                  effectStack.push(effect)
                  activeEffect = effect
                  return fn()
                } finally {
                  effectStack.pop()
                  resetTracking()
                  activeEffect = effectStack[effectStack.length - 1]
                }
              }
            }

            effect.id = uid++
            effect.allowRecurse = !!options.allowRecurse
            effect._isEffect = true
            effect.active = true
            effect.raw = fn
            effect.deps = []
            effect.options = options
            return effect
          }

          function cleanup(effect) {
            var deps = effect.deps

            if (deps.length) {
              for (var i = 0; i < deps.length; i++) {
                deps[i]['delete'](effect)
              }

              deps.length = 0
            }
          }

          var shouldTrack = true
          var trackStack = []

          function pauseTracking() {
            trackStack.push(shouldTrack)
            shouldTrack = false
          }

          function enableTracking() {
            trackStack.push(shouldTrack)
            shouldTrack = true
          }

          function resetTracking() {
            var last = trackStack.pop()
            shouldTrack = last === undefined ? true : last
          }

          function track(target, type, key) {
            if (!shouldTrack || activeEffect === undefined) {
              return
            }

            var depsMap = targetMap.get(target)

            if (!depsMap) {
              targetMap.set(target, (depsMap = new Map()))
            }

            var dep = depsMap.get(key)

            if (!dep) {
              depsMap.set(key, (dep = new Set()))
            }

            if (!dep.has(activeEffect)) {
              dep.add(activeEffect)
              activeEffect.deps.push(dep)

              if (activeEffect.options.onTrack) {
                activeEffect.options.onTrack({
                  effect: activeEffect,
                  target: target,
                  type: type,
                  key: key
                })
              }
            }
          }

          function trigger(target, type, key, newValue, oldValue, oldTarget) {
            var depsMap = targetMap.get(target)

            if (!depsMap) {
              // never been tracked
              return
            }

            var effects = new Set()

            var add = function add(effectsToAdd) {
              if (effectsToAdd) {
                effectsToAdd.forEach(function(effect) {
                  if (effect !== activeEffect || effect.allowRecurse) {
                    effects.add(effect)
                  }
                })
              }
            }

            if (
              type === 'clear'
              /* CLEAR */
            ) {
              // collection being cleared
              // trigger all effects for target
              depsMap.forEach(add)
            } else if (key === 'length' && isArray(target)) {
              depsMap.forEach(function(dep, key) {
                if (key === 'length' || key >= newValue) {
                  add(dep)
                }
              })
            } else {
              // schedule runs for SET | ADD | DELETE
              if (key !== void 0) {
                add(depsMap.get(key))
              } // also run for iteration key on ADD | DELETE | Map.SET

              switch (type) {
                case 'add':
                  /* ADD */
                  if (!isArray(target)) {
                    add(depsMap.get(ITERATE_KEY))

                    if (isMap(target)) {
                      add(depsMap.get(MAP_KEY_ITERATE_KEY))
                    }
                  } else if (isIntegerKey(key)) {
                    // new index added to array -> length changes
                    add(depsMap.get('length'))
                  }

                  break

                case 'delete':
                  /* DELETE */
                  if (!isArray(target)) {
                    add(depsMap.get(ITERATE_KEY))

                    if (isMap(target)) {
                      add(depsMap.get(MAP_KEY_ITERATE_KEY))
                    }
                  }

                  break

                case 'set':
                  /* SET */
                  if (isMap(target)) {
                    add(depsMap.get(ITERATE_KEY))
                  }

                  break
              }
            }

            var run = function run(effect) {
              if (effect.options.onTrigger) {
                effect.options.onTrigger({
                  effect: effect,
                  target: target,
                  key: key,
                  type: type,
                  newValue: newValue,
                  oldValue: oldValue,
                  oldTarget: oldTarget
                })
              }

              if (effect.options.scheduler) {
                effect.options.scheduler(effect)
              } else {
                effect()
              }
            }

            effects.forEach(run)
          }

          var isNonTrackableKeys = /*#__PURE__*/ makeMap(
            '__proto__,__v_isRef,__isVue'
          )
          var builtInSymbols = new Set(
            Object.getOwnPropertyNames(Symbol)
              .map(function(key) {
                return Symbol[key]
              })
              .filter(isSymbol)
          )
          var get = /*#__PURE__*/ createGetter()
          var shallowGet = /*#__PURE__*/ createGetter(false, true)
          var readonlyGet = /*#__PURE__*/ createGetter(true)
          var shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)
          var arrayInstrumentations = {}
          ;['includes', 'indexOf', 'lastIndexOf'].forEach(function(key) {
            var method = Array.prototype[key]

            arrayInstrumentations[key] = function() {
              var arr = toRaw(this)

              for (var i = 0, l = this.length; i < l; i++) {
                track(
                  arr,
                  'get',
                  /* GET */
                  i + ''
                )
              } // we run the method using the original args first (which may be reactive)

              for (
                var _len = arguments.length, args = new Array(_len), _key2 = 0;
                _key2 < _len;
                _key2++
              ) {
                args[_key2] = arguments[_key2]
              }

              var res = method.apply(arr, args)

              if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return method.apply(arr, args.map(toRaw))
              } else {
                return res
              }
            }
          })
          ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function(key) {
            var method = Array.prototype[key]

            arrayInstrumentations[key] = function() {
              pauseTracking()

              for (
                var _len2 = arguments.length,
                  args = new Array(_len2),
                  _key3 = 0;
                _key3 < _len2;
                _key3++
              ) {
                args[_key3] = arguments[_key3]
              }

              var res = method.apply(this, args)
              resetTracking()
              return res
            }
          })

          function createGetter() {
            var isReadonly =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : false
            var shallow =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false
            return function get(target, key, receiver) {
              if (
                key === '__v_isReactive'
                /* IS_REACTIVE */
              ) {
                return !isReadonly
              } else if (
                key === '__v_isReadonly'
                /* IS_READONLY */
              ) {
                return isReadonly
              } else if (
                key === '__v_raw' &&
                /* RAW */
                receiver ===
                  (isReadonly ? readonlyMap : reactiveMap).get(target)
              ) {
                return target
              }

              var targetIsArray = isArray(target)

              if (
                !isReadonly &&
                targetIsArray &&
                hasOwn(arrayInstrumentations, key)
              ) {
                return Reflect.get(arrayInstrumentations, key, receiver)
              }

              var res = Reflect.get(target, key, receiver)

              if (
                isSymbol(key)
                  ? builtInSymbols.has(key)
                  : isNonTrackableKeys(key)
              ) {
                return res
              }

              if (!isReadonly) {
                track(
                  target,
                  'get',
                  /* GET */
                  key
                )
              }

              if (shallow) {
                return res
              }

              if (isRef(res)) {
                // ref unwrapping - does not apply for Array + integer key.
                var shouldUnwrap = !targetIsArray || !isIntegerKey(key)
                return shouldUnwrap ? res.value : res
              }

              if (isObject(res)) {
                // Convert returned value into a proxy as well. we do the isObject check
                // here to avoid invalid value warning. Also need to lazy access readonly
                // and reactive here to avoid circular dependency.
                return isReadonly ? readonly(res) : reactive(res)
              }

              return res
            }
          }

          var set = /*#__PURE__*/ createSetter()
          var shallowSet = /*#__PURE__*/ createSetter(true)

          function createSetter() {
            var shallow =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : false
            return function set(target, key, value, receiver) {
              var oldValue = target[key]

              if (!shallow) {
                value = toRaw(value)

                if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
                  oldValue.value = value
                  return true
                }
              }

              var hadKey =
                isArray(target) && isIntegerKey(key)
                  ? Number(key) < target.length
                  : hasOwn(target, key)
              var result = Reflect.set(target, key, value, receiver) // don't trigger if target is something up in the prototype chain of original

              if (target === toRaw(receiver)) {
                if (!hadKey) {
                  trigger(
                    target,
                    'add',
                    /* ADD */
                    key,
                    value
                  )
                } else if (hasChanged(value, oldValue)) {
                  trigger(
                    target,
                    'set',
                    /* SET */
                    key,
                    value,
                    oldValue
                  )
                }
              }

              return result
            }
          }

          function deleteProperty(target, key) {
            var hadKey = hasOwn(target, key)
            var oldValue = target[key]
            var result = Reflect.deleteProperty(target, key)

            if (result && hadKey) {
              trigger(
                target,
                'delete',
                /* DELETE */
                key,
                undefined,
                oldValue
              )
            }

            return result
          }

          function has(target, key) {
            var result = Reflect.has(target, key)

            if (!isSymbol(key) || !builtInSymbols.has(key)) {
              track(
                target,
                'has',
                /* HAS */
                key
              )
            }

            return result
          }

          function ownKeys(target) {
            track(
              target,
              'iterate',
              /* ITERATE */
              isArray(target) ? 'length' : ITERATE_KEY
            )
            return Reflect.ownKeys(target)
          }

          var mutableHandlers = {
            get: get,
            set: set,
            deleteProperty: deleteProperty,
            has: has,
            ownKeys: ownKeys
          }
          var readonlyHandlers = {
            get: readonlyGet,
            set: function set(target, key) {
              {
                console.warn(
                  'Set operation on key "'.concat(
                    String(key),
                    '" failed: target is readonly.'
                  ),
                  target
                )
              }
              return true
            },
            deleteProperty: function deleteProperty(target, key) {
              {
                console.warn(
                  'Delete operation on key "'.concat(
                    String(key),
                    '" failed: target is readonly.'
                  ),
                  target
                )
              }
              return true
            }
          }
          var shallowReactiveHandlers = extend({}, mutableHandlers, {
            get: shallowGet,
            set: shallowSet
          }) // Props handlers are special in the sense that it should not unwrap top-level
          // refs (in order to allow refs to be explicitly passed down), but should
          // retain the reactivity of the normal readonly object.

          var shallowReadonlyHandlers = extend({}, readonlyHandlers, {
            get: shallowReadonlyGet
          })

          var toReactive = function toReactive(value) {
            return isObject(value) ? reactive(value) : value
          }

          var toReadonly = function toReadonly(value) {
            return isObject(value) ? readonly(value) : value
          }

          var toShallow = function toShallow(value) {
            return value
          }

          var getProto = function getProto(v) {
            return Reflect.getPrototypeOf(v)
          }

          function get$1(target, key) {
            var isReadonly =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : false
            var isShallow =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : false
            // #1772: readonly(reactive(Map)) should return readonly + reactive version
            // of the value
            target =
              target[
                '__v_raw'
                /* RAW */
              ]
            var rawTarget = toRaw(target)
            var rawKey = toRaw(key)

            if (key !== rawKey) {
              !isReadonly &&
                track(
                  rawTarget,
                  'get',
                  /* GET */
                  key
                )
            }

            !isReadonly &&
              track(
                rawTarget,
                'get',
                /* GET */
                rawKey
              )

            var _getProto = getProto(rawTarget),
              has = _getProto.has

            var wrap = isReadonly
              ? toReadonly
              : isShallow
                ? toShallow
                : toReactive

            if (has.call(rawTarget, key)) {
              return wrap(target.get(key))
            } else if (has.call(rawTarget, rawKey)) {
              return wrap(target.get(rawKey))
            }
          }

          function has$1(key) {
            var isReadonly =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false
            var target = this[
              '__v_raw'
              /* RAW */
            ]
            var rawTarget = toRaw(target)
            var rawKey = toRaw(key)

            if (key !== rawKey) {
              !isReadonly &&
                track(
                  rawTarget,
                  'has',
                  /* HAS */
                  key
                )
            }

            !isReadonly &&
              track(
                rawTarget,
                'has',
                /* HAS */
                rawKey
              )
            return key === rawKey
              ? target.has(key)
              : target.has(key) || target.has(rawKey)
          }

          function size(target) {
            var isReadonly =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false
            target =
              target[
                '__v_raw'
                /* RAW */
              ]
            !isReadonly &&
              track(
                toRaw(target),
                'iterate',
                /* ITERATE */
                ITERATE_KEY
              )
            return Reflect.get(target, 'size', target)
          }

          function add(value) {
            value = toRaw(value)
            var target = toRaw(this)
            var proto = getProto(target)
            var hadKey = proto.has.call(target, value)
            target.add(value)

            if (!hadKey) {
              trigger(
                target,
                'add',
                /* ADD */
                value,
                value
              )
            }

            return this
          }

          function set$1(key, value) {
            value = toRaw(value)
            var target = toRaw(this)

            var _getProto2 = getProto(target),
              has = _getProto2.has,
              get = _getProto2.get

            var hadKey = has.call(target, key)

            if (!hadKey) {
              key = toRaw(key)
              hadKey = has.call(target, key)
            } else {
              checkIdentityKeys(target, has, key)
            }

            var oldValue = get.call(target, key)
            target.set(key, value)

            if (!hadKey) {
              trigger(
                target,
                'add',
                /* ADD */
                key,
                value
              )
            } else if (hasChanged(value, oldValue)) {
              trigger(
                target,
                'set',
                /* SET */
                key,
                value,
                oldValue
              )
            }

            return this
          }

          function deleteEntry(key) {
            var target = toRaw(this)

            var _getProto3 = getProto(target),
              has = _getProto3.has,
              get = _getProto3.get

            var hadKey = has.call(target, key)

            if (!hadKey) {
              key = toRaw(key)
              hadKey = has.call(target, key)
            } else {
              checkIdentityKeys(target, has, key)
            }

            var oldValue = get ? get.call(target, key) : undefined // forward the operation before queueing reactions

            var result = target['delete'](key)

            if (hadKey) {
              trigger(
                target,
                'delete',
                /* DELETE */
                key,
                undefined,
                oldValue
              )
            }

            return result
          }

          function clear() {
            var target = toRaw(this)
            var hadItems = target.size !== 0
            var oldTarget = isMap(target) ? new Map(target) : new Set(target) // forward the operation before queueing reactions

            var result = target.clear()

            if (hadItems) {
              trigger(
                target,
                'clear',
                /* CLEAR */
                undefined,
                undefined,
                oldTarget
              )
            }

            return result
          }

          function createForEach(isReadonly, isShallow) {
            return function forEach(callback, thisArg) {
              var observed = this
              var target =
                observed[
                  '__v_raw'
                  /* RAW */
                ]
              var rawTarget = toRaw(target)
              var wrap = isReadonly
                ? toReadonly
                : isShallow
                  ? toShallow
                  : toReactive
              !isReadonly &&
                track(
                  rawTarget,
                  'iterate',
                  /* ITERATE */
                  ITERATE_KEY
                )
              return target.forEach(function(value, key) {
                // important: make sure the callback is
                // 1. invoked with the reactive map as `this` and 3rd arg
                // 2. the value received should be a corresponding reactive/readonly.
                return callback.call(thisArg, wrap(value), wrap(key), observed)
              })
            }
          }

          function createIterableMethod(method, isReadonly, isShallow) {
            return function() {
              var target = this[
                '__v_raw'
                /* RAW */
              ]
              var rawTarget = toRaw(target)
              var targetIsMap = isMap(rawTarget)
              var isPair =
                method === 'entries' ||
                (method === Symbol.iterator && targetIsMap)
              var isKeyOnly = method === 'keys' && targetIsMap
              var innerIterator = target[method].apply(target, arguments)
              var wrap = isReadonly
                ? toReadonly
                : isShallow
                  ? toShallow
                  : toReactive
              !isReadonly &&
                track(
                  rawTarget,
                  'iterate',
                  /* ITERATE */
                  isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
                ) // return a wrapped iterator which returns observed versions of the
              // values emitted from the real iterator

              return _defineProperty(
                {
                  // iterator protocol
                  next: function next() {
                    var _innerIterator$next = innerIterator.next(),
                      value = _innerIterator$next.value,
                      done = _innerIterator$next.done

                    return done
                      ? {
                          value: value,
                          done: done
                        }
                      : {
                          value: isPair
                            ? [wrap(value[0]), wrap(value[1])]
                            : wrap(value),
                          done: done
                        }
                  }
                },
                Symbol.iterator,
                function() {
                  return this
                }
              )
            }
          }

          function createReadonlyMethod(type) {
            return function() {
              {
                var key = (arguments.length <= 0
                ? undefined
                : arguments[0])
                  ? 'on key "'.concat(
                      arguments.length <= 0 ? undefined : arguments[0],
                      '" '
                    )
                  : ''
                console.warn(
                  ''
                    .concat(capitalize(type), ' operation ')
                    .concat(key, 'failed: target is readonly.'),
                  toRaw(this)
                )
              }
              return type === 'delete'
                ? /* DELETE */
                  false
                : this
            }
          }

          var mutableInstrumentations = {
            get: function get(key) {
              return get$1(this, key)
            },

            get size() {
              return size(this)
            },

            has: has$1,
            add: add,
            set: set$1,
            delete: deleteEntry,
            clear: clear,
            forEach: createForEach(false, false)
          }
          var shallowInstrumentations = {
            get: function get(key) {
              return get$1(this, key, false, true)
            },

            get size() {
              return size(this)
            },

            has: has$1,
            add: add,
            set: set$1,
            delete: deleteEntry,
            clear: clear,
            forEach: createForEach(false, true)
          }
          var readonlyInstrumentations = {
            get: function get(key) {
              return get$1(this, key, true)
            },

            get size() {
              return size(this, true)
            },

            has: function has(key) {
              return has$1.call(this, key, true)
            },
            add: createReadonlyMethod(
              'add'
              /* ADD */
            ),
            set: createReadonlyMethod(
              'set'
              /* SET */
            ),
            delete: createReadonlyMethod(
              'delete'
              /* DELETE */
            ),
            clear: createReadonlyMethod(
              'clear'
              /* CLEAR */
            ),
            forEach: createForEach(true, false)
          }
          var iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]
          iteratorMethods.forEach(function(method) {
            mutableInstrumentations[method] = createIterableMethod(
              method,
              false,
              false
            )
            readonlyInstrumentations[method] = createIterableMethod(
              method,
              true,
              false
            )
            shallowInstrumentations[method] = createIterableMethod(
              method,
              false,
              true
            )
          })

          function createInstrumentationGetter(isReadonly, shallow) {
            var instrumentations = shallow
              ? shallowInstrumentations
              : isReadonly
                ? readonlyInstrumentations
                : mutableInstrumentations
            return function(target, key, receiver) {
              if (
                key === '__v_isReactive'
                /* IS_REACTIVE */
              ) {
                return !isReadonly
              } else if (
                key === '__v_isReadonly'
                /* IS_READONLY */
              ) {
                return isReadonly
              } else if (
                key === '__v_raw'
                /* RAW */
              ) {
                return target
              }

              return Reflect.get(
                hasOwn(instrumentations, key) && key in target
                  ? instrumentations
                  : target,
                key,
                receiver
              )
            }
          }

          var mutableCollectionHandlers = {
            get: createInstrumentationGetter(false, false)
          }
          var shallowCollectionHandlers = {
            get: createInstrumentationGetter(false, true)
          }
          var readonlyCollectionHandlers = {
            get: createInstrumentationGetter(true, false)
          }

          function checkIdentityKeys(target, has, key) {
            var rawKey = toRaw(key)

            if (rawKey !== key && has.call(target, rawKey)) {
              var type = toRawType(target)
              console.warn(
                'Reactive '.concat(
                  type,
                  ' contains both the raw and reactive '
                ) +
                  'versions of the same object'.concat(
                    type === 'Map' ? ' as keys' : '',
                    ', '
                  ) +
                  'which can lead to inconsistencies. ' +
                  'Avoid differentiating between the raw and reactive versions ' +
                  'of an object and only use the reactive version if possible.'
              )
            }
          }

          var reactiveMap = new WeakMap()
          var readonlyMap = new WeakMap()

          function targetTypeMap(rawType) {
            switch (rawType) {
              case 'Object':
              case 'Array':
                return 1
                /* COMMON */

              case 'Map':
              case 'Set':
              case 'WeakMap':
              case 'WeakSet':
                return 2
                /* COLLECTION */

              default:
                return 0
                /* INVALID */
            }
          }

          function getTargetType(value) {
            return value[
              '__v_skip'
              /* SKIP */
            ] || !Object.isExtensible(value)
              ? 0
              : /* INVALID */
                targetTypeMap(toRawType(value))
          }

          function reactive(target) {
            // if trying to observe a readonly proxy, return the readonly version.
            if (
              target &&
              target[
                '__v_isReadonly'
                /* IS_READONLY */
              ]
            ) {
              return target
            }

            return createReactiveObject(
              target,
              false,
              mutableHandlers,
              mutableCollectionHandlers
            )
          }
          /**
           * Return a shallowly-reactive copy of the original object, where only the root
           * level properties are reactive. It also does not auto-unwrap refs (even at the
           * root level).
           */

          function shallowReactive(target) {
            return createReactiveObject(
              target,
              false,
              shallowReactiveHandlers,
              shallowCollectionHandlers
            )
          }
          /**
           * Creates a readonly copy of the original object. Note the returned copy is not
           * made reactive, but `readonly` can be called on an already reactive object.
           */

          function readonly(target) {
            return createReactiveObject(
              target,
              true,
              readonlyHandlers,
              readonlyCollectionHandlers
            )
          }
          /**
           * Returns a reactive-copy of the original object, where only the root level
           * properties are readonly, and does NOT unwrap refs nor recursively convert
           * returned properties.
           * This is used for creating the props proxy object for stateful components.
           */

          function shallowReadonly(target) {
            return createReactiveObject(
              target,
              true,
              shallowReadonlyHandlers,
              readonlyCollectionHandlers
            )
          }

          function createReactiveObject(
            target,
            isReadonly,
            baseHandlers,
            collectionHandlers
          ) {
            if (!isObject(target)) {
              {
                console.warn(
                  'value cannot be made reactive: '.concat(String(target))
                )
              }
              return target
            } // target is already a Proxy, return it.
            // exception: calling readonly() on a reactive object

            if (
              target[
                '__v_raw'
                /* RAW */
              ] &&
              !(
                isReadonly &&
                target[
                  '__v_isReactive'
                  /* IS_REACTIVE */
                ]
              )
            ) {
              return target
            } // target already has corresponding Proxy

            var proxyMap = isReadonly ? readonlyMap : reactiveMap
            var existingProxy = proxyMap.get(target)

            if (existingProxy) {
              return existingProxy
            } // only a whitelist of value types can be observed.

            var targetType = getTargetType(target)

            if (
              targetType === 0
              /* INVALID */
            ) {
              return target
            }

            var proxy = new Proxy(
              target,
              targetType === 2
                ? /* COLLECTION */
                  collectionHandlers
                : baseHandlers
            )
            proxyMap.set(target, proxy)
            return proxy
          }

          function isReactive(value) {
            if (isReadonly(value)) {
              return isReactive(
                value[
                  '__v_raw'
                  /* RAW */
                ]
              )
            }

            return !!(
              value &&
              value[
                '__v_isReactive'
                /* IS_REACTIVE */
              ]
            )
          }

          function isReadonly(value) {
            return !!(
              value &&
              value[
                '__v_isReadonly'
                /* IS_READONLY */
              ]
            )
          }

          function isProxy(value) {
            return isReactive(value) || isReadonly(value)
          }

          function toRaw(observed) {
            return (
              (observed &&
                toRaw(
                  observed[
                    '__v_raw'
                    /* RAW */
                  ]
                )) ||
              observed
            )
          }

          function markRaw(value) {
            def(
              value,
              '__v_skip',
              /* SKIP */
              true
            )
            return value
          }

          var convert = function convert(val) {
            return isObject(val) ? reactive(val) : val
          }

          function isRef(r) {
            return Boolean(r && r.__v_isRef === true)
          }

          function ref(value) {
            return createRef(value)
          }

          function shallowRef(value) {
            return createRef(value, true)
          }

          var RefImpl = /*#__PURE__*/ (function() {
            function RefImpl(_rawValue) {
              var _shallow =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : false

              _classCallCheck(this, RefImpl)

              this._rawValue = _rawValue
              this._shallow = _shallow
              this.__v_isRef = true
              this._value = _shallow ? _rawValue : convert(_rawValue)
            }

            _createClass(RefImpl, [
              {
                key: 'value',
                get: function get() {
                  track(
                    toRaw(this),
                    'get',
                    /* GET */
                    'value'
                  )
                  return this._value
                },
                set: function set(newVal) {
                  if (hasChanged(toRaw(newVal), this._rawValue)) {
                    this._rawValue = newVal
                    this._value = this._shallow ? newVal : convert(newVal)
                    trigger(
                      toRaw(this),
                      'set',
                      /* SET */
                      'value',
                      newVal
                    )
                  }
                }
              }
            ])

            return RefImpl
          })()

          function createRef(rawValue) {
            var shallow =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false

            if (isRef(rawValue)) {
              return rawValue
            }

            return new RefImpl(rawValue, shallow)
          }

          function triggerRef(ref) {
            trigger(
              toRaw(ref),
              'set',
              /* SET */
              'value',
              ref.value
            )
          }

          function unref(ref) {
            return isRef(ref) ? ref.value : ref
          }

          var shallowUnwrapHandlers = {
            get: function get(target, key, receiver) {
              return unref(Reflect.get(target, key, receiver))
            },
            set: function set(target, key, value, receiver) {
              var oldValue = target[key]

              if (isRef(oldValue) && !isRef(value)) {
                oldValue.value = value
                return true
              } else {
                return Reflect.set(target, key, value, receiver)
              }
            }
          }

          function proxyRefs(objectWithRefs) {
            return isReactive(objectWithRefs)
              ? objectWithRefs
              : new Proxy(objectWithRefs, shallowUnwrapHandlers)
          }

          var CustomRefImpl = /*#__PURE__*/ (function() {
            function CustomRefImpl(factory) {
              var _this = this

              _classCallCheck(this, CustomRefImpl)

              this.__v_isRef = true

              var _factory = factory(
                  function() {
                    return track(
                      _this,
                      'get',
                      /* GET */
                      'value'
                    )
                  },
                  function() {
                    return trigger(
                      _this,
                      'set',
                      /* SET */
                      'value'
                    )
                  }
                ),
                get = _factory.get,
                set = _factory.set

              this._get = get
              this._set = set
            }

            _createClass(CustomRefImpl, [
              {
                key: 'value',
                get: function get() {
                  return this._get()
                },
                set: function set(newVal) {
                  this._set(newVal)
                }
              }
            ])

            return CustomRefImpl
          })()

          function customRef(factory) {
            return new CustomRefImpl(factory)
          }

          function toRefs(object) {
            if (!isProxy(object)) {
              console.warn(
                'toRefs() expects a reactive object but received a plain one.'
              )
            }

            var ret = isArray(object) ? new Array(object.length) : {}

            for (var key in object) {
              ret[key] = toRef(object, key)
            }

            return ret
          }

          var ObjectRefImpl = /*#__PURE__*/ (function() {
            function ObjectRefImpl(_object, _key) {
              _classCallCheck(this, ObjectRefImpl)

              this._object = _object
              this._key = _key
              this.__v_isRef = true
            }

            _createClass(ObjectRefImpl, [
              {
                key: 'value',
                get: function get() {
                  return this._object[this._key]
                },
                set: function set(newVal) {
                  this._object[this._key] = newVal
                }
              }
            ])

            return ObjectRefImpl
          })()

          function toRef(object, key) {
            return isRef(object[key])
              ? object[key]
              : new ObjectRefImpl(object, key)
          }

          var ComputedRefImpl = /*#__PURE__*/ (function() {
            function ComputedRefImpl(getter, _setter, isReadonly) {
              var _this2 = this

              _classCallCheck(this, ComputedRefImpl)

              this._setter = _setter
              this._dirty = true
              this.__v_isRef = true
              this.effect = effect(getter, {
                lazy: true,
                scheduler: function scheduler() {
                  if (!_this2._dirty) {
                    _this2._dirty = true
                    trigger(
                      toRaw(_this2),
                      'set',
                      /* SET */
                      'value'
                    )
                  }
                }
              })
              this[
                '__v_isReadonly'
                /* IS_READONLY */
              ] = isReadonly
            }

            _createClass(ComputedRefImpl, [
              {
                key: 'value',
                get: function get() {
                  if (this._dirty) {
                    this._value = this.effect()
                    this._dirty = false
                  }

                  track(
                    toRaw(this),
                    'get',
                    /* GET */
                    'value'
                  )
                  return this._value
                },
                set: function set(newValue) {
                  this._setter(newValue)
                }
              }
            ])

            return ComputedRefImpl
          })()

          function computed(getterOrOptions) {
            var getter
            var setter

            if (isFunction(getterOrOptions)) {
              getter = getterOrOptions

              setter = function setter() {
                console.warn(
                  'Write operation failed: computed value is readonly'
                )
              }
            } else {
              getter = getterOrOptions.get
              setter = getterOrOptions.set
            }

            return new ComputedRefImpl(
              getter,
              setter,
              isFunction(getterOrOptions) || !getterOrOptions.set
            )
          }

          var stack = []

          function pushWarningContext(vnode) {
            stack.push(vnode)
          }

          function popWarningContext() {
            stack.pop()
          }

          function warn(msg) {
            // avoid props formatting or warn handler tracking deps that might be mutated
            // during patch, leading to infinite recursion.
            pauseTracking()
            var instance = stack.length
              ? stack[stack.length - 1].component
              : null
            var appWarnHandler =
              instance && instance.appContext.config.warnHandler
            var trace = getComponentTrace()

            for (
              var _len3 = arguments.length,
                args = new Array(_len3 > 1 ? _len3 - 1 : 0),
                _key4 = 1;
              _key4 < _len3;
              _key4++
            ) {
              args[_key4 - 1] = arguments[_key4]
            }

            if (appWarnHandler) {
              callWithErrorHandling(
                appWarnHandler,
                instance,
                11,
                /* APP_WARN_HANDLER */
                [
                  msg + args.join(''),
                  instance && instance.proxy,
                  trace
                    .map(function(_ref6) {
                      var vnode = _ref6.vnode
                      return 'at <'.concat(
                        formatComponentName(instance, vnode.type),
                        '>'
                      )
                    })
                    .join('\n'),
                  trace
                ]
              )
            } else {
              var _console

              var warnArgs = ['[Vue warn]: '.concat(msg)].concat(args)
              /* istanbul ignore if */

              if (
                trace.length && // avoid spamming console during tests
                !false
              ) {
                warnArgs.push.apply(
                  warnArgs,
                  ['\n'].concat(_toConsumableArray(formatTrace(trace)))
                )
              }

              ;(_console = console).warn.apply(
                _console,
                _toConsumableArray(warnArgs)
              )
            }

            resetTracking()
          }

          function getComponentTrace() {
            var currentVNode = stack[stack.length - 1]

            if (!currentVNode) {
              return []
            } // we can't just use the stack because it will be incomplete during updates
            // that did not start from the root. Re-construct the parent chain using
            // instance parent pointers.

            var normalizedStack = []

            while (currentVNode) {
              var last = normalizedStack[0]

              if (last && last.vnode === currentVNode) {
                last.recurseCount++
              } else {
                normalizedStack.push({
                  vnode: currentVNode,
                  recurseCount: 0
                })
              }

              var parentInstance =
                currentVNode.component && currentVNode.component.parent
              currentVNode = parentInstance && parentInstance.vnode
            }

            return normalizedStack
          }
          /* istanbul ignore next */

          function formatTrace(trace) {
            var logs = []
            trace.forEach(function(entry, i) {
              logs.push.apply(
                logs,
                _toConsumableArray(i === 0 ? [] : ['\n']).concat(
                  _toConsumableArray(formatTraceEntry(entry))
                )
              )
            })
            return logs
          }

          function formatTraceEntry(_ref7) {
            var vnode = _ref7.vnode,
              recurseCount = _ref7.recurseCount
            var postfix =
              recurseCount > 0
                ? '... ('.concat(recurseCount, ' recursive calls)')
                : ''
            var isRoot = vnode.component
              ? vnode.component.parent == null
              : false
            var open = ' at <'.concat(
              formatComponentName(vnode.component, vnode.type, isRoot)
            )
            var close = '>' + postfix
            return vnode.props
              ? [open].concat(_toConsumableArray(formatProps(vnode.props)), [
                  close
                ])
              : [open + close]
          }
          /* istanbul ignore next */

          function formatProps(props) {
            var res = []
            var keys = Object.keys(props)
            keys.slice(0, 3).forEach(function(key) {
              res.push.apply(
                res,
                _toConsumableArray(formatProp(key, props[key]))
              )
            })

            if (keys.length > 3) {
              res.push(' ...')
            }

            return res
          }
          /* istanbul ignore next */

          function formatProp(key, value, raw) {
            if (isString(value)) {
              value = JSON.stringify(value)
              return raw ? value : [''.concat(key, '=').concat(value)]
            } else if (
              typeof value === 'number' ||
              typeof value === 'boolean' ||
              value == null
            ) {
              return raw ? value : [''.concat(key, '=').concat(value)]
            } else if (isRef(value)) {
              value = formatProp(key, toRaw(value.value), true)
              return raw ? value : [''.concat(key, '=Ref<'), value, '>']
            } else if (isFunction(value)) {
              return [
                ''
                  .concat(key, '=fn')
                  .concat(value.name ? '<'.concat(value.name, '>') : '')
              ]
            } else {
              value = toRaw(value)
              return raw ? value : [''.concat(key, '='), value]
            }
          }

          var ErrorTypeStrings = ((_ErrorTypeStrings = {}),
          _defineProperty(
            _ErrorTypeStrings,
            'bc',
            /* BEFORE_CREATE */
            'beforeCreate hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'c',
            /* CREATED */
            'created hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'bm',
            /* BEFORE_MOUNT */
            'beforeMount hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'm',
            /* MOUNTED */
            'mounted hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'bu',
            /* BEFORE_UPDATE */
            'beforeUpdate hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'u',
            /* UPDATED */
            'updated'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'bum',
            /* BEFORE_UNMOUNT */
            'beforeUnmount hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'um',
            /* UNMOUNTED */
            'unmounted hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'a',
            /* ACTIVATED */
            'activated hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'da',
            /* DEACTIVATED */
            'deactivated hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'ec',
            /* ERROR_CAPTURED */
            'errorCaptured hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'rtc',
            /* RENDER_TRACKED */
            'renderTracked hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            'rtg',
            /* RENDER_TRIGGERED */
            'renderTriggered hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            0,
            /* SETUP_FUNCTION */
            'setup function'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            1,
            /* RENDER_FUNCTION */
            'render function'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            2,
            /* WATCH_GETTER */
            'watcher getter'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            3,
            /* WATCH_CALLBACK */
            'watcher callback'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            4,
            /* WATCH_CLEANUP */
            'watcher cleanup function'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            5,
            /* NATIVE_EVENT_HANDLER */
            'native event handler'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            6,
            /* COMPONENT_EVENT_HANDLER */
            'component event handler'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            7,
            /* VNODE_HOOK */
            'vnode hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            8,
            /* DIRECTIVE_HOOK */
            'directive hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            9,
            /* TRANSITION_HOOK */
            'transition hook'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            10,
            /* APP_ERROR_HANDLER */
            'app errorHandler'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            11,
            /* APP_WARN_HANDLER */
            'app warnHandler'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            12,
            /* FUNCTION_REF */
            'ref function'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            13,
            /* ASYNC_COMPONENT_LOADER */
            'async component loader'
          ),
          _defineProperty(
            _ErrorTypeStrings,
            14,
            /* SCHEDULER */
            'scheduler flush. This is likely a Vue internals bug. ' +
              'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
          ),
          _ErrorTypeStrings)

          function callWithErrorHandling(fn, instance, type, args) {
            var res

            try {
              res = args ? fn.apply(void 0, _toConsumableArray(args)) : fn()
            } catch (err) {
              handleError(err, instance, type)
            }

            return res
          }

          function callWithAsyncErrorHandling(fn, instance, type, args) {
            if (isFunction(fn)) {
              var res = callWithErrorHandling(fn, instance, type, args)

              if (res && isPromise(res)) {
                res['catch'](function(err) {
                  handleError(err, instance, type)
                })
              }

              return res
            }

            var values = []

            for (var i = 0; i < fn.length; i++) {
              values.push(
                callWithAsyncErrorHandling(fn[i], instance, type, args)
              )
            }

            return values
          }

          function handleError(err, instance, type) {
            var throwInDev =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : true
            var contextVNode = instance ? instance.vnode : null

            if (instance) {
              var cur = instance.parent // the exposed instance is the render proxy to keep it consistent with 2.x

              var exposedInstance = instance.proxy // in production the hook receives only the error code

              var errorInfo = ErrorTypeStrings[type]

              while (cur) {
                var errorCapturedHooks = cur.ec

                if (errorCapturedHooks) {
                  for (var i = 0; i < errorCapturedHooks.length; i++) {
                    if (
                      errorCapturedHooks[i](err, exposedInstance, errorInfo) ===
                      false
                    ) {
                      return
                    }
                  }
                }

                cur = cur.parent
              } // app-level handling

              var appErrorHandler = instance.appContext.config.errorHandler

              if (appErrorHandler) {
                callWithErrorHandling(
                  appErrorHandler,
                  null,
                  10,
                  /* APP_ERROR_HANDLER */
                  [err, exposedInstance, errorInfo]
                )
                return
              }
            }

            logError(err, type, contextVNode, throwInDev)
          }

          function logError(err, type, contextVNode) {
            var throwInDev =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : true
            {
              var info = ErrorTypeStrings[type]

              if (contextVNode) {
                pushWarningContext(contextVNode)
              }

              warn(
                'Unhandled error'.concat(
                  info ? ' during execution of '.concat(info) : ''
                )
              )

              if (contextVNode) {
                popWarningContext()
              } // crash in dev by default so it's more noticeable

              if (throwInDev) {
                throw err
              } else {
                console.error(err)
              }
            }
          }

          var isFlushing = false
          var isFlushPending = false
          var queue = []
          var flushIndex = 0
          var pendingPreFlushCbs = []
          var activePreFlushCbs = null
          var preFlushIndex = 0
          var pendingPostFlushCbs = []
          var activePostFlushCbs = null
          var postFlushIndex = 0
          var resolvedPromise = Promise.resolve()
          var currentFlushPromise = null
          var currentPreFlushParentJob = null
          var RECURSION_LIMIT = 100

          function nextTick(fn) {
            var p = currentFlushPromise || resolvedPromise
            return fn ? p.then(this ? fn.bind(this) : fn) : p
          }

          function queueJob(job) {
            // the dedupe search uses the startIndex argument of Array.includes()
            // by default the search index includes the current job that is being run
            // so it cannot recursively trigger itself again.
            // if the job is a watch() callback, the search will start with a +1 index to
            // allow it recursively trigger itself - it is the user's responsibility to
            // ensure it doesn't end up in an infinite loop.
            if (
              (!queue.length ||
                !queue.includes(
                  job,
                  isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
                )) &&
              job !== currentPreFlushParentJob
            ) {
              queue.push(job)
              queueFlush()
            }
          }

          function queueFlush() {
            if (!isFlushing && !isFlushPending) {
              isFlushPending = true
              currentFlushPromise = resolvedPromise.then(flushJobs)
            }
          }

          function invalidateJob(job) {
            var i = queue.indexOf(job)

            if (i > -1) {
              queue.splice(i, 1)
            }
          }

          function queueCb(cb, activeQueue, pendingQueue, index) {
            if (!isArray(cb)) {
              if (
                !activeQueue ||
                !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)
              ) {
                pendingQueue.push(cb)
              }
            } else {
              // if cb is an array, it is a component lifecycle hook which can only be
              // triggered by a job, which is already deduped in the main queue, so
              // we can skip duplicate check here to improve perf
              pendingQueue.push.apply(pendingQueue, _toConsumableArray(cb))
            }

            queueFlush()
          }

          function queuePreFlushCb(cb) {
            queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)
          }

          function queuePostFlushCb(cb) {
            queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)
          }

          function flushPreFlushCbs(seen) {
            var parentJob =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : null

            if (pendingPreFlushCbs.length) {
              currentPreFlushParentJob = parentJob
              activePreFlushCbs = _toConsumableArray(
                new Set(pendingPreFlushCbs)
              )
              pendingPreFlushCbs.length = 0
              {
                seen = seen || new Map()
              }

              for (
                preFlushIndex = 0;
                preFlushIndex < activePreFlushCbs.length;
                preFlushIndex++
              ) {
                {
                  checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])
                }
                activePreFlushCbs[preFlushIndex]()
              }

              activePreFlushCbs = null
              preFlushIndex = 0
              currentPreFlushParentJob = null // recursively flush until it drains

              flushPreFlushCbs(seen, parentJob)
            }
          }

          function flushPostFlushCbs(seen) {
            if (pendingPostFlushCbs.length) {
              var deduped = _toConsumableArray(new Set(pendingPostFlushCbs))

              pendingPostFlushCbs.length = 0 // #1947 already has active queue, nested flushPostFlushCbs call

              if (activePostFlushCbs) {
                var _activePostFlushCbs

                ;(_activePostFlushCbs = activePostFlushCbs).push.apply(
                  _activePostFlushCbs,
                  _toConsumableArray(deduped)
                )

                return
              }

              activePostFlushCbs = deduped
              {
                seen = seen || new Map()
              }
              activePostFlushCbs.sort(function(a, b) {
                return getId(a) - getId(b)
              })

              for (
                postFlushIndex = 0;
                postFlushIndex < activePostFlushCbs.length;
                postFlushIndex++
              ) {
                {
                  checkRecursiveUpdates(
                    seen,
                    activePostFlushCbs[postFlushIndex]
                  )
                }
                activePostFlushCbs[postFlushIndex]()
              }

              activePostFlushCbs = null
              postFlushIndex = 0
            }
          }

          var getId = function getId(job) {
            return job.id == null ? Infinity : job.id
          }

          function flushJobs(seen) {
            isFlushPending = false
            isFlushing = true
            {
              seen = seen || new Map()
            }
            flushPreFlushCbs(seen) // Sort queue before flush.
            // This ensures that:
            // 1. Components are updated from parent to child. (because parent is always
            //    created before the child so its render effect will have smaller
            //    priority number)
            // 2. If a component is unmounted during a parent component's update,
            //    its update can be skipped.

            queue.sort(function(a, b) {
              return getId(a) - getId(b)
            })

            try {
              for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
                var job = queue[flushIndex]

                if (job) {
                  if (true) {
                    checkRecursiveUpdates(seen, job)
                  }

                  callWithErrorHandling(
                    job,
                    null,
                    14
                    /* SCHEDULER */
                  )
                }
              }
            } finally {
              flushIndex = 0
              queue.length = 0
              flushPostFlushCbs(seen)
              isFlushing = false
              currentFlushPromise = null // some postFlushCb queued jobs!
              // keep flushing until it drains.

              if (queue.length || pendingPostFlushCbs.length) {
                flushJobs(seen)
              }
            }
          }

          function checkRecursiveUpdates(seen, fn) {
            if (!seen.has(fn)) {
              seen.set(fn, 1)
            } else {
              var count = seen.get(fn)

              if (count > RECURSION_LIMIT) {
                throw new Error(
                  'Maximum recursive updates exceeded. ' +
                    'This means you have a reactive effect that is mutating its own ' +
                    'dependencies and thus recursively triggering itself. Possible sources ' +
                    'include component template, render function, updated hook or ' +
                    'watcher source function.'
                )
              } else {
                seen.set(fn, count + 1)
              }
            }
          }
          /* eslint-disable no-restricted-globals */

          var isHmrUpdating = false
          var hmrDirtyComponents = new Set() // Expose the HMR runtime on the global object
          // This makes it entirely tree-shakable without polluting the exports and makes
          // it easier to be used in toolings like vue-loader
          // Note: for a component to be eligible for HMR it also needs the __hmrId option
          // to be set so that its instances can be registered / removed.

          {
            var globalObject =
              typeof global !== 'undefined'
                ? global
                : typeof self !== 'undefined'
                  ? self
                  : typeof window !== 'undefined'
                    ? window
                    : {}
            globalObject.__VUE_HMR_RUNTIME__ = {
              createRecord: tryWrap(createRecord),
              rerender: tryWrap(rerender),
              reload: tryWrap(reload)
            }
          }
          var map = new Map()

          function registerHMR(instance) {
            var id = instance.type.__hmrId
            var record = map.get(id)

            if (!record) {
              createRecord(id, instance.type)
              record = map.get(id)
            }

            record.instances.add(instance)
          }

          function unregisterHMR(instance) {
            map.get(instance.type.__hmrId).instances['delete'](instance)
          }

          function createRecord(id, component) {
            if (!component) {
              warn(
                'HMR API usage is out of date.\n' +
                  'Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ' +
                  'dependency that handles Vue SFC compilation.'
              )
              component = {}
            }

            if (map.has(id)) {
              return false
            }

            map.set(id, {
              component: isClassComponent(component)
                ? component.__vccOpts
                : component,
              instances: new Set()
            })
            return true
          }

          function rerender(id, newRender) {
            var record = map.get(id)
            if (!record) return
            if (newRender) record.component.render = newRender // Array.from creates a snapshot which avoids the set being mutated during
            // updates

            Array.from(record.instances).forEach(function(instance) {
              if (newRender) {
                instance.render = newRender
              }

              instance.renderCache = [] // this flag forces child components with slot content to update

              isHmrUpdating = true
              instance.update()
              isHmrUpdating = false
            })
          }

          function reload(id, newComp) {
            var record = map.get(id)
            if (!record) return // Array.from creates a snapshot which avoids the set being mutated during
            // updates

            var component = record.component,
              instances = record.instances

            if (!hmrDirtyComponents.has(component)) {
              // 1. Update existing comp definition to match new one
              newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp
              extend(component, newComp)

              for (var key in component) {
                if (!(key in newComp)) {
                  delete component[key]
                }
              } // 2. Mark component dirty. This forces the renderer to replace the component
              // on patch.

              hmrDirtyComponents.add(component) // 3. Make sure to unmark the component after the reload.

              queuePostFlushCb(function() {
                hmrDirtyComponents['delete'](component)
              })
            }

            Array.from(instances).forEach(function(instance) {
              if (instance.parent) {
                // 4. Force the parent instance to re-render. This will cause all updated
                // components to be unmounted and re-mounted. Queue the update so that we
                // don't end up forcing the same parent to re-render multiple times.
                queueJob(instance.parent.update)
              } else if (instance.appContext.reload) {
                // root instance mounted via createApp() has a reload method
                instance.appContext.reload()
              } else if (typeof window !== 'undefined') {
                // root instance inside tree created via raw render(). Force reload.
                window.location.reload()
              } else {
                console.warn(
                  '[HMR] Root or manually mounted instance modified. Full reload required.'
                )
              }
            })
          }

          function tryWrap(fn) {
            return function(id, arg) {
              try {
                return fn(id, arg)
              } catch (e) {
                console.error(e)
                console.warn(
                  '[HMR] Something went wrong during Vue component hot-reload. ' +
                    'Full reload required.'
                )
              }
            }
          }

          var devtools

          function setDevtoolsHook(hook) {
            devtools = hook
          }

          function devtoolsInitApp(app, version) {
            // TODO queue if devtools is undefined
            if (!devtools) return
            devtools.emit(
              'app:init',
              /* APP_INIT */
              app,
              version,
              {
                Fragment: Fragment,
                Text: Text,
                Comment: Comment,
                Static: Static
              }
            )
          }

          function devtoolsUnmountApp(app) {
            if (!devtools) return
            devtools.emit(
              'app:unmount',
              /* APP_UNMOUNT */
              app
            )
          }

          var devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(
            'component:added'
            /* COMPONENT_ADDED */
          )
          var devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook(
            'component:updated'
            /* COMPONENT_UPDATED */
          )
          var devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook(
            'component:removed'
            /* COMPONENT_REMOVED */
          )

          function createDevtoolsComponentHook(hook) {
            return function(component) {
              if (!devtools) return
              devtools.emit(
                hook,
                component.appContext.app,
                component.uid,
                component.parent ? component.parent.uid : undefined,
                component
              )
            }
          }

          function devtoolsComponentEmit(component, event, params) {
            if (!devtools) return
            devtools.emit(
              'component:emit',
              /* COMPONENT_EMIT */
              component.appContext.app,
              component,
              event,
              params
            )
          }

          function emit(instance, event) {
            var props = instance.vnode.props || EMPTY_OBJ

            for (
              var _len4 = arguments.length,
                rawArgs = new Array(_len4 > 2 ? _len4 - 2 : 0),
                _key5 = 2;
              _key5 < _len4;
              _key5++
            ) {
              rawArgs[_key5 - 2] = arguments[_key5]
            }

            {
              var emitsOptions = instance.emitsOptions,
                _instance$propsOption = _slicedToArray(
                  instance.propsOptions,
                  1
                ),
                propsOptions = _instance$propsOption[0]

              if (emitsOptions) {
                if (!(event in emitsOptions)) {
                  if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
                    warn(
                      'Component emitted event "'.concat(
                        event,
                        '" but it is neither declared in '
                      ) +
                        'the emits option nor as an "'.concat(
                          toHandlerKey(event),
                          '" prop.'
                        )
                    )
                  }
                } else {
                  var validator = emitsOptions[event]

                  if (isFunction(validator)) {
                    var isValid = validator.apply(void 0, rawArgs)

                    if (!isValid) {
                      warn(
                        'Invalid event arguments: event validation failed for event "'.concat(
                          event,
                          '".'
                        )
                      )
                    }
                  }
                }
              }
            }
            var args = rawArgs
            var isModelListener = event.startsWith('update:') // for v-model update:xxx events, apply modifiers on args

            var modelArg = isModelListener && event.slice(7)

            if (modelArg && modelArg in props) {
              var modifiersKey = ''.concat(
                modelArg === 'modelValue' ? 'model' : modelArg,
                'Modifiers'
              )

              var _ref8 = props[modifiersKey] || EMPTY_OBJ,
                number = _ref8.number,
                trim = _ref8.trim

              if (trim) {
                args = rawArgs.map(function(a) {
                  return a.trim()
                })
              } else if (number) {
                args = rawArgs.map(toNumber)
              }
            }

            {
              devtoolsComponentEmit(instance, event, args)
            }
            {
              var lowerCaseEvent = event.toLowerCase()

              if (
                lowerCaseEvent !== event &&
                props[toHandlerKey(lowerCaseEvent)]
              ) {
                warn(
                  'Event "'.concat(
                    lowerCaseEvent,
                    '" is emitted in component '
                  ) +
                    ''
                      .concat(
                        formatComponentName(instance, instance.type),
                        ' but the handler is registered for "'
                      )
                      .concat(event, '". ') +
                    'Note that HTML attributes are case-insensitive and you cannot use ' +
                    'v-on to listen to camelCase events when using in-DOM templates. ' +
                    'You should probably use "'
                      .concat(hyphenate(event), '" instead of "')
                      .concat(event, '".')
                )
              }
            } // convert handler name to camelCase. See issue #2249

            var handlerName = toHandlerKey(camelize(event))
            var handler = props[handlerName] // for v-model update:xxx events, also trigger kebab-case equivalent
            // for props passed via kebab-case

            if (!handler && isModelListener) {
              handlerName = toHandlerKey(hyphenate(event))
              handler = props[handlerName]
            }

            if (handler) {
              callWithAsyncErrorHandling(
                handler,
                instance,
                6,
                /* COMPONENT_EVENT_HANDLER */
                args
              )
            }

            var onceHandler = props[handlerName + 'Once']

            if (onceHandler) {
              if (!instance.emitted) {
                ;(instance.emitted = {})[handlerName] = true
              } else if (instance.emitted[handlerName]) {
                return
              }

              callWithAsyncErrorHandling(
                onceHandler,
                instance,
                6,
                /* COMPONENT_EVENT_HANDLER */
                args
              )
            }
          }

          function normalizeEmitsOptions(comp, appContext) {
            var asMixin =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : false

            if (!appContext.deopt && comp.__emits !== undefined) {
              return comp.__emits
            }

            var raw = comp.emits
            var normalized = {} // apply mixin/extends props

            var hasExtends = false

            if (!isFunction(comp)) {
              var extendEmits = function extendEmits(raw) {
                hasExtends = true
                extend(normalized, normalizeEmitsOptions(raw, appContext, true))
              }

              if (!asMixin && appContext.mixins.length) {
                appContext.mixins.forEach(extendEmits)
              }

              if (comp['extends']) {
                extendEmits(comp['extends'])
              }

              if (comp.mixins) {
                comp.mixins.forEach(extendEmits)
              }
            }

            if (!raw && !hasExtends) {
              return (comp.__emits = null)
            }

            if (isArray(raw)) {
              raw.forEach(function(key) {
                return (normalized[key] = null)
              })
            } else {
              extend(normalized, raw)
            }

            return (comp.__emits = normalized)
          } // Check if an incoming prop key is a declared emit event listener.
          // e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
          // both considered matched listeners.

          function isEmitListener(options, key) {
            if (!options || !isOn(key)) {
              return false
            }

            key = key.slice(2).replace(/Once$/, '')
            return (
              hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||
              hasOwn(options, hyphenate(key)) ||
              hasOwn(options, key)
            )
          }
          /**
           * mark the current rendering instance for asset resolution (e.g.
           * resolveComponent, resolveDirective) during render
           */

          var currentRenderingInstance = null

          function setCurrentRenderingInstance(instance) {
            currentRenderingInstance = instance
          }
          /**
           * dev only flag to track whether $attrs was used during render.
           * If $attrs was used during render then the warning for failed attrs
           * fallthrough can be suppressed.
           */

          var accessedAttrs = false

          function markAttrsAccessed() {
            accessedAttrs = true
          }

          function renderComponentRoot(instance) {
            var Component = instance.type,
              vnode = instance.vnode,
              proxy = instance.proxy,
              withProxy = instance.withProxy,
              props = instance.props,
              _instance$propsOption2 = _slicedToArray(instance.propsOptions, 1),
              propsOptions = _instance$propsOption2[0],
              slots = instance.slots,
              attrs = instance.attrs,
              emit = instance.emit,
              render = instance.render,
              renderCache = instance.renderCache,
              data = instance.data,
              setupState = instance.setupState,
              ctx = instance.ctx

            var result
            currentRenderingInstance = instance
            {
              accessedAttrs = false
            }

            try {
              var fallthroughAttrs

              if (
                vnode.shapeFlag & 4
                /* STATEFUL_COMPONENT */
              ) {
                // withProxy is a proxy with a different `has` trap only for
                // runtime-compiled render functions using `with` block.
                var proxyToUse = withProxy || proxy
                result = normalizeVNode(
                  render.call(
                    proxyToUse,
                    proxyToUse,
                    renderCache,
                    props,
                    setupState,
                    data,
                    ctx
                  )
                )
                fallthroughAttrs = attrs
              } else {
                // functional
                var _render = Component // in dev, mark attrs accessed if optional props (attrs === props)

                if (true && attrs === props) {
                  markAttrsAccessed()
                }

                result = normalizeVNode(
                  _render.length > 1
                    ? _render(
                        props,
                        true
                          ? {
                              get attrs() {
                                markAttrsAccessed()
                                return attrs
                              },

                              slots: slots,
                              emit: emit
                            }
                          : undefined
                      )
                    : _render(
                        props,
                        null
                        /* we know it doesn't need it */
                      )
                )
                fallthroughAttrs = Component.props
                  ? attrs
                  : getFunctionalFallthrough(attrs)
              } // attr merging
              // in dev mode, comments are preserved, and it's possible for a template
              // to have comments along side the root element which makes it a fragment

              var root = result
              var setRoot = undefined

              if (
                true &&
                result.patchFlag > 0 &&
                result.patchFlag & 2048
                /* DEV_ROOT_FRAGMENT */
              ) {
                var _getChildRoot = getChildRoot(result)

                var _getChildRoot2 = _slicedToArray(_getChildRoot, 2)

                root = _getChildRoot2[0]
                setRoot = _getChildRoot2[1]
              }

              if (Component.inheritAttrs !== false && fallthroughAttrs) {
                var keys = Object.keys(fallthroughAttrs)
                var _root = root,
                  shapeFlag = _root.shapeFlag

                if (keys.length) {
                  if (
                    shapeFlag & 1 ||
                    /* ELEMENT */
                    shapeFlag & 6
                    /* COMPONENT */
                  ) {
                    if (propsOptions && keys.some(isModelListener)) {
                      // If a v-model listener (onUpdate:xxx) has a corresponding declared
                      // prop, it indicates this component expects to handle v-model and
                      // it should not fallthrough.
                      // related: #1543, #1643, #1989
                      fallthroughAttrs = filterModelListeners(
                        fallthroughAttrs,
                        propsOptions
                      )
                    }

                    root = cloneVNode(root, fallthroughAttrs)
                  } else if (true && !accessedAttrs && root.type !== Comment) {
                    var allAttrs = Object.keys(attrs)
                    var eventAttrs = []
                    var extraAttrs = []

                    for (var i = 0, l = allAttrs.length; i < l; i++) {
                      var key = allAttrs[i]

                      if (isOn(key)) {
                        // ignore v-model handlers when they fail to fallthrough
                        if (!isModelListener(key)) {
                          // remove `on`, lowercase first letter to reflect event casing
                          // accurately
                          eventAttrs.push(key[2].toLowerCase() + key.slice(3))
                        }
                      } else {
                        extraAttrs.push(key)
                      }
                    }

                    if (extraAttrs.length) {
                      warn(
                        'Extraneous non-props attributes (' +
                          ''.concat(extraAttrs.join(', '), ') ') +
                          'were passed to component but could not be automatically inherited ' +
                          'because component renders fragment or text root nodes.'
                      )
                    }

                    if (eventAttrs.length) {
                      warn(
                        'Extraneous non-emits event listeners (' +
                          ''.concat(eventAttrs.join(', '), ') ') +
                          'were passed to component but could not be automatically inherited ' +
                          'because component renders fragment or text root nodes. ' +
                          'If the listener is intended to be a component custom event listener only, ' +
                          'declare it using the "emits" option.'
                      )
                    }
                  }
                }
              } // inherit directives

              if (vnode.dirs) {
                if (true && !isElementRoot(root)) {
                  warn(
                    'Runtime directive used on component with non-element root node. ' +
                      'The directives will not function as intended.'
                  )
                }

                root.dirs = root.dirs
                  ? root.dirs.concat(vnode.dirs)
                  : vnode.dirs
              } // inherit transition data

              if (vnode.transition) {
                if (true && !isElementRoot(root)) {
                  warn(
                    'Component inside <Transition> renders non-element root node ' +
                      'that cannot be animated.'
                  )
                }

                root.transition = vnode.transition
              }

              if (true && setRoot) {
                setRoot(root)
              } else {
                result = root
              }
            } catch (err) {
              handleError(
                err,
                instance,
                1
                /* RENDER_FUNCTION */
              )
              result = createVNode(Comment)
            }

            currentRenderingInstance = null
            return result
          }
          /**
           * dev only
           * In dev mode, template root level comments are rendered, which turns the
           * template into a fragment root, but we need to locate the single element
           * root for attrs and scope id processing.
           */

          var getChildRoot = function getChildRoot(vnode) {
            var rawChildren = vnode.children
            var dynamicChildren = vnode.dynamicChildren
            var childRoot = filterSingleRoot(rawChildren)

            if (!childRoot) {
              return [vnode, undefined]
            }

            var index = rawChildren.indexOf(childRoot)
            var dynamicIndex = dynamicChildren
              ? dynamicChildren.indexOf(childRoot)
              : -1

            var setRoot = function setRoot(updatedRoot) {
              rawChildren[index] = updatedRoot

              if (dynamicChildren) {
                if (dynamicIndex > -1) {
                  dynamicChildren[dynamicIndex] = updatedRoot
                } else if (updatedRoot.patchFlag > 0) {
                  vnode.dynamicChildren = [].concat(
                    _toConsumableArray(dynamicChildren),
                    [updatedRoot]
                  )
                }
              }
            }

            return [normalizeVNode(childRoot), setRoot]
          }

          function filterSingleRoot(children) {
            var singleRoot

            for (var i = 0; i < children.length; i++) {
              var child = children[i]

              if (isVNode(child)) {
                // ignore user comment
                if (child.type !== Comment || child.children === 'v-if') {
                  if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return
                  } else {
                    singleRoot = child
                  }
                }
              } else {
                return
              }
            }

            return singleRoot
          }

          var getFunctionalFallthrough = function getFunctionalFallthrough(
            attrs
          ) {
            var res

            for (var key in attrs) {
              if (key === 'class' || key === 'style' || isOn(key)) {
                ;(res || (res = {}))[key] = attrs[key]
              }
            }

            return res
          }

          var filterModelListeners = function filterModelListeners(
            attrs,
            props
          ) {
            var res = {}

            for (var key in attrs) {
              if (!isModelListener(key) || !(key.slice(9) in props)) {
                res[key] = attrs[key]
              }
            }

            return res
          }

          var isElementRoot = function isElementRoot(vnode) {
            return (
              vnode.shapeFlag & 6 ||
              /* COMPONENT */
              vnode.shapeFlag & 1 ||
              /* ELEMENT */
              vnode.type === Comment // potential v-if branch switch
            )
          }

          function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
            var prevProps = prevVNode.props,
              prevChildren = prevVNode.children,
              component = prevVNode.component
            var nextProps = nextVNode.props,
              nextChildren = nextVNode.children,
              patchFlag = nextVNode.patchFlag
            var emits = component.emitsOptions // Parent component's render function was hot-updated. Since this may have
            // caused the child component's slots content to have changed, we need to
            // force the child to update as well.

            if ((prevChildren || nextChildren) && isHmrUpdating) {
              return true
            } // force child update for runtime directive or transition on component vnode.

            if (nextVNode.dirs || nextVNode.transition) {
              return true
            }

            if (optimized && patchFlag >= 0) {
              if (
                patchFlag & 1024
                /* DYNAMIC_SLOTS */
              ) {
                // slot content that references values that might have changed,
                // e.g. in a v-for
                return true
              }

              if (
                patchFlag & 16
                /* FULL_PROPS */
              ) {
                if (!prevProps) {
                  return !!nextProps
                } // presence of this flag indicates props are always non-null

                return hasPropsChanged(prevProps, nextProps, emits)
              } else if (
                patchFlag & 8
                /* PROPS */
              ) {
                var dynamicProps = nextVNode.dynamicProps

                for (var i = 0; i < dynamicProps.length; i++) {
                  var key = dynamicProps[i]

                  if (
                    nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)
                  ) {
                    return true
                  }
                }
              }
            } else {
              // this path is only taken by manually written render functions
              // so presence of any children leads to a forced update
              if (prevChildren || nextChildren) {
                if (!nextChildren || !nextChildren.$stable) {
                  return true
                }
              }

              if (prevProps === nextProps) {
                return false
              }

              if (!prevProps) {
                return !!nextProps
              }

              if (!nextProps) {
                return true
              }

              return hasPropsChanged(prevProps, nextProps, emits)
            }

            return false
          }

          function hasPropsChanged(prevProps, nextProps, emitsOptions) {
            var nextKeys = Object.keys(nextProps)

            if (nextKeys.length !== Object.keys(prevProps).length) {
              return true
            }

            for (var i = 0; i < nextKeys.length; i++) {
              var key = nextKeys[i]

              if (
                nextProps[key] !== prevProps[key] &&
                !isEmitListener(emitsOptions, key)
              ) {
                return true
              }
            }

            return false
          }

          function updateHOCHostEl(
            _ref9,
            el // HostNode
          ) {
            var vnode = _ref9.vnode,
              parent = _ref9.parent

            while (parent && parent.subTree === vnode) {
              ;(vnode = parent.vnode).el = el
              parent = parent.parent
            }
          }

          var isSuspense = function isSuspense(type) {
            return type.__isSuspense
          } // Suspense exposes a component-like API, and is treated like a component
          // in the compiler, but internally it's a special built-in type that hooks
          // directly into the renderer.

          var SuspenseImpl = {
            // In order to make Suspense tree-shakable, we need to avoid importing it
            // directly in the renderer. The renderer checks for the __isSuspense flag
            // on a vnode's type and calls the `process` method, passing in renderer
            // internals.
            __isSuspense: true,
            process: function process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized, // platform-specific impl passed from renderer
              rendererInternals
            ) {
              if (n1 == null) {
                mountSuspense(
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized,
                  rendererInternals
                )
              } else {
                patchSuspense(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  isSVG,
                  rendererInternals
                )
              }
            },
            hydrate: hydrateSuspense,
            create: createSuspenseBoundary
          } // Force-casted public typing for h and TSX props inference

          var Suspense = SuspenseImpl

          function mountSuspense(
            vnode,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            optimized,
            rendererInternals
          ) {
            var patch = rendererInternals.p,
              createElement = rendererInternals.o.createElement
            var hiddenContainer = createElement('div')
            var suspense = (vnode.suspense = createSuspenseBoundary(
              vnode,
              parentSuspense,
              parentComponent,
              container,
              hiddenContainer,
              anchor,
              isSVG,
              optimized,
              rendererInternals
            )) // start mounting the content subtree in an off-dom container

            patch(
              null,
              (suspense.pendingBranch = vnode.ssContent),
              hiddenContainer,
              null,
              parentComponent,
              suspense,
              isSVG
            ) // now check if we have encountered any async deps

            if (suspense.deps > 0) {
              // has async
              // mount the fallback tree
              patch(
                null,
                vnode.ssFallback,
                container,
                anchor,
                parentComponent,
                null, // fallback tree will not have suspense context
                isSVG
              )
              setActiveBranch(suspense, vnode.ssFallback)
            } else {
              // Suspense has no async deps. Just resolve.
              suspense.resolve()
            }
          }

          function patchSuspense(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            isSVG,
            _ref10
          ) {
            var patch = _ref10.p,
              unmount = _ref10.um,
              createElement = _ref10.o.createElement
            var suspense = (n2.suspense = n1.suspense)
            suspense.vnode = n2
            n2.el = n1.el
            var newBranch = n2.ssContent
            var newFallback = n2.ssFallback
            var activeBranch = suspense.activeBranch,
              pendingBranch = suspense.pendingBranch,
              isInFallback = suspense.isInFallback,
              isHydrating = suspense.isHydrating

            if (pendingBranch) {
              suspense.pendingBranch = newBranch

              if (isSameVNodeType(newBranch, pendingBranch)) {
                // same root type but content may have changed.
                patch(
                  pendingBranch,
                  newBranch,
                  suspense.hiddenContainer,
                  null,
                  parentComponent,
                  suspense,
                  isSVG
                )

                if (suspense.deps <= 0) {
                  suspense.resolve()
                } else if (isInFallback) {
                  patch(
                    activeBranch,
                    newFallback,
                    container,
                    anchor,
                    parentComponent,
                    null, // fallback tree will not have suspense context
                    isSVG
                  )
                  setActiveBranch(suspense, newFallback)
                }
              } else {
                // toggled before pending tree is resolved
                suspense.pendingId++

                if (isHydrating) {
                  // if toggled before hydration is finished, the current DOM tree is
                  // no longer valid. set it as the active branch so it will be unmounted
                  // when resolved
                  suspense.isHydrating = false
                  suspense.activeBranch = pendingBranch
                } else {
                  unmount(pendingBranch, parentComponent, suspense)
                } // increment pending ID. this is used to invalidate async callbacks
                // reset suspense state

                suspense.deps = 0 // discard effects from pending branch

                suspense.effects.length = 0 // discard previous container

                suspense.hiddenContainer = createElement('div')

                if (isInFallback) {
                  // already in fallback state
                  patch(
                    null,
                    newBranch,
                    suspense.hiddenContainer,
                    null,
                    parentComponent,
                    suspense,
                    isSVG
                  )

                  if (suspense.deps <= 0) {
                    suspense.resolve()
                  } else {
                    patch(
                      activeBranch,
                      newFallback,
                      container,
                      anchor,
                      parentComponent,
                      null, // fallback tree will not have suspense context
                      isSVG
                    )
                    setActiveBranch(suspense, newFallback)
                  }
                } else if (
                  activeBranch &&
                  isSameVNodeType(newBranch, activeBranch)
                ) {
                  // toggled "back" to current active branch
                  patch(
                    activeBranch,
                    newBranch,
                    container,
                    anchor,
                    parentComponent,
                    suspense,
                    isSVG
                  ) // force resolve

                  suspense.resolve(true)
                } else {
                  // switched to a 3rd branch
                  patch(
                    null,
                    newBranch,
                    suspense.hiddenContainer,
                    null,
                    parentComponent,
                    suspense,
                    isSVG
                  )

                  if (suspense.deps <= 0) {
                    suspense.resolve()
                  }
                }
              }
            } else {
              if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // root did not change, just normal patch
                patch(
                  activeBranch,
                  newBranch,
                  container,
                  anchor,
                  parentComponent,
                  suspense,
                  isSVG
                )
                setActiveBranch(suspense, newBranch)
              } else {
                // root node toggled
                // invoke @pending event
                var onPending = n2.props && n2.props.onPending

                if (isFunction(onPending)) {
                  onPending()
                } // mount pending branch in off-dom container

                suspense.pendingBranch = newBranch
                suspense.pendingId++
                patch(
                  null,
                  newBranch,
                  suspense.hiddenContainer,
                  null,
                  parentComponent,
                  suspense,
                  isSVG
                )

                if (suspense.deps <= 0) {
                  // incoming branch has no async deps, resolve now.
                  suspense.resolve()
                } else {
                  var timeout = suspense.timeout,
                    pendingId = suspense.pendingId

                  if (timeout > 0) {
                    setTimeout(function() {
                      if (suspense.pendingId === pendingId) {
                        suspense.fallback(newFallback)
                      }
                    }, timeout)
                  } else if (timeout === 0) {
                    suspense.fallback(newFallback)
                  }
                }
              }
            }
          }

          var hasWarned = false

          function createSuspenseBoundary(
            vnode,
            parent,
            parentComponent,
            container,
            hiddenContainer,
            anchor,
            isSVG,
            optimized,
            rendererInternals
          ) {
            var isHydrating =
              arguments.length > 9 && arguments[9] !== undefined
                ? arguments[9]
                : false

            /* istanbul ignore if */
            if (!hasWarned) {
              hasWarned = true // @ts-ignore `console.info` cannot be null error

              console[console.info ? 'info' : 'log'](
                '<Suspense> is an experimental feature and its API will likely change.'
              )
            }

            var patch = rendererInternals.p,
              _move = rendererInternals.m,
              _unmount2 = rendererInternals.um,
              _next = rendererInternals.n,
              _rendererInternals$o = rendererInternals.o,
              parentNode = _rendererInternals$o.parentNode,
              remove = _rendererInternals$o.remove
            var timeout = toNumber(vnode.props && vnode.props.timeout)
            var suspense = {
              vnode: vnode,
              parent: parent,
              parentComponent: parentComponent,
              isSVG: isSVG,
              container: container,
              hiddenContainer: hiddenContainer,
              anchor: anchor,
              deps: 0,
              pendingId: 0,
              timeout: typeof timeout === 'number' ? timeout : -1,
              activeBranch: null,
              pendingBranch: null,
              isInFallback: true,
              isHydrating: isHydrating,
              isUnmounted: false,
              effects: [],
              resolve: function resolve() {
                var resume =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : false
                {
                  if (!resume && !suspense.pendingBranch) {
                    throw new Error(
                      'suspense.resolve() is called without a pending branch.'
                    )
                  }

                  if (suspense.isUnmounted) {
                    throw new Error(
                      'suspense.resolve() is called on an already unmounted suspense boundary.'
                    )
                  }
                }
                var vnode = suspense.vnode,
                  activeBranch = suspense.activeBranch,
                  pendingBranch = suspense.pendingBranch,
                  pendingId = suspense.pendingId,
                  effects = suspense.effects,
                  parentComponent = suspense.parentComponent,
                  container = suspense.container

                if (suspense.isHydrating) {
                  suspense.isHydrating = false
                } else if (!resume) {
                  var delayEnter =
                    activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in'

                  if (delayEnter) {
                    activeBranch.transition.afterLeave = function() {
                      if (pendingId === suspense.pendingId) {
                        _move(
                          pendingBranch,
                          container,
                          _anchor,
                          0
                          /* ENTER */
                        )
                      }
                    }
                  } // this is initial anchor on mount

                  var _anchor = suspense.anchor // unmount current active tree

                  if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    _anchor = _next(activeBranch)

                    _unmount2(activeBranch, parentComponent, suspense, true)
                  }

                  if (!delayEnter) {
                    // move content from off-dom container to actual container
                    _move(
                      pendingBranch,
                      container,
                      _anchor,
                      0
                      /* ENTER */
                    )
                  }
                }

                setActiveBranch(suspense, pendingBranch)
                suspense.pendingBranch = null
                suspense.isInFallback = false // flush buffered effects
                // check if there is a pending parent suspense

                var parent = suspense.parent
                var hasUnresolvedAncestor = false

                while (parent) {
                  if (parent.pendingBranch) {
                    var _parent$effects

                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    ;(_parent$effects = parent.effects).push.apply(
                      _parent$effects,
                      _toConsumableArray(effects)
                    )

                    hasUnresolvedAncestor = true
                    break
                  }

                  parent = parent.parent
                } // no pending parent suspense, flush all jobs

                if (!hasUnresolvedAncestor) {
                  queuePostFlushCb(effects)
                }

                suspense.effects = [] // invoke @resolve event

                var onResolve = vnode.props && vnode.props.onResolve

                if (isFunction(onResolve)) {
                  onResolve()
                }
              },
              fallback: function fallback(fallbackVNode) {
                if (!suspense.pendingBranch) {
                  return
                }

                var vnode = suspense.vnode,
                  activeBranch = suspense.activeBranch,
                  parentComponent = suspense.parentComponent,
                  container = suspense.container,
                  isSVG = suspense.isSVG // invoke @fallback event

                var onFallback = vnode.props && vnode.props.onFallback

                if (isFunction(onFallback)) {
                  onFallback()
                }

                var anchor = _next(activeBranch)

                var mountFallback = function mountFallback() {
                  if (!suspense.isInFallback) {
                    return
                  } // mount the fallback tree

                  patch(
                    null,
                    fallbackVNode,
                    container,
                    anchor,
                    parentComponent,
                    null, // fallback tree will not have suspense context
                    isSVG
                  )
                  setActiveBranch(suspense, fallbackVNode)
                }

                var delayEnter =
                  fallbackVNode.transition &&
                  fallbackVNode.transition.mode === 'out-in'

                if (delayEnter) {
                  activeBranch.transition.afterLeave = mountFallback
                } // unmount current active branch

                _unmount2(
                  activeBranch,
                  parentComponent,
                  null, // no suspense so unmount hooks fire now
                  true // shouldRemove
                )

                suspense.isInFallback = true

                if (!delayEnter) {
                  mountFallback()
                }
              },
              move: function move(container, anchor, type) {
                suspense.activeBranch &&
                  _move(suspense.activeBranch, container, anchor, type)
                suspense.container = container
              },
              next: function next() {
                return suspense.activeBranch && _next(suspense.activeBranch)
              },
              registerDep: function registerDep(instance, setupRenderEffect) {
                var isInPendingSuspense = !!suspense.pendingBranch

                if (isInPendingSuspense) {
                  suspense.deps++
                }

                var hydratedEl = instance.vnode.el
                instance.asyncDep['catch'](function(err) {
                  handleError(
                    err,
                    instance,
                    0
                    /* SETUP_FUNCTION */
                  )
                }).then(function(asyncSetupResult) {
                  // retry when the setup() promise resolves.
                  // component may have been unmounted before resolve.
                  if (
                    instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId
                  ) {
                    return
                  } // retry from this component

                  instance.asyncResolved = true
                  var vnode = instance.vnode
                  {
                    pushWarningContext(vnode)
                  }
                  handleSetupResult(instance, asyncSetupResult)

                  if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl
                  }

                  var placeholder = !hydratedEl && instance.subTree.el
                  setupRenderEffect(
                    instance,
                    vnode, // component may have been moved before resolve.
                    // if this is not a hydration, instance.subTree will be the comment
                    // placeholder.
                    parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                    // consider the comment placeholder case.
                    hydratedEl ? null : _next(instance.subTree),
                    suspense,
                    isSVG,
                    optimized
                  )

                  if (placeholder) {
                    remove(placeholder)
                  }

                  updateHOCHostEl(instance, vnode.el)
                  {
                    popWarningContext()
                  } // only decrease deps count if suspense is not already resolved

                  if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve()
                  }
                })
              },
              unmount: function unmount(parentSuspense, doRemove) {
                suspense.isUnmounted = true

                if (suspense.activeBranch) {
                  _unmount2(
                    suspense.activeBranch,
                    parentComponent,
                    parentSuspense,
                    doRemove
                  )
                }

                if (suspense.pendingBranch) {
                  _unmount2(
                    suspense.pendingBranch,
                    parentComponent,
                    parentSuspense,
                    doRemove
                  )
                }
              }
            }
            return suspense
          }

          function hydrateSuspense(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            isSVG,
            optimized,
            rendererInternals,
            hydrateNode
          ) {
            /* eslint-disable no-restricted-globals */
            var suspense = (vnode.suspense = createSuspenseBoundary(
              vnode,
              parentSuspense,
              parentComponent,
              node.parentNode,
              document.createElement('div'),
              null,
              isSVG,
              optimized,
              rendererInternals,
              true
              /* hydrating */
            )) // there are two possible scenarios for server-rendered suspense:
            // - success: ssr content should be fully resolved
            // - failure: ssr content should be the fallback branch.
            // however, on the client we don't really know if it has failed or not
            // attempt to hydrate the DOM assuming it has succeeded, but we still
            // need to construct a suspense boundary first

            var result = hydrateNode(
              node,
              (suspense.pendingBranch = vnode.ssContent),
              parentComponent,
              suspense,
              optimized
            )

            if (suspense.deps === 0) {
              suspense.resolve()
            }

            return result
            /* eslint-enable no-restricted-globals */
          }

          function normalizeSuspenseChildren(vnode) {
            var shapeFlag = vnode.shapeFlag,
              children = vnode.children
            var content
            var fallback

            if (
              shapeFlag & 32
              /* SLOTS_CHILDREN */
            ) {
              content = normalizeSuspenseSlot(children['default'])
              fallback = normalizeSuspenseSlot(children.fallback)
            } else {
              content = normalizeSuspenseSlot(children)
              fallback = normalizeVNode(null)
            }

            return {
              content: content,
              fallback: fallback
            }
          }

          function normalizeSuspenseSlot(s) {
            if (isFunction(s)) {
              s = s()
            }

            if (isArray(s)) {
              var singleChild = filterSingleRoot(s)

              if (!singleChild) {
                warn('<Suspense> slots expect a single root node.')
              }

              s = singleChild
            }

            return normalizeVNode(s)
          }

          function queueEffectWithSuspense(fn, suspense) {
            if (suspense && suspense.pendingBranch) {
              if (isArray(fn)) {
                var _suspense$effects

                ;(_suspense$effects = suspense.effects).push.apply(
                  _suspense$effects,
                  _toConsumableArray(fn)
                )
              } else {
                suspense.effects.push(fn)
              }
            } else {
              queuePostFlushCb(fn)
            }
          }

          function setActiveBranch(suspense, branch) {
            suspense.activeBranch = branch
            var vnode = suspense.vnode,
              parentComponent = suspense.parentComponent
            var el = (vnode.el = branch.el) // in case suspense is the root node of a component,
            // recursively update the HOC el

            if (parentComponent && parentComponent.subTree === vnode) {
              parentComponent.vnode.el = el
              updateHOCHostEl(parentComponent, el)
            }
          }

          var isRenderingCompiledSlot = 0

          var setCompiledSlotRendering = function setCompiledSlotRendering(n) {
            return (isRenderingCompiledSlot += n)
          }
          /**
           * Compiler runtime helper for rendering `<slot/>`
           * @private
           */

          function renderSlot(slots, name) {
            var props =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : {}
            var // this is not a user-facing function, so the fallback is always generated by
            // the compiler and guaranteed to be a function returning an array
            fallback = arguments.length > 3 ? arguments[3] : undefined
            var slot = slots[name]

            if (slot && slot.length > 1) {
              warn(
                'SSR-optimized slot function detected in a non-SSR-optimized render ' +
                  'function. You need to mark this component with $dynamic-slots in the ' +
                  'parent template.'
              )

              slot = function slot() {
                return []
              }
            } // a compiled slot disables block tracking by default to avoid manual
            // invocation interfering with template-based block tracking, but in
            // `renderSlot` we can be sure that it's template-based so we can force
            // enable it.

            isRenderingCompiledSlot++
            openBlock()
            var validSlotContent = slot && ensureValidVNode(slot(props))
            var rendered = createBlock(
              Fragment,
              {
                key: props.key || '_'.concat(name)
              },
              validSlotContent || (fallback ? fallback() : []),
              validSlotContent && slots._ === 1
                ? /* STABLE */
                  64
                : /* STABLE_FRAGMENT */
                  -2
              /* BAIL */
            )
            isRenderingCompiledSlot--
            return rendered
          }

          function ensureValidVNode(vnodes) {
            return vnodes.some(function(child) {
              if (!isVNode(child)) return true
              if (child.type === Comment) return false
              if (child.type === Fragment && !ensureValidVNode(child.children))
                return false
              return true
            })
              ? vnodes
              : null
          }
          /**
           * Wrap a slot function to memoize current rendering instance
           * @private
           */

          function withCtx(fn) {
            var ctx =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : currentRenderingInstance
            if (!ctx) return fn

            var renderFnWithContext = function renderFnWithContext() {
              // If a user calls a compiled slot inside a template expression (#1745), it
              // can mess up block tracking, so by default we need to push a null block to
              // avoid that. This isn't necessary if rendering a compiled `<slot>`.
              if (!isRenderingCompiledSlot) {
                openBlock(
                  true
                  /* null block that disables tracking */
                )
              }

              var owner = currentRenderingInstance
              setCurrentRenderingInstance(ctx)
              var res = fn.apply(void 0, arguments)
              setCurrentRenderingInstance(owner)

              if (!isRenderingCompiledSlot) {
                closeBlock()
              }

              return res
            }

            renderFnWithContext._c = true
            return renderFnWithContext
          } // SFC scoped style ID management.

          var currentScopeId = null
          var scopeIdStack = []
          /**
           * @private
           */

          function pushScopeId(id) {
            scopeIdStack.push((currentScopeId = id))
          }
          /**
           * @private
           */

          function popScopeId() {
            scopeIdStack.pop()
            currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null
          }
          /**
           * @private
           */

          function withScopeId(id) {
            return function(fn) {
              return withCtx(function() {
                pushScopeId(id)
                var res = fn.apply(this, arguments)
                popScopeId()
                return res
              })
            }
          }

          function initProps(instance, rawProps, isStateful) {
            var isSSR =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : false
            var props = {}
            var attrs = {}
            def(attrs, InternalObjectKey, 1)
            setFullProps(instance, rawProps, props, attrs) // validation

            {
              validateProps(props, instance)
            }

            if (isStateful) {
              // stateful
              instance.props = isSSR ? props : shallowReactive(props)
            } else {
              if (!instance.type.props) {
                // functional w/ optional props, props === attrs
                instance.props = attrs
              } else {
                // functional w/ declared props
                instance.props = props
              }
            }

            instance.attrs = attrs
          }

          function updateProps(instance, rawProps, rawPrevProps, optimized) {
            var props = instance.props,
              attrs = instance.attrs,
              patchFlag = instance.vnode.patchFlag
            var rawCurrentProps = toRaw(props)

            var _instance$propsOption3 = _slicedToArray(
                instance.propsOptions,
                1
              ),
              options = _instance$propsOption3[0]

            if (
              // always force full diff in dev
              // - #1942 if hmr is enabled with sfc component
              // - vite#872 non-sfc component used by sfc component
              !(
                instance.type.__hmrId ||
                (instance.parent && instance.parent.type.__hmrId)
              ) &&
              (optimized || patchFlag > 0) &&
              !(patchFlag & 16)
              /* FULL_PROPS */
            ) {
              if (
                patchFlag & 8
                /* PROPS */
              ) {
                // Compiler-generated props & no keys change, just set the updated
                // the props.
                var propsToUpdate = instance.vnode.dynamicProps

                for (var i = 0; i < propsToUpdate.length; i++) {
                  var key = propsToUpdate[i] // PROPS flag guarantees rawProps to be non-null

                  var value = rawProps[key]

                  if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if (hasOwn(attrs, key)) {
                      attrs[key] = value
                    } else {
                      var camelizedKey = camelize(key)
                      props[camelizedKey] = resolvePropValue(
                        options,
                        rawCurrentProps,
                        camelizedKey,
                        value,
                        instance
                      )
                    }
                  } else {
                    attrs[key] = value
                  }
                }
              }
            } else {
              // full props update.
              setFullProps(instance, rawProps, props, attrs) // in case of dynamic props, check if we need to delete keys from
              // the props object

              var kebabKey

              for (var _key6 in rawCurrentProps) {
                if (
                  !rawProps || // for camelCase
                  (!hasOwn(rawProps, _key6) && // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = hyphenate(_key6)) === _key6 ||
                      !hasOwn(rawProps, kebabKey)))
                ) {
                  if (options) {
                    if (
                      rawPrevProps && // for camelCase
                      (rawPrevProps[_key6] !== undefined || // for kebab-case
                        rawPrevProps[kebabKey] !== undefined)
                    ) {
                      props[_key6] = resolvePropValue(
                        options,
                        rawProps || EMPTY_OBJ,
                        _key6,
                        undefined,
                        instance
                      )
                    }
                  } else {
                    delete props[_key6]
                  }
                }
              } // in the case of functional component w/o props declaration, props and
              // attrs point to the same object so it should already have been updated.

              if (attrs !== rawCurrentProps) {
                for (var _key7 in attrs) {
                  if (!rawProps || !hasOwn(rawProps, _key7)) {
                    delete attrs[_key7]
                  }
                }
              }
            } // trigger updates for $attrs in case it's used in component slots

            trigger(
              instance,
              'set',
              /* SET */
              '$attrs'
            )

            if (rawProps) {
              validateProps(props, instance)
            }
          }

          function setFullProps(instance, rawProps, props, attrs) {
            var _instance$propsOption4 = _slicedToArray(
                instance.propsOptions,
                2
              ),
              options = _instance$propsOption4[0],
              needCastKeys = _instance$propsOption4[1]

            if (rawProps) {
              for (var key in rawProps) {
                var value = rawProps[key] // key, ref are reserved and never passed down

                if (isReservedProp(key)) {
                  continue
                } // prop option names are camelized during normalization, so to support
                // kebab -> camel conversion here we need to camelize the key.

                var camelKey = void 0

                if (options && hasOwn(options, (camelKey = camelize(key)))) {
                  props[camelKey] = value
                } else if (!isEmitListener(instance.emitsOptions, key)) {
                  // Any non-declared (either as a prop or an emitted event) props are put
                  // into a separate `attrs` object for spreading. Make sure to preserve
                  // original key casing
                  attrs[key] = value
                }
              }
            }

            if (needCastKeys) {
              var rawCurrentProps = toRaw(props)

              for (var i = 0; i < needCastKeys.length; i++) {
                var _key8 = needCastKeys[i]
                props[_key8] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  _key8,
                  rawCurrentProps[_key8],
                  instance
                )
              }
            }
          }

          function resolvePropValue(options, props, key, value, instance) {
            var opt = options[key]

            if (opt != null) {
              var hasDefault = hasOwn(opt, 'default') // default values

              if (hasDefault && value === undefined) {
                var defaultValue = opt['default']

                if (opt.type !== Function && isFunction(defaultValue)) {
                  setCurrentInstance(instance)
                  value = defaultValue(props)
                  setCurrentInstance(null)
                } else {
                  value = defaultValue
                }
              } // boolean casting

              if (
                opt[0]
                /* shouldCast */
              ) {
                if (!hasOwn(props, key) && !hasDefault) {
                  value = false
                } else if (
                  opt[1] &&
                  /* shouldCastTrue */
                  (value === '' || value === hyphenate(key))
                ) {
                  value = true
                }
              }
            }

            return value
          }

          function normalizePropsOptions(comp, appContext) {
            var asMixin =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : false

            if (!appContext.deopt && comp.__props) {
              return comp.__props
            }

            var raw = comp.props
            var normalized = {}
            var needCastKeys = [] // apply mixin/extends props

            var hasExtends = false

            if (!isFunction(comp)) {
              var extendProps = function extendProps(raw) {
                hasExtends = true

                var _normalizePropsOption = normalizePropsOptions(
                    raw,
                    appContext,
                    true
                  ),
                  _normalizePropsOption2 = _slicedToArray(
                    _normalizePropsOption,
                    2
                  ),
                  props = _normalizePropsOption2[0],
                  keys = _normalizePropsOption2[1]

                extend(normalized, props)
                if (keys)
                  needCastKeys.push.apply(
                    needCastKeys,
                    _toConsumableArray(keys)
                  )
              }

              if (!asMixin && appContext.mixins.length) {
                appContext.mixins.forEach(extendProps)
              }

              if (comp['extends']) {
                extendProps(comp['extends'])
              }

              if (comp.mixins) {
                comp.mixins.forEach(extendProps)
              }
            }

            if (!raw && !hasExtends) {
              return (comp.__props = EMPTY_ARR)
            }

            if (isArray(raw)) {
              for (var i = 0; i < raw.length; i++) {
                if (!isString(raw[i])) {
                  warn('props must be strings when using array syntax.', raw[i])
                }

                var normalizedKey = camelize(raw[i])

                if (validatePropName(normalizedKey)) {
                  normalized[normalizedKey] = EMPTY_OBJ
                }
              }
            } else if (raw) {
              if (!isObject(raw)) {
                warn('invalid props options', raw)
              }

              for (var key in raw) {
                var _normalizedKey = camelize(key)

                if (validatePropName(_normalizedKey)) {
                  var opt = raw[key]
                  var prop = (normalized[_normalizedKey] =
                    isArray(opt) || isFunction(opt)
                      ? {
                          type: opt
                        }
                      : opt)

                  if (prop) {
                    var booleanIndex = getTypeIndex(Boolean, prop.type)
                    var stringIndex = getTypeIndex(String, prop.type)
                    prop[0] = booleanIndex > -1
                    /* shouldCast */
                    prop[1] = stringIndex < 0 || booleanIndex < stringIndex
                    /* shouldCastTrue */ // if the prop needs boolean casting or default value

                    if (booleanIndex > -1 || hasOwn(prop, 'default')) {
                      needCastKeys.push(_normalizedKey)
                    }
                  }
                }
              }
            }

            return (comp.__props = [normalized, needCastKeys])
          }

          function validatePropName(key) {
            if (key[0] !== '$') {
              return true
            } else {
              warn(
                'Invalid prop name: "'.concat(key, '" is a reserved property.')
              )
            }

            return false
          } // use function string name to check type constructors
          // so that it works across vms / iframes.

          function getType(ctor) {
            var match = ctor && ctor.toString().match(/^\s*function (\w+)/)
            return match ? match[1] : ''
          }

          function isSameType(a, b) {
            return getType(a) === getType(b)
          }

          function getTypeIndex(type, expectedTypes) {
            if (isArray(expectedTypes)) {
              for (var i = 0, len = expectedTypes.length; i < len; i++) {
                if (isSameType(expectedTypes[i], type)) {
                  return i
                }
              }
            } else if (isFunction(expectedTypes)) {
              return isSameType(expectedTypes, type) ? 0 : -1
            }

            return -1
          }
          /**
           * dev only
           */

          function validateProps(props, instance) {
            var rawValues = toRaw(props)
            var options = instance.propsOptions[0]

            for (var key in options) {
              var opt = options[key]
              if (opt == null) continue
              validateProp(key, rawValues[key], opt, !hasOwn(rawValues, key))
            }
          }
          /**
           * dev only
           */

          function validateProp(name, value, prop, isAbsent) {
            var type = prop.type,
              required = prop.required,
              validator = prop.validator // required!

            if (required && isAbsent) {
              warn('Missing required prop: "' + name + '"')
              return
            } // missing but optional

            if (value == null && !prop.required) {
              return
            } // type check

            if (type != null && type !== true) {
              var isValid = false
              var types = isArray(type) ? type : [type]
              var expectedTypes = [] // value is valid as long as one of the specified types match

              for (var i = 0; i < types.length && !isValid; i++) {
                var _assertType = assertType(value, types[i]),
                  valid = _assertType.valid,
                  expectedType = _assertType.expectedType

                expectedTypes.push(expectedType || '')
                isValid = valid
              }

              if (!isValid) {
                warn(getInvalidTypeMessage(name, value, expectedTypes))
                return
              }
            } // custom validator

            if (validator && !validator(value)) {
              warn(
                'Invalid prop: custom validator check failed for prop "' +
                  name +
                  '".'
              )
            }
          }

          var isSimpleType = /*#__PURE__*/ makeMap(
            'String,Number,Boolean,Function,Symbol,BigInt'
          )
          /**
           * dev only
           */

          function assertType(value, type) {
            var valid
            var expectedType = getType(type)

            if (isSimpleType(expectedType)) {
              var t = _typeof(value)

              valid = t === expectedType.toLowerCase() // for primitive wrapper objects

              if (!valid && t === 'object') {
                valid = value instanceof type
              }
            } else if (expectedType === 'Object') {
              valid = isObject(value)
            } else if (expectedType === 'Array') {
              valid = isArray(value)
            } else {
              valid = value instanceof type
            }

            return {
              valid: valid,
              expectedType: expectedType
            }
          }
          /**
           * dev only
           */

          function getInvalidTypeMessage(name, value, expectedTypes) {
            var message =
              'Invalid prop: type check failed for prop "'.concat(name, '".') +
              ' Expected '.concat(expectedTypes.map(capitalize).join(', '))
            var expectedType = expectedTypes[0]
            var receivedType = toRawType(value)
            var expectedValue = styleValue(value, expectedType)
            var receivedValue = styleValue(value, receivedType) // check if we need to specify expected value

            if (
              expectedTypes.length === 1 &&
              isExplicable(expectedType) &&
              !isBoolean(expectedType, receivedType)
            ) {
              message += ' with value '.concat(expectedValue)
            }

            message += ', got '.concat(receivedType, ' ') // check if we need to specify received value

            if (isExplicable(receivedType)) {
              message += 'with value '.concat(receivedValue, '.')
            }

            return message
          }
          /**
           * dev only
           */

          function styleValue(value, type) {
            if (type === 'String') {
              return '"'.concat(value, '"')
            } else if (type === 'Number') {
              return ''.concat(Number(value))
            } else {
              return ''.concat(value)
            }
          }
          /**
           * dev only
           */

          function isExplicable(type) {
            var explicitTypes = ['string', 'number', 'boolean']
            return explicitTypes.some(function(elem) {
              return type.toLowerCase() === elem
            })
          }
          /**
           * dev only
           */

          function isBoolean() {
            for (
              var _len5 = arguments.length, args = new Array(_len5), _key9 = 0;
              _key9 < _len5;
              _key9++
            ) {
              args[_key9] = arguments[_key9]
            }

            return args.some(function(elem) {
              return elem.toLowerCase() === 'boolean'
            })
          }

          function injectHook(type, hook) {
            var target =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : currentInstance
            var prepend =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : false

            if (target) {
              var hooks = target[type] || (target[type] = []) // cache the error handling wrapper for injected hooks so the same hook
              // can be properly deduped by the scheduler. "__weh" stands for "with error
              // handling".

              var wrappedHook =
                hook.__weh ||
                (hook.__weh = function() {
                  if (target.isUnmounted) {
                    return
                  } // disable tracking inside all lifecycle hooks
                  // since they can potentially be called inside effects.

                  pauseTracking() // Set currentInstance during hook invocation.
                  // This assumes the hook does not synchronously trigger other hooks, which
                  // can only be false when the user does something really funky.

                  setCurrentInstance(target)

                  for (
                    var _len6 = arguments.length,
                      args = new Array(_len6),
                      _key10 = 0;
                    _key10 < _len6;
                    _key10++
                  ) {
                    args[_key10] = arguments[_key10]
                  }

                  var res = callWithAsyncErrorHandling(hook, target, type, args)
                  setCurrentInstance(null)
                  resetTracking()
                  return res
                })

              if (prepend) {
                hooks.unshift(wrappedHook)
              } else {
                hooks.push(wrappedHook)
              }

              return wrappedHook
            } else {
              var apiName = toHandlerKey(
                ErrorTypeStrings[type].replace(/ hook$/, '')
              )
              warn(
                ''.concat(
                  apiName,
                  ' is called when there is no active component instance to be '
                ) +
                  'associated with. ' +
                  'Lifecycle injection APIs can only be used during execution of setup().' +
                  (' If you are using async setup(), make sure to register lifecycle ' +
                    'hooks before the first await statement.')
              )
            }
          }

          var createHook = function createHook(lifecycle) {
            return function(hook) {
              var target =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : currentInstance
              return (
                // post-create lifecycle registrations are noops during SSR
                !isInSSRComponentSetup && injectHook(lifecycle, hook, target)
              )
            }
          }

          var onBeforeMount = createHook(
            'bm'
            /* BEFORE_MOUNT */
          )
          var onMounted = createHook(
            'm'
            /* MOUNTED */
          )
          var onBeforeUpdate = createHook(
            'bu'
            /* BEFORE_UPDATE */
          )
          var onUpdated = createHook(
            'u'
            /* UPDATED */
          )
          var onBeforeUnmount = createHook(
            'bum'
            /* BEFORE_UNMOUNT */
          )
          var onUnmounted = createHook(
            'um'
            /* UNMOUNTED */
          )
          var onRenderTriggered = createHook(
            'rtg'
            /* RENDER_TRIGGERED */
          )
          var onRenderTracked = createHook(
            'rtc'
            /* RENDER_TRACKED */
          )

          var onErrorCaptured = function onErrorCaptured(hook) {
            var target =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : currentInstance
            injectHook(
              'ec',
              /* ERROR_CAPTURED */
              hook,
              target
            )
          } // Simple effect.

          function watchEffect(effect, options) {
            return doWatch(effect, null, options)
          } // initial value for watchers to trigger on undefined initial values

          var INITIAL_WATCHER_VALUE = {} // implementation

          function watch(source, cb, options) {
            if (!isFunction(cb)) {
              warn(
                '`watch(fn, options?)` signature has been moved to a separate API. ' +
                  'Use `watchEffect(fn, options?)` instead. `watch` now only ' +
                  'supports `watch(source, cb, options?) signature.'
              )
            }

            return doWatch(source, cb, options)
          }

          function doWatch(source, cb) {
            var _ref11 =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : EMPTY_OBJ,
              immediate = _ref11.immediate,
              deep = _ref11.deep,
              flush = _ref11.flush,
              onTrack = _ref11.onTrack,
              onTrigger = _ref11.onTrigger

            var instance =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : currentInstance

            if (!cb) {
              if (immediate !== undefined) {
                warn(
                  'watch() "immediate" option is only respected when using the ' +
                    'watch(source, callback, options?) signature.'
                )
              }

              if (deep !== undefined) {
                warn(
                  'watch() "deep" option is only respected when using the ' +
                    'watch(source, callback, options?) signature.'
                )
              }
            }

            var warnInvalidSource = function warnInvalidSource(s) {
              warn(
                'Invalid watch source: ',
                s,
                'A watch source can only be a getter/effect function, a ref, ' +
                  'a reactive object, or an array of these types.'
              )
            }

            var getter
            var forceTrigger = false

            if (isRef(source)) {
              getter = function getter() {
                return source.value
              }

              forceTrigger = !!source._shallow
            } else if (isReactive(source)) {
              getter = function getter() {
                return source
              }

              deep = true
            } else if (isArray(source)) {
              getter = function getter() {
                return source.map(function(s) {
                  if (isRef(s)) {
                    return s.value
                  } else if (isReactive(s)) {
                    return traverse(s)
                  } else if (isFunction(s)) {
                    return callWithErrorHandling(
                      s,
                      instance,
                      2,
                      /* WATCH_GETTER */
                      [instance && instance.proxy]
                    )
                  } else {
                    warnInvalidSource(s)
                  }
                })
              }
            } else if (isFunction(source)) {
              if (cb) {
                // getter with cb
                getter = function getter() {
                  return callWithErrorHandling(
                    source,
                    instance,
                    2,
                    /* WATCH_GETTER */
                    [instance && instance.proxy]
                  )
                }
              } else {
                // no cb -> simple effect
                getter = function getter() {
                  if (instance && instance.isUnmounted) {
                    return
                  }

                  if (cleanup) {
                    cleanup()
                  }

                  return callWithErrorHandling(
                    source,
                    instance,
                    3,
                    /* WATCH_CALLBACK */
                    [onInvalidate]
                  )
                }
              }
            } else {
              getter = NOOP
              warnInvalidSource(source)
            }

            if (cb && deep) {
              var baseGetter = getter

              getter = function getter() {
                return traverse(baseGetter())
              }
            }

            var cleanup

            var onInvalidate = function onInvalidate(fn) {
              cleanup = runner.options.onStop = function() {
                callWithErrorHandling(
                  fn,
                  instance,
                  4
                  /* WATCH_CLEANUP */
                )
              }
            }

            var oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE

            var job = function job() {
              if (!runner.active) {
                return
              }

              if (cb) {
                // watch(source, cb)
                var newValue = runner()

                if (deep || forceTrigger || hasChanged(newValue, oldValue)) {
                  // cleanup before running cb again
                  if (cleanup) {
                    cleanup()
                  }

                  callWithAsyncErrorHandling(
                    cb,
                    instance,
                    3,
                    /* WATCH_CALLBACK */
                    [
                      newValue, // pass undefined as the old value when it's changed for the first time
                      oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                      onInvalidate
                    ]
                  )
                  oldValue = newValue
                }
              } else {
                // watchEffect
                runner()
              }
            } // important: mark the job as a watcher callback so that scheduler knows
            // it is allowed to self-trigger (#1727)

            job.allowRecurse = !!cb
            var scheduler

            if (flush === 'sync') {
              scheduler = job
            } else if (flush === 'post') {
              scheduler = function scheduler() {
                return queuePostRenderEffect(job, instance && instance.suspense)
              }
            } else {
              // default: 'pre'
              scheduler = function scheduler() {
                if (!instance || instance.isMounted) {
                  queuePreFlushCb(job)
                } else {
                  // with 'pre' option, the first call must happen before
                  // the component is mounted so it is called synchronously.
                  job()
                }
              }
            }

            var runner = effect(getter, {
              lazy: true,
              onTrack: onTrack,
              onTrigger: onTrigger,
              scheduler: scheduler
            })
            recordInstanceBoundEffect(runner, instance) // initial run

            if (cb) {
              if (immediate) {
                job()
              } else {
                oldValue = runner()
              }
            } else if (flush === 'post') {
              queuePostRenderEffect(runner, instance && instance.suspense)
            } else {
              runner()
            }

            return function() {
              stop(runner)

              if (instance) {
                remove(instance.effects, runner)
              }
            }
          } // this.$watch

          function instanceWatch(source, cb, options) {
            var publicThis = this.proxy
            var getter = isString(source)
              ? function() {
                  return publicThis[source]
                }
              : source.bind(publicThis)
            return doWatch(getter, cb.bind(publicThis), options, this)
          }

          function traverse(value) {
            var seen =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : new Set()

            if (!isObject(value) || seen.has(value)) {
              return value
            }

            seen.add(value)

            if (isRef(value)) {
              traverse(value.value, seen)
            } else if (isArray(value)) {
              for (var i = 0; i < value.length; i++) {
                traverse(value[i], seen)
              }
            } else if (isSet(value) || isMap(value)) {
              value.forEach(function(v) {
                traverse(v, seen)
              })
            } else {
              for (var key in value) {
                traverse(value[key], seen)
              }
            }

            return value
          }

          function useTransitionState() {
            var state = {
              isMounted: false,
              isLeaving: false,
              isUnmounting: false,
              leavingVNodes: new Map()
            }
            onMounted(function() {
              state.isMounted = true
            })
            onBeforeUnmount(function() {
              state.isUnmounting = true
            })
            return state
          }

          var TransitionHookValidator = [Function, Array]
          var BaseTransitionImpl = {
            name: 'BaseTransition',
            props: {
              mode: String,
              appear: Boolean,
              persisted: Boolean,
              // enter
              onBeforeEnter: TransitionHookValidator,
              onEnter: TransitionHookValidator,
              onAfterEnter: TransitionHookValidator,
              onEnterCancelled: TransitionHookValidator,
              // leave
              onBeforeLeave: TransitionHookValidator,
              onLeave: TransitionHookValidator,
              onAfterLeave: TransitionHookValidator,
              onLeaveCancelled: TransitionHookValidator,
              // appear
              onBeforeAppear: TransitionHookValidator,
              onAppear: TransitionHookValidator,
              onAfterAppear: TransitionHookValidator,
              onAppearCancelled: TransitionHookValidator
            },
            setup: function setup(props, _ref12) {
              var slots = _ref12.slots
              var instance = getCurrentInstance()
              var state = useTransitionState()
              var prevTransitionKey
              return function() {
                var children =
                  slots['default'] &&
                  getTransitionRawChildren(slots['default'](), true)

                if (!children || !children.length) {
                  return
                } // warn multiple elements

                if (children.length > 1) {
                  warn(
                    '<transition> can only be used on a single element or component. Use ' +
                      '<transition-group> for lists.'
                  )
                } // there's no need to track reactivity for these props so use the raw
                // props for a bit better perf

                var rawProps = toRaw(props)
                var mode = rawProps.mode // check mode

                if (mode && !['in-out', 'out-in', 'default'].includes(mode)) {
                  warn('invalid <transition> mode: '.concat(mode))
                } // at this point children has a guaranteed length of 1.

                var child = children[0]

                if (state.isLeaving) {
                  return emptyPlaceholder(child)
                } // in the case of <transition><keep-alive/></transition>, we need to
                // compare the type of the kept-alive children.

                var innerChild = getKeepAliveChild(child)

                if (!innerChild) {
                  return emptyPlaceholder(child)
                }

                var enterHooks = resolveTransitionHooks(
                  innerChild,
                  rawProps,
                  state,
                  instance
                )
                setTransitionHooks(innerChild, enterHooks)
                var oldChild = instance.subTree
                var oldInnerChild = oldChild && getKeepAliveChild(oldChild)
                var transitionKeyChanged = false
                var getTransitionKey = innerChild.type.getTransitionKey

                if (getTransitionKey) {
                  var key = getTransitionKey()

                  if (prevTransitionKey === undefined) {
                    prevTransitionKey = key
                  } else if (key !== prevTransitionKey) {
                    prevTransitionKey = key
                    transitionKeyChanged = true
                  }
                } // handle mode

                if (
                  oldInnerChild &&
                  oldInnerChild.type !== Comment &&
                  (!isSameVNodeType(innerChild, oldInnerChild) ||
                    transitionKeyChanged)
                ) {
                  var leavingHooks = resolveTransitionHooks(
                    oldInnerChild,
                    rawProps,
                    state,
                    instance
                  ) // update old tree's hooks in case of dynamic transition

                  setTransitionHooks(oldInnerChild, leavingHooks) // switching between different views

                  if (mode === 'out-in') {
                    state.isLeaving = true // return placeholder node and queue update when leave finishes

                    leavingHooks.afterLeave = function() {
                      state.isLeaving = false
                      instance.update()
                    }

                    return emptyPlaceholder(child)
                  } else if (mode === 'in-out') {
                    leavingHooks.delayLeave = function(
                      el,
                      earlyRemove,
                      delayedLeave
                    ) {
                      var leavingVNodesCache = getLeavingNodesForType(
                        state,
                        oldInnerChild
                      )
                      leavingVNodesCache[
                        String(oldInnerChild.key)
                      ] = oldInnerChild // early removal callback

                      el._leaveCb = function() {
                        earlyRemove()
                        el._leaveCb = undefined
                        delete enterHooks.delayedLeave
                      }

                      enterHooks.delayedLeave = delayedLeave
                    }
                  }
                }

                return child
              }
            }
          } // export the public type for h/tsx inference
          // also to avoid inline import() in generated d.ts files

          var BaseTransition = BaseTransitionImpl

          function getLeavingNodesForType(state, vnode) {
            var leavingVNodes = state.leavingVNodes
            var leavingVNodesCache = leavingVNodes.get(vnode.type)

            if (!leavingVNodesCache) {
              leavingVNodesCache = Object.create(null)
              leavingVNodes.set(vnode.type, leavingVNodesCache)
            }

            return leavingVNodesCache
          } // The transition hooks are attached to the vnode as vnode.transition
          // and will be called at appropriate timing in the renderer.

          function resolveTransitionHooks(vnode, props, state, instance) {
            var appear = props.appear,
              mode = props.mode,
              _props$persisted = props.persisted,
              persisted =
                _props$persisted === void 0 ? false : _props$persisted,
              onBeforeEnter = props.onBeforeEnter,
              onEnter = props.onEnter,
              onAfterEnter = props.onAfterEnter,
              onEnterCancelled = props.onEnterCancelled,
              onBeforeLeave = props.onBeforeLeave,
              onLeave = props.onLeave,
              onAfterLeave = props.onAfterLeave,
              onLeaveCancelled = props.onLeaveCancelled,
              onBeforeAppear = props.onBeforeAppear,
              onAppear = props.onAppear,
              onAfterAppear = props.onAfterAppear,
              onAppearCancelled = props.onAppearCancelled
            var key = String(vnode.key)
            var leavingVNodesCache = getLeavingNodesForType(state, vnode)

            var callHook = function callHook(hook, args) {
              hook &&
                callWithAsyncErrorHandling(
                  hook,
                  instance,
                  9,
                  /* TRANSITION_HOOK */
                  args
                )
            }

            var hooks = {
              mode: mode,
              persisted: persisted,
              beforeEnter: function beforeEnter(el) {
                var hook = onBeforeEnter

                if (!state.isMounted) {
                  if (appear) {
                    hook = onBeforeAppear || onBeforeEnter
                  } else {
                    return
                  }
                } // for same element (v-show)

                if (el._leaveCb) {
                  el._leaveCb(
                    true
                    /* cancelled */
                  )
                } // for toggled element with same key (v-if)

                var leavingVNode = leavingVNodesCache[key]

                if (
                  leavingVNode &&
                  isSameVNodeType(vnode, leavingVNode) &&
                  leavingVNode.el._leaveCb
                ) {
                  // force early removal (not cancelled)
                  leavingVNode.el._leaveCb()
                }

                callHook(hook, [el])
              },
              enter: function enter(el) {
                var hook = onEnter
                var afterHook = onAfterEnter
                var cancelHook = onEnterCancelled

                if (!state.isMounted) {
                  if (appear) {
                    hook = onAppear || onEnter
                    afterHook = onAfterAppear || onAfterEnter
                    cancelHook = onAppearCancelled || onEnterCancelled
                  } else {
                    return
                  }
                }

                var called = false

                var done = (el._enterCb = function(cancelled) {
                  if (called) return
                  called = true

                  if (cancelled) {
                    callHook(cancelHook, [el])
                  } else {
                    callHook(afterHook, [el])
                  }

                  if (hooks.delayedLeave) {
                    hooks.delayedLeave()
                  }

                  el._enterCb = undefined
                })

                if (hook) {
                  hook(el, done)

                  if (hook.length <= 1) {
                    done()
                  }
                } else {
                  done()
                }
              },
              leave: function leave(el, remove) {
                var key = String(vnode.key)

                if (el._enterCb) {
                  el._enterCb(
                    true
                    /* cancelled */
                  )
                }

                if (state.isUnmounting) {
                  return remove()
                }

                callHook(onBeforeLeave, [el])
                var called = false

                var done = (el._leaveCb = function(cancelled) {
                  if (called) return
                  called = true
                  remove()

                  if (cancelled) {
                    callHook(onLeaveCancelled, [el])
                  } else {
                    callHook(onAfterLeave, [el])
                  }

                  el._leaveCb = undefined

                  if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key]
                  }
                })

                leavingVNodesCache[key] = vnode

                if (onLeave) {
                  onLeave(el, done)

                  if (onLeave.length <= 1) {
                    done()
                  }
                } else {
                  done()
                }
              },
              clone: function clone(vnode) {
                return resolveTransitionHooks(vnode, props, state, instance)
              }
            }
            return hooks
          } // the placeholder really only handles one special case: KeepAlive
          // in the case of a KeepAlive in a leave phase we need to return a KeepAlive
          // placeholder with empty content to avoid the KeepAlive instance from being
          // unmounted.

          function emptyPlaceholder(vnode) {
            if (isKeepAlive(vnode)) {
              vnode = cloneVNode(vnode)
              vnode.children = null
              return vnode
            }
          }

          function getKeepAliveChild(vnode) {
            return isKeepAlive(vnode)
              ? vnode.children
                ? vnode.children[0]
                : undefined
              : vnode
          }

          function setTransitionHooks(vnode, hooks) {
            if (
              vnode.shapeFlag & 6 &&
              /* COMPONENT */
              vnode.component
            ) {
              setTransitionHooks(vnode.component.subTree, hooks)
            } else if (
              vnode.shapeFlag & 128
              /* SUSPENSE */
            ) {
              vnode.ssContent.transition = hooks.clone(vnode.ssContent)
              vnode.ssFallback.transition = hooks.clone(vnode.ssFallback)
            } else {
              vnode.transition = hooks
            }
          }

          function getTransitionRawChildren(children) {
            var keepComment =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false
            var ret = []
            var keyedFragmentCount = 0

            for (var i = 0; i < children.length; i++) {
              var child = children[i] // handle fragment children case, e.g. v-for

              if (child.type === Fragment) {
                if (
                  child.patchFlag & 128
                  /* KEYED_FRAGMENT */
                )
                  keyedFragmentCount++
                ret = ret.concat(
                  getTransitionRawChildren(child.children, keepComment)
                )
              } // comment placeholders should be skipped, e.g. v-if
              else if (keepComment || child.type !== Comment) {
                ret.push(child)
              }
            } // #1126 if a transition children list contains multiple sub fragments, these
            // fragments will be merged into a flat children array. Since each v-for
            // fragment may contain different static bindings inside, we need to de-op
            // these children to force full diffs to ensure correct behavior.

            if (keyedFragmentCount > 1) {
              for (var _i2 = 0; _i2 < ret.length; _i2++) {
                ret[_i2].patchFlag = -2
                /* BAIL */
              }
            }

            return ret
          }

          var isKeepAlive = function isKeepAlive(vnode) {
            return vnode.type.__isKeepAlive
          }

          var KeepAliveImpl = {
            name: 'KeepAlive',
            // Marker for special handling inside the renderer. We are not using a ===
            // check directly on KeepAlive in the renderer, because importing it directly
            // would prevent it from being tree-shaken.
            __isKeepAlive: true,
            props: {
              include: [String, RegExp, Array],
              exclude: [String, RegExp, Array],
              max: [String, Number]
            },
            setup: function setup(props, _ref13) {
              var slots = _ref13.slots
              var cache = new Map()
              var keys = new Set()
              var current = null
              var instance = getCurrentInstance()
              var parentSuspense = instance.suspense // KeepAlive communicates with the instantiated renderer via the
              // ctx where the renderer passes in its internals,
              // and the KeepAlive instance exposes activate/deactivate implementations.
              // The whole point of this is to avoid importing KeepAlive directly in the
              // renderer to facilitate tree-shaking.

              var sharedContext = instance.ctx
              var _sharedContext$render = sharedContext.renderer,
                patch = _sharedContext$render.p,
                move = _sharedContext$render.m,
                _unmount = _sharedContext$render.um,
                createElement = _sharedContext$render.o.createElement
              var storageContainer = createElement('div')

              sharedContext.activate = function(
                vnode,
                container,
                anchor,
                isSVG,
                optimized
              ) {
                var instance = vnode.component
                move(
                  vnode,
                  container,
                  anchor,
                  0,
                  /* ENTER */
                  parentSuspense
                ) // in case props have changed

                patch(
                  instance.vnode,
                  vnode,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  isSVG,
                  optimized
                )
                queuePostRenderEffect(function() {
                  instance.isDeactivated = false

                  if (instance.a) {
                    invokeArrayFns(instance.a)
                  }

                  var vnodeHook = vnode.props && vnode.props.onVnodeMounted

                  if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode)
                  }
                }, parentSuspense)
              }

              sharedContext.deactivate = function(vnode) {
                var instance = vnode.component
                move(
                  vnode,
                  storageContainer,
                  null,
                  1,
                  /* LEAVE */
                  parentSuspense
                )
                queuePostRenderEffect(function() {
                  if (instance.da) {
                    invokeArrayFns(instance.da)
                  }

                  var vnodeHook = vnode.props && vnode.props.onVnodeUnmounted

                  if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode)
                  }

                  instance.isDeactivated = true
                }, parentSuspense)
              }

              function unmount(vnode) {
                // reset the shapeFlag so it can be properly unmounted
                resetShapeFlag(vnode)

                _unmount(vnode, instance, parentSuspense)
              }

              function pruneCache(filter) {
                cache.forEach(function(vnode, key) {
                  var name = getComponentName(vnode.type)

                  if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key)
                  }
                })
              }

              function pruneCacheEntry(key) {
                var cached = cache.get(key)

                if (!current || cached.type !== current.type) {
                  unmount(cached)
                } else if (current) {
                  // current active instance should no longer be kept-alive.
                  // we can't unmount it now but it might be later, so reset its flag now.
                  resetShapeFlag(current)
                }

                cache['delete'](key)
                keys['delete'](key)
              } // prune cache on include/exclude prop change

              watch(
                function() {
                  return [props.include, props.exclude]
                },
                function(_ref14) {
                  var _ref15 = _slicedToArray(_ref14, 2),
                    include = _ref15[0],
                    exclude = _ref15[1]

                  include &&
                    pruneCache(function(name) {
                      return matches(include, name)
                    })
                  exclude &&
                    pruneCache(function(name) {
                      return !matches(exclude, name)
                    })
                }, // prune post-render after `current` has been updated
                {
                  flush: 'post',
                  deep: true
                }
              ) // cache sub tree after render

              var pendingCacheKey = null

              var cacheSubtree = function cacheSubtree() {
                // fix #1621, the pendingCacheKey could be 0
                if (pendingCacheKey != null) {
                  cache.set(pendingCacheKey, getInnerChild(instance.subTree))
                }
              }

              onMounted(cacheSubtree)
              onUpdated(cacheSubtree)
              onBeforeUnmount(function() {
                cache.forEach(function(cached) {
                  var subTree = instance.subTree,
                    suspense = instance.suspense
                  var vnode = getInnerChild(subTree)

                  if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode) // but invoke its deactivated hook here

                    var da = vnode.component.da
                    da && queuePostRenderEffect(da, suspense)
                    return
                  }

                  unmount(cached)
                })
              })
              return function() {
                pendingCacheKey = null

                if (!slots['default']) {
                  return null
                }

                var children = slots['default']()
                var rawVNode = children[0]

                if (children.length > 1) {
                  {
                    warn(
                      'KeepAlive should contain exactly one component child.'
                    )
                  }
                  current = null
                  return children
                } else if (
                  !isVNode(rawVNode) ||
                  (!(rawVNode.shapeFlag & 4) &&
                  /* STATEFUL_COMPONENT */
                    !(rawVNode.shapeFlag & 128))
                    /* SUSPENSE */
                ) {
                  current = null
                  return rawVNode
                }

                var vnode = getInnerChild(rawVNode)
                var comp = vnode.type
                var name = getComponentName(comp)
                var include = props.include,
                  exclude = props.exclude,
                  max = props.max

                if (
                  (include && (!name || !matches(include, name))) ||
                  (exclude && name && matches(exclude, name))
                ) {
                  current = vnode
                  return rawVNode
                }

                var key = vnode.key == null ? comp : vnode.key
                var cachedVNode = cache.get(key) // clone vnode if it's reused because we are going to mutate it

                if (vnode.el) {
                  vnode = cloneVNode(vnode)

                  if (
                    rawVNode.shapeFlag & 128
                    /* SUSPENSE */
                  ) {
                    rawVNode.ssContent = vnode
                  }
                } // #1513 it's possible for the returned vnode to be cloned due to attr
                // fallthrough or scopeId, so the vnode here may not be the final vnode
                // that is mounted. Instead of caching it directly, we store the pending
                // key and cache `instance.subTree` (the normalized vnode) in
                // beforeMount/beforeUpdate hooks.

                pendingCacheKey = key

                if (cachedVNode) {
                  // copy over mounted state
                  vnode.el = cachedVNode.el
                  vnode.component = cachedVNode.component

                  if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition)
                  } // avoid vnode being mounted as fresh

                  vnode.shapeFlag |= 512
                  /* COMPONENT_KEPT_ALIVE */ // make this key the freshest

                  keys['delete'](key)
                  keys.add(key)
                } else {
                  keys.add(key) // prune oldest entry

                  if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value)
                  }
                } // avoid vnode being unmounted

                vnode.shapeFlag |= 256
                /* COMPONENT_SHOULD_KEEP_ALIVE */
                current = vnode
                return rawVNode
              }
            }
          } // export the public type for h/tsx inference
          // also to avoid inline import() in generated d.ts files

          var KeepAlive = KeepAliveImpl

          function matches(pattern, name) {
            if (isArray(pattern)) {
              return pattern.some(function(p) {
                return matches(p, name)
              })
            } else if (isString(pattern)) {
              return pattern.split(',').indexOf(name) > -1
            } else if (pattern.test) {
              return pattern.test(name)
            }
            /* istanbul ignore next */

            return false
          }

          function onActivated(hook, target) {
            registerKeepAliveHook(
              hook,
              'a',
              /* ACTIVATED */
              target
            )
          }

          function onDeactivated(hook, target) {
            registerKeepAliveHook(
              hook,
              'da',
              /* DEACTIVATED */
              target
            )
          }

          function registerKeepAliveHook(hook, type) {
            var target =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : currentInstance

            // cache the deactivate branch check wrapper for injected hooks so the same
            // hook can be properly deduped by the scheduler. "__wdc" stands for "with
            // deactivation check".
            var wrappedHook =
              hook.__wdc ||
              (hook.__wdc = function() {
                // only fire the hook if the target instance is NOT in a deactivated branch.
                var current = target

                while (current) {
                  if (current.isDeactivated) {
                    return
                  }

                  current = current.parent
                }

                hook()
              })

            injectHook(type, wrappedHook, target) // In addition to registering it on the target instance, we walk up the parent
            // chain and register it on all ancestor instances that are keep-alive roots.
            // This avoids the need to walk the entire component tree when invoking these
            // hooks, and more importantly, avoids the need to track child components in
            // arrays.

            if (target) {
              var current = target.parent

              while (current && current.parent) {
                if (isKeepAlive(current.parent.vnode)) {
                  injectToKeepAliveRoot(wrappedHook, type, target, current)
                }

                current = current.parent
              }
            }
          }

          function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
            // injectHook wraps the original for error handling, so make sure to remove
            // the wrapped version.
            var injected = injectHook(
              type,
              hook,
              keepAliveRoot,
              true
              /* prepend */
            )
            onUnmounted(function() {
              remove(keepAliveRoot[type], injected)
            }, target)
          }

          function resetShapeFlag(vnode) {
            var shapeFlag = vnode.shapeFlag

            if (
              shapeFlag & 256
              /* COMPONENT_SHOULD_KEEP_ALIVE */
            ) {
              shapeFlag -= 256
              /* COMPONENT_SHOULD_KEEP_ALIVE */
            }

            if (
              shapeFlag & 512
              /* COMPONENT_KEPT_ALIVE */
            ) {
              shapeFlag -= 512
              /* COMPONENT_KEPT_ALIVE */
            }

            vnode.shapeFlag = shapeFlag
          }

          function getInnerChild(vnode) {
            return vnode.shapeFlag & 128
              ? /* SUSPENSE */
                vnode.ssContent
              : vnode
          }

          var isInternalKey = function isInternalKey(key) {
            return key[0] === '_' || key === '$stable'
          }

          var normalizeSlotValue = function normalizeSlotValue(value) {
            return isArray(value)
              ? value.map(normalizeVNode)
              : [normalizeVNode(value)]
          }

          var normalizeSlot = function normalizeSlot(key, rawSlot, ctx) {
            return withCtx(function(props) {
              if (currentInstance) {
                warn(
                  'Slot "'.concat(
                    key,
                    '" invoked outside of the render function: '
                  ) +
                    'this will not track dependencies used in the slot. ' +
                    'Invoke the slot function inside the render function instead.'
                )
              }

              return normalizeSlotValue(rawSlot(props))
            }, ctx)
          }

          var normalizeObjectSlots = function normalizeObjectSlots(
            rawSlots,
            slots
          ) {
            var ctx = rawSlots._ctx

            for (var key in rawSlots) {
              if (isInternalKey(key)) continue
              var value = rawSlots[key]

              if (isFunction(value)) {
                slots[key] = normalizeSlot(key, value, ctx)
              } else if (value != null) {
                ;(function() {
                  {
                    warn(
                      'Non-function value encountered for slot "'.concat(
                        key,
                        '". '
                      ) + 'Prefer function slots for better performance.'
                    )
                  }
                  var normalized = normalizeSlotValue(value)

                  slots[key] = function() {
                    return normalized
                  }
                })()
              }
            }
          }

          var normalizeVNodeSlots = function normalizeVNodeSlots(
            instance,
            children
          ) {
            if (!isKeepAlive(instance.vnode)) {
              warn(
                'Non-function value encountered for default slot. ' +
                  'Prefer function slots for better performance.'
              )
            }

            var normalized = normalizeSlotValue(children)

            instance.slots['default'] = function() {
              return normalized
            }
          }

          var initSlots = function initSlots(instance, children) {
            if (
              instance.vnode.shapeFlag & 32
              /* SLOTS_CHILDREN */
            ) {
              var type = children._

              if (type) {
                instance.slots = children // make compiler marker non-enumerable

                def(children, '_', type)
              } else {
                normalizeObjectSlots(children, (instance.slots = {}))
              }
            } else {
              instance.slots = {}

              if (children) {
                normalizeVNodeSlots(instance, children)
              }
            }

            def(instance.slots, InternalObjectKey, 1)
          }

          var updateSlots = function updateSlots(instance, children) {
            var vnode = instance.vnode,
              slots = instance.slots
            var needDeletionCheck = true
            var deletionComparisonTarget = EMPTY_OBJ

            if (
              vnode.shapeFlag & 32
              /* SLOTS_CHILDREN */
            ) {
              var type = children._

              if (type) {
                // compiled slots.
                if (isHmrUpdating) {
                  // Parent was HMR updated so slot content may have changed.
                  // force update slots and mark instance for hmr as well
                  extend(slots, children)
                } else if (
                  type === 1
                  /* STABLE */
                ) {
                  // compiled AND stable.
                  // no need to update, and skip stale slots removal.
                  needDeletionCheck = false
                } else {
                  // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                  // normalization.
                  extend(slots, children)
                }
              } else {
                needDeletionCheck = !children.$stable
                normalizeObjectSlots(children, slots)
              }

              deletionComparisonTarget = children
            } else if (children) {
              // non slot object children (direct value) passed to a component
              normalizeVNodeSlots(instance, children)
              deletionComparisonTarget = {
                default: 1
              }
            } // delete stale slots

            if (needDeletionCheck) {
              for (var key in slots) {
                if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                  delete slots[key]
                }
              }
            }
          }
          /**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/

          var isBuiltInDirective = /*#__PURE__*/ makeMap(
            'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text'
          )

          function validateDirectiveName(name) {
            if (isBuiltInDirective(name)) {
              warn(
                'Do not use built-in directive ids as custom directive id: ' +
                  name
              )
            }
          }
          /**
           * Adds directives to a VNode.
           */

          function withDirectives(vnode, directives) {
            var internalInstance = currentRenderingInstance

            if (internalInstance === null) {
              warn('withDirectives can only be used inside render functions.')
              return vnode
            }

            var instance = internalInstance.proxy
            var bindings = vnode.dirs || (vnode.dirs = [])

            for (var i = 0; i < directives.length; i++) {
              var _directives$i = _slicedToArray(directives[i], 4),
                dir = _directives$i[0],
                value = _directives$i[1],
                arg = _directives$i[2],
                _directives$i$ = _directives$i[3],
                modifiers =
                  _directives$i$ === void 0 ? EMPTY_OBJ : _directives$i$

              if (isFunction(dir)) {
                dir = {
                  mounted: dir,
                  updated: dir
                }
              }

              bindings.push({
                dir: dir,
                instance: instance,
                value: value,
                oldValue: void 0,
                arg: arg,
                modifiers: modifiers
              })
            }

            return vnode
          }

          function invokeDirectiveHook(vnode, prevVNode, instance, name) {
            var bindings = vnode.dirs
            var oldBindings = prevVNode && prevVNode.dirs

            for (var i = 0; i < bindings.length; i++) {
              var binding = bindings[i]

              if (oldBindings) {
                binding.oldValue = oldBindings[i].value
              }

              var hook = binding.dir[name]

              if (hook) {
                callWithAsyncErrorHandling(
                  hook,
                  instance,
                  8,
                  /* DIRECTIVE_HOOK */
                  [vnode.el, binding, vnode, prevVNode]
                )
              }
            }
          }

          function createAppContext() {
            return {
              app: null,
              config: {
                isNativeTag: NO,
                performance: false,
                globalProperties: {},
                optionMergeStrategies: {},
                isCustomElement: NO,
                errorHandler: undefined,
                warnHandler: undefined
              },
              mixins: [],
              components: {},
              directives: {},
              provides: Object.create(null)
            }
          }

          var uid$1 = 0

          function createAppAPI(render, hydrate) {
            return function createApp(rootComponent) {
              var rootProps =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : null

              if (rootProps != null && !isObject(rootProps)) {
                warn('root props passed to app.mount() must be an object.')
                rootProps = null
              }

              var context = createAppContext()
              var installedPlugins = new Set()
              var isMounted = false
              var app = (context.app = {
                _uid: uid$1++,
                _component: rootComponent,
                _props: rootProps,
                _container: null,
                _context: context,
                version: version,

                get config() {
                  return context.config
                },

                set config(v) {
                  {
                    warn(
                      'app.config cannot be replaced. Modify individual options instead.'
                    )
                  }
                },

                use: function use(plugin) {
                  for (
                    var _len7 = arguments.length,
                      options = new Array(_len7 > 1 ? _len7 - 1 : 0),
                      _key11 = 1;
                    _key11 < _len7;
                    _key11++
                  ) {
                    options[_key11 - 1] = arguments[_key11]
                  }

                  if (installedPlugins.has(plugin)) {
                    warn('Plugin has already been applied to target app.')
                  } else if (plugin && isFunction(plugin.install)) {
                    installedPlugins.add(plugin)
                    plugin.install.apply(plugin, [app].concat(options))
                  } else if (isFunction(plugin)) {
                    installedPlugins.add(plugin)
                    plugin.apply(void 0, [app].concat(options))
                  } else {
                    warn(
                      'A plugin must either be a function or an object with an "install" ' +
                        'function.'
                    )
                  }

                  return app
                },
                mixin: function mixin(_mixin) {
                  {
                    if (!context.mixins.includes(_mixin)) {
                      context.mixins.push(_mixin) // global mixin with props/emits de-optimizes props/emits
                      // normalization caching.

                      if (_mixin.props || _mixin.emits) {
                        context.deopt = true
                      }
                    } else {
                      warn(
                        'Mixin has already been applied to target app' +
                          (_mixin.name ? ': '.concat(_mixin.name) : '')
                      )
                    }
                  }
                  return app
                },
                component: function component(name, _component) {
                  {
                    validateComponentName(name, context.config)
                  }

                  if (!_component) {
                    return context.components[name]
                  }

                  if (context.components[name]) {
                    warn(
                      'Component "'.concat(
                        name,
                        '" has already been registered in target app.'
                      )
                    )
                  }

                  context.components[name] = _component
                  return app
                },
                directive: function directive(name, _directive) {
                  {
                    validateDirectiveName(name)
                  }

                  if (!_directive) {
                    return context.directives[name]
                  }

                  if (context.directives[name]) {
                    warn(
                      'Directive "'.concat(
                        name,
                        '" has already been registered in target app.'
                      )
                    )
                  }

                  context.directives[name] = _directive
                  return app
                },
                mount: function mount(rootContainer, isHydrate) {
                  if (!isMounted) {
                    var vnode = createVNode(rootComponent, rootProps) // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.

                    vnode.appContext = context // HMR root reload

                    {
                      context.reload = function() {
                        render(cloneVNode(vnode), rootContainer)
                      }
                    }

                    if (isHydrate && hydrate) {
                      hydrate(vnode, rootContainer)
                    } else {
                      render(vnode, rootContainer)
                    }

                    isMounted = true
                    app._container = rootContainer
                    rootContainer.__vue_app__ = app
                    {
                      devtoolsInitApp(app, version)
                    }
                    return vnode.component.proxy
                  } else {
                    warn(
                      'App has already been mounted.\n' +
                        'If you want to remount the same app, move your app creation logic ' +
                        'into a factory function and create fresh app instances for each ' +
                        'mount - e.g. `const createMyApp = () => createApp(App)`'
                    )
                  }
                },
                unmount: function unmount() {
                  if (isMounted) {
                    render(null, app._container)
                    {
                      devtoolsUnmountApp(app)
                    }
                    delete app._container.__vue_app__
                  } else {
                    warn('Cannot unmount an app that is not mounted.')
                  }
                },
                provide: function provide(key, value) {
                  if (key in context.provides) {
                    warn(
                      'App already provides property with key "'.concat(
                        String(key),
                        '". '
                      ) + 'It will be overwritten with the new value.'
                    )
                  } // TypeScript doesn't allow symbols as index type
                  // https://github.com/Microsoft/TypeScript/issues/24587

                  context.provides[key] = value
                  return app
                }
              })
              return app
            }
          }

          var hasMismatch = false

          var isSVGContainer = function isSVGContainer(container) {
            return (
              /svg/.test(container.namespaceURI) &&
              container.tagName !== 'foreignObject'
            )
          }

          var isComment = function isComment(node) {
            return node.nodeType === 8
          }
          /* COMMENT */ // Note: hydration is DOM-specific
          // But we have to place it in core due to tight coupling with core - splitting
          // it out creates a ton of unnecessary complexity.
          // Hydration also depends on some renderer internal logic which needs to be
          // passed in via arguments.

          function createHydrationFunctions(rendererInternals) {
            var mountComponent = rendererInternals.mt,
              patch = rendererInternals.p,
              _rendererInternals$o2 = rendererInternals.o,
              patchProp = _rendererInternals$o2.patchProp,
              nextSibling = _rendererInternals$o2.nextSibling,
              parentNode = _rendererInternals$o2.parentNode,
              remove = _rendererInternals$o2.remove,
              insert = _rendererInternals$o2.insert,
              createComment = _rendererInternals$o2.createComment

            var hydrate = function hydrate(vnode, container) {
              if (!container.hasChildNodes()) {
                warn(
                  'Attempting to hydrate existing markup but container is empty. ' +
                    'Performing full mount instead.'
                )
                patch(null, vnode, container)
                return
              }

              hasMismatch = false
              hydrateNode(container.firstChild, vnode, null, null)
              flushPostFlushCbs()

              if (hasMismatch && !false) {
                // this error should show up in production
                console.error('Hydration completed but contains mismatches.')
              }
            }

            var hydrateNode = function hydrateNode(
              node,
              vnode,
              parentComponent,
              parentSuspense
            ) {
              var optimized =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : false
              var isFragmentStart = isComment(node) && node.data === '['

              var onMismatch = function onMismatch() {
                return handleMismatch(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  isFragmentStart
                )
              }

              var type = vnode.type,
                ref = vnode.ref,
                shapeFlag = vnode.shapeFlag
              var domType = node.nodeType
              vnode.el = node
              var nextNode = null

              switch (type) {
                case Text:
                  if (
                    domType !== 3
                    /* TEXT */
                  ) {
                    nextNode = onMismatch()
                  } else {
                    if (node.data !== vnode.children) {
                      hasMismatch = true
                      warn(
                        'Hydration text mismatch:' +
                          '\n- Client: '.concat(JSON.stringify(node.data)) +
                          '\n- Server: '.concat(JSON.stringify(vnode.children))
                      )
                      node.data = vnode.children
                    }

                    nextNode = nextSibling(node)
                  }

                  break

                case Comment:
                  if (
                    domType !== 8 ||
                    /* COMMENT */
                    isFragmentStart
                  ) {
                    nextNode = onMismatch()
                  } else {
                    nextNode = nextSibling(node)
                  }

                  break

                case Static:
                  if (
                    domType !== 1
                    /* ELEMENT */
                  ) {
                    nextNode = onMismatch()
                  } else {
                    // determine anchor, adopt content
                    nextNode = node // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.

                    var needToAdoptContent = !vnode.children.length

                    for (var i = 0; i < vnode.staticCount; i++) {
                      if (needToAdoptContent)
                        vnode.children += nextNode.outerHTML

                      if (i === vnode.staticCount - 1) {
                        vnode.anchor = nextNode
                      }

                      nextNode = nextSibling(nextNode)
                    }

                    return nextNode
                  }

                  break

                case Fragment:
                  if (!isFragmentStart) {
                    nextNode = onMismatch()
                  } else {
                    nextNode = hydrateFragment(
                      node,
                      vnode,
                      parentComponent,
                      parentSuspense,
                      optimized
                    )
                  }

                  break

                default:
                  if (
                    shapeFlag & 1
                    /* ELEMENT */
                  ) {
                    if (
                      domType !== 1 ||
                      /* ELEMENT */
                      vnode.type !== node.tagName.toLowerCase()
                    ) {
                      nextNode = onMismatch()
                    } else {
                      nextNode = hydrateElement(
                        node,
                        vnode,
                        parentComponent,
                        parentSuspense,
                        optimized
                      )
                    }
                  } else if (
                    shapeFlag & 6
                    /* COMPONENT */
                  ) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    var container = parentNode(node)

                    var hydrateComponent = function hydrateComponent() {
                      mountComponent(
                        vnode,
                        container,
                        null,
                        parentComponent,
                        parentSuspense,
                        isSVGContainer(container),
                        optimized
                      )
                    } // async component

                    var loadAsync = vnode.type.__asyncLoader

                    if (loadAsync) {
                      loadAsync().then(hydrateComponent)
                    } else {
                      hydrateComponent()
                    } // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.

                    nextNode = isFragmentStart
                      ? locateClosingAsyncAnchor(node)
                      : nextSibling(node)
                  } else if (
                    shapeFlag & 64
                    /* TELEPORT */
                  ) {
                    if (
                      domType !== 8
                      /* COMMENT */
                    ) {
                      nextNode = onMismatch()
                    } else {
                      nextNode = vnode.type.hydrate(
                        node,
                        vnode,
                        parentComponent,
                        parentSuspense,
                        optimized,
                        rendererInternals,
                        hydrateChildren
                      )
                    }
                  } else if (
                    shapeFlag & 128
                    /* SUSPENSE */
                  ) {
                    nextNode = vnode.type.hydrate(
                      node,
                      vnode,
                      parentComponent,
                      parentSuspense,
                      isSVGContainer(parentNode(node)),
                      optimized,
                      rendererInternals,
                      hydrateNode
                    )
                  } else {
                    warn(
                      'Invalid HostVNode type:',
                      type,
                      '('.concat(_typeof(type), ')')
                    )
                  }
              }

              if (ref != null) {
                setRef(ref, null, parentSuspense, vnode)
              }

              return nextNode
            }

            var hydrateElement = function hydrateElement(
              el,
              vnode,
              parentComponent,
              parentSuspense,
              optimized
            ) {
              optimized = optimized || !!vnode.dynamicChildren
              var props = vnode.props,
                patchFlag = vnode.patchFlag,
                shapeFlag = vnode.shapeFlag,
                dirs = vnode.dirs // skip props & children if this is hoisted static nodes

              if (
                patchFlag !== -1
                /* HOISTED */
              ) {
                if (dirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'created')
                } // props

                if (props) {
                  if (
                    !optimized ||
                    patchFlag & 16 ||
                    /* FULL_PROPS */
                    patchFlag & 32
                    /* HYDRATE_EVENTS */
                  ) {
                    for (var key in props) {
                      if (!isReservedProp(key) && isOn(key)) {
                        patchProp(el, key, null, props[key])
                      }
                    }
                  } else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick)
                  }
                } // vnode / directive hooks

                var vnodeHooks

                if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                  invokeVNodeHook(vnodeHooks, parentComponent, vnode)
                }

                if (dirs) {
                  invokeDirectiveHook(
                    vnode,
                    null,
                    parentComponent,
                    'beforeMount'
                  )
                }

                if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                  queueEffectWithSuspense(function() {
                    vnodeHooks &&
                      invokeVNodeHook(vnodeHooks, parentComponent, vnode)
                    dirs &&
                      invokeDirectiveHook(
                        vnode,
                        null,
                        parentComponent,
                        'mounted'
                      )
                  }, parentSuspense)
                } // children

                if (
                  shapeFlag & 16 && // skip if element has innerHTML / textContent
                  /* ARRAY_CHILDREN */
                  !(props && (props.innerHTML || props.textContent))
                ) {
                  var next = hydrateChildren(
                    el.firstChild,
                    vnode,
                    el,
                    parentComponent,
                    parentSuspense,
                    optimized
                  )
                  var _hasWarned = false

                  while (next) {
                    hasMismatch = true

                    if (!_hasWarned) {
                      warn(
                        'Hydration children mismatch in <'.concat(
                          vnode.type,
                          '>: '
                        ) +
                          'server rendered element contains more child nodes than client vdom.'
                      )
                      _hasWarned = true
                    } // The SSRed DOM contains more nodes than it should. Remove them.

                    var cur = next
                    next = next.nextSibling
                    remove(cur)
                  }
                } else if (
                  shapeFlag & 8
                  /* TEXT_CHILDREN */
                ) {
                  if (el.textContent !== vnode.children) {
                    hasMismatch = true
                    warn(
                      'Hydration text content mismatch in <'.concat(
                        vnode.type,
                        '>:\n'
                      ) +
                        '- Client: '.concat(el.textContent, '\n') +
                        '- Server: '.concat(vnode.children)
                    )
                    el.textContent = vnode.children
                  }
                }
              }

              return el.nextSibling
            }

            var hydrateChildren = function hydrateChildren(
              node,
              parentVNode,
              container,
              parentComponent,
              parentSuspense,
              optimized
            ) {
              optimized = optimized || !!parentVNode.dynamicChildren
              var children = parentVNode.children
              var l = children.length
              var hasWarned = false

              for (var i = 0; i < l; i++) {
                var vnode = optimized
                  ? children[i]
                  : (children[i] = normalizeVNode(children[i]))

                if (node) {
                  node = hydrateNode(
                    node,
                    vnode,
                    parentComponent,
                    parentSuspense,
                    optimized
                  )
                } else {
                  hasMismatch = true

                  if (!hasWarned) {
                    warn(
                      'Hydration children mismatch in <'.concat(
                        container.tagName.toLowerCase(),
                        '>: '
                      ) +
                        'server rendered element contains fewer child nodes than client vdom.'
                    )
                    hasWarned = true
                  } // the SSRed DOM didn't contain enough nodes. Mount the missing ones.

                  patch(
                    null,
                    vnode,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVGContainer(container)
                  )
                }
              }

              return node
            }

            var hydrateFragment = function hydrateFragment(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              optimized
            ) {
              var container = parentNode(node)
              var next = hydrateChildren(
                nextSibling(node),
                vnode,
                container,
                parentComponent,
                parentSuspense,
                optimized
              )

              if (next && isComment(next) && next.data === ']') {
                return nextSibling((vnode.anchor = next))
              } else {
                // fragment didn't hydrate successfully, since we didn't get a end anchor
                // back. This should have led to node/children mismatch warnings.
                hasMismatch = true // since the anchor is missing, we need to create one and insert it

                insert((vnode.anchor = createComment(']')), container, next)
                return next
              }
            }

            var handleMismatch = function handleMismatch(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              isFragment
            ) {
              hasMismatch = true
              warn(
                'Hydration node mismatch:\n- Client vnode:',
                vnode.type,
                '\n- Server rendered DOM:',
                node,
                node.nodeType === 3
                  ? /* TEXT */
                    '(text)'
                  : isComment(node) && node.data === '['
                    ? '(start of fragment)'
                    : ''
              )
              vnode.el = null

              if (isFragment) {
                // remove excessive fragment nodes
                var end = locateClosingAsyncAnchor(node)

                while (true) {
                  var _next2 = nextSibling(node)

                  if (_next2 && _next2 !== end) {
                    remove(_next2)
                  } else {
                    break
                  }
                }
              }

              var next = nextSibling(node)
              var container = parentNode(node)
              remove(node)
              patch(
                null,
                vnode,
                container,
                next,
                parentComponent,
                parentSuspense,
                isSVGContainer(container)
              )
              return next
            }

            var locateClosingAsyncAnchor = function locateClosingAsyncAnchor(
              node
            ) {
              var match = 0

              while (node) {
                node = nextSibling(node)

                if (node && isComment(node)) {
                  if (node.data === '[') match++

                  if (node.data === ']') {
                    if (match === 0) {
                      return nextSibling(node)
                    } else {
                      match--
                    }
                  }
                }
              }

              return node
            }

            return [hydrate, hydrateNode]
          }

          var supported
          var perf

          function startMeasure(instance, type) {
            if (instance.appContext.config.performance && isSupported()) {
              perf.mark('vue-'.concat(type, '-').concat(instance.uid))
            }
          }

          function endMeasure(instance, type) {
            if (instance.appContext.config.performance && isSupported()) {
              var startTag = 'vue-'.concat(type, '-').concat(instance.uid)
              var endTag = startTag + ':end'
              perf.mark(endTag)
              perf.measure(
                '<'
                  .concat(formatComponentName(instance, instance.type), '> ')
                  .concat(type),
                startTag,
                endTag
              )
              perf.clearMarks(startTag)
              perf.clearMarks(endTag)
            }
          }

          function isSupported() {
            if (supported !== undefined) {
              return supported
            }
            /* eslint-disable no-restricted-globals */

            if (typeof window !== 'undefined' && window.performance) {
              supported = true
              perf = window.performance
            } else {
              supported = false
            }
            /* eslint-enable no-restricted-globals */

            return supported
          } // implementation, close to no-op

          function defineComponent(options) {
            return isFunction(options)
              ? {
                  setup: options,
                  name: options.name
                }
              : options
          }

          var isAsyncWrapper = function isAsyncWrapper(i) {
            return !!i.type.__asyncLoader
          }

          function defineAsyncComponent(source) {
            if (isFunction(source)) {
              source = {
                loader: source
              }
            }

            var _source = source,
              loader = _source.loader,
              loadingComponent = _source.loadingComponent,
              errorComponent = _source.errorComponent,
              _source$delay = _source.delay,
              delay = _source$delay === void 0 ? 200 : _source$delay,
              timeout = _source.timeout,
              _source$suspensible = _source.suspensible,
              suspensible =
                _source$suspensible === void 0 ? true : _source$suspensible,
              userOnError = _source.onError
            var pendingRequest = null
            var resolvedComp
            var retries = 0

            var retry = function retry() {
              retries++
              pendingRequest = null
              return load()
            }

            var load = function load() {
              var thisRequest
              return (
                pendingRequest ||
                (thisRequest = pendingRequest = loader()
                  ['catch'](function(err) {
                    err = err instanceof Error ? err : new Error(String(err))

                    if (userOnError) {
                      return new Promise(function(resolve, reject) {
                        var userRetry = function userRetry() {
                          return resolve(retry())
                        }

                        var userFail = function userFail() {
                          return reject(err)
                        }

                        userOnError(err, userRetry, userFail, retries + 1)
                      })
                    } else {
                      throw err
                    }
                  })
                  .then(function(comp) {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                      return pendingRequest
                    }

                    if (!comp) {
                      warn(
                        'Async component loader resolved to undefined. ' +
                          'If you are using retry(), make sure to return its return value.'
                      )
                    } // interop module default

                    if (
                      comp &&
                      (comp.__esModule || comp[Symbol.toStringTag] === 'Module')
                    ) {
                      comp = comp['default']
                    }

                    if (comp && !isObject(comp) && !isFunction(comp)) {
                      throw new Error(
                        'Invalid async component load result: '.concat(comp)
                      )
                    }

                    resolvedComp = comp
                    return comp
                  }))
              )
            }

            return defineComponent({
              __asyncLoader: load,
              name: 'AsyncComponentWrapper',
              setup: function setup() {
                var instance = currentInstance // already resolved

                if (resolvedComp) {
                  return function() {
                    return createInnerComp(resolvedComp, instance)
                  }
                }

                var onError = function onError(err) {
                  pendingRequest = null
                  handleError(
                    err,
                    instance,
                    13,
                    /* ASYNC_COMPONENT_LOADER */
                    !errorComponent
                    /* do not throw in dev if user provided error component */
                  )
                } // suspense-controlled or SSR.

                if ((suspensible && instance.suspense) || false) {
                  return load()
                    .then(function(comp) {
                      return function() {
                        return createInnerComp(comp, instance)
                      }
                    })
                    ['catch'](function(err) {
                      onError(err)
                      return function() {
                        return errorComponent
                          ? createVNode(errorComponent, {
                              error: err
                            })
                          : null
                      }
                    })
                }

                var loaded = ref(false)
                var error = ref()
                var delayed = ref(!!delay)

                if (delay) {
                  setTimeout(function() {
                    delayed.value = false
                  }, delay)
                }

                if (timeout != null) {
                  setTimeout(function() {
                    if (!loaded.value && !error.value) {
                      var err = new Error(
                        'Async component timed out after '.concat(
                          timeout,
                          'ms.'
                        )
                      )
                      onError(err)
                      error.value = err
                    }
                  }, timeout)
                }

                load()
                  .then(function() {
                    loaded.value = true
                  })
                  ['catch'](function(err) {
                    onError(err)
                    error.value = err
                  })
                return function() {
                  if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance)
                  } else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                      error: error.value
                    })
                  } else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent)
                  }
                }
              }
            })
          }

          function createInnerComp(comp, _ref16) {
            var _ref16$vnode = _ref16.vnode,
              ref = _ref16$vnode.ref,
              props = _ref16$vnode.props,
              children = _ref16$vnode.children
            var vnode = createVNode(comp, props, children) // ensure inner component inherits the async wrapper's ref owner

            vnode.ref = ref
            return vnode
          }

          function createDevEffectOptions(instance) {
            return {
              scheduler: queueJob,
              allowRecurse: true,
              onTrack: instance.rtc
                ? function(e) {
                    return invokeArrayFns(instance.rtc, e)
                  }
                : void 0,
              onTrigger: instance.rtg
                ? function(e) {
                    return invokeArrayFns(instance.rtg, e)
                  }
                : void 0
            }
          }

          var queuePostRenderEffect = queueEffectWithSuspense

          var setRef = function setRef(
            rawRef,
            oldRawRef,
            parentSuspense,
            vnode
          ) {
            if (isArray(rawRef)) {
              rawRef.forEach(function(r, i) {
                return setRef(
                  r,
                  oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
                  parentSuspense,
                  vnode
                )
              })
              return
            }

            var value

            if (!vnode || isAsyncWrapper(vnode)) {
              value = null
            } else {
              if (
                vnode.shapeFlag & 4
                /* STATEFUL_COMPONENT */
              ) {
                value = vnode.component.exposed || vnode.component.proxy
              } else {
                value = vnode.el
              }
            }

            var owner = rawRef.i,
              ref = rawRef.r

            if (!owner) {
              warn(
                'Missing ref owner context. ref cannot be used on hoisted vnodes. ' +
                  'A vnode with ref must be created inside the render function.'
              )
              return
            }

            var oldRef = oldRawRef && oldRawRef.r
            var refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs
            var setupState = owner.setupState // unset old ref

            if (oldRef != null && oldRef !== ref) {
              if (isString(oldRef)) {
                refs[oldRef] = null

                if (hasOwn(setupState, oldRef)) {
                  setupState[oldRef] = null
                }
              } else if (isRef(oldRef)) {
                oldRef.value = null
              }
            }

            if (isString(ref)) {
              var doSet = function doSet() {
                refs[ref] = value

                if (hasOwn(setupState, ref)) {
                  setupState[ref] = value
                }
              } // #1789: for non-null values, set them after render
              // null values means this is unmount and it should not overwrite another
              // ref with the same key

              if (value) {
                doSet.id = -1
                queuePostRenderEffect(doSet, parentSuspense)
              } else {
                doSet()
              }
            } else if (isRef(ref)) {
              var _doSet = function _doSet() {
                ref.value = value
              }

              if (value) {
                _doSet.id = -1
                queuePostRenderEffect(_doSet, parentSuspense)
              } else {
                _doSet()
              }
            } else if (isFunction(ref)) {
              callWithErrorHandling(
                ref,
                owner,
                12,
                /* FUNCTION_REF */
                [value, refs]
              )
            } else {
              warn(
                'Invalid template ref type:',
                value,
                '('.concat(_typeof(value), ')')
              )
            }
          }
          /**
           * The createRenderer function accepts two generic arguments:
           * HostNode and HostElement, corresponding to Node and Element types in the
           * host environment. For example, for runtime-dom, HostNode would be the DOM
           * `Node` interface and HostElement would be the DOM `Element` interface.
           *
           * Custom renderers can pass in the platform specific types like this:
           *
           * ``` js
           * const { render, createApp } = createRenderer<Node, Element>({
           *   patchProp,
           *   ...nodeOps
           * })
           * ```
           */

          function createRenderer(options) {
            return baseCreateRenderer(options)
          } // Separate API for creating hydration-enabled renderer.
          // Hydration logic is only used when calling this function, making it
          // tree-shakable.

          function createHydrationRenderer(options) {
            return baseCreateRenderer(options, createHydrationFunctions)
          } // implementation

          function baseCreateRenderer(options, createHydrationFns) {
            {
              var target = getGlobalThis()
              target.__VUE__ = true
              setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__)
            }
            var hostInsert = options.insert,
              hostRemove = options.remove,
              hostPatchProp = options.patchProp,
              hostForcePatchProp = options.forcePatchProp,
              hostCreateElement = options.createElement,
              hostCreateText = options.createText,
              hostCreateComment = options.createComment,
              hostSetText = options.setText,
              hostSetElementText = options.setElementText,
              hostParentNode = options.parentNode,
              hostNextSibling = options.nextSibling,
              _options$setScopeId = options.setScopeId,
              hostSetScopeId =
                _options$setScopeId === void 0 ? NOOP : _options$setScopeId,
              hostCloneNode = options.cloneNode,
              hostInsertStaticContent = options.insertStaticContent // Note: functions inside this closure should use `const xxx = () => {}`
            // style in order to prevent being inlined by minifiers.

            var patch = function patch(n1, n2, container) {
              var anchor =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : null
              var parentComponent =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : null
              var parentSuspense =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : null
              var isSVG =
                arguments.length > 6 && arguments[6] !== undefined
                  ? arguments[6]
                  : false
              var optimized =
                arguments.length > 7 && arguments[7] !== undefined
                  ? arguments[7]
                  : false

              // patching & not same type, unmount old tree
              if (n1 && !isSameVNodeType(n1, n2)) {
                anchor = getNextHostNode(n1)
                unmount(n1, parentComponent, parentSuspense, true)
                n1 = null
              }

              if (
                n2.patchFlag === -2
                /* BAIL */
              ) {
                optimized = false
                n2.dynamicChildren = null
              }

              var type = n2.type,
                ref = n2.ref,
                shapeFlag = n2.shapeFlag

              switch (type) {
                case Text:
                  processText(n1, n2, container, anchor)
                  break

                case Comment:
                  processCommentNode(n1, n2, container, anchor)
                  break

                case Static:
                  if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG)
                  } else {
                    patchStaticNode(n1, n2, container, isSVG)
                  }

                  break

                case Fragment:
                  processFragment(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                  break

                default:
                  if (
                    shapeFlag & 1
                    /* ELEMENT */
                  ) {
                    processElement(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  } else if (
                    shapeFlag & 6
                    /* COMPONENT */
                  ) {
                    processComponent(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  } else if (
                    shapeFlag & 64
                    /* TELEPORT */
                  ) {
                    type.process(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized,
                      internals
                    )
                  } else if (
                    shapeFlag & 128
                    /* SUSPENSE */
                  ) {
                    type.process(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized,
                      internals
                    )
                  } else {
                    warn(
                      'Invalid VNode type:',
                      type,
                      '('.concat(_typeof(type), ')')
                    )
                  }
              } // set ref

              if (ref != null && parentComponent) {
                setRef(ref, n1 && n1.ref, parentSuspense, n2)
              }
            }

            var processText = function processText(n1, n2, container, anchor) {
              if (n1 == null) {
                hostInsert(
                  (n2.el = hostCreateText(n2.children)),
                  container,
                  anchor
                )
              } else {
                var el = (n2.el = n1.el)

                if (n2.children !== n1.children) {
                  hostSetText(el, n2.children)
                }
              }
            }

            var processCommentNode = function processCommentNode(
              n1,
              n2,
              container,
              anchor
            ) {
              if (n1 == null) {
                hostInsert(
                  (n2.el = hostCreateComment(n2.children || '')),
                  container,
                  anchor
                )
              } else {
                // there's no support for dynamic comments
                n2.el = n1.el
              }
            }

            var mountStaticNode = function mountStaticNode(
              n2,
              container,
              anchor,
              isSVG
            ) {
              var _hostInsertStaticCont = hostInsertStaticContent(
                n2.children,
                container,
                anchor,
                isSVG
              )

              var _hostInsertStaticCont2 = _slicedToArray(
                _hostInsertStaticCont,
                2
              )

              n2.el = _hostInsertStaticCont2[0]
              n2.anchor = _hostInsertStaticCont2[1]
            }
            /**
             * Dev / HMR only
             */

            var patchStaticNode = function patchStaticNode(
              n1,
              n2,
              container,
              isSVG
            ) {
              // static nodes are only patched during dev for HMR
              if (n2.children !== n1.children) {
                var anchor = hostNextSibling(n1.anchor) // remove existing

                removeStaticNode(n1)

                var _hostInsertStaticCont3 = hostInsertStaticContent(
                  n2.children,
                  container,
                  anchor,
                  isSVG
                )

                var _hostInsertStaticCont4 = _slicedToArray(
                  _hostInsertStaticCont3,
                  2
                )

                n2.el = _hostInsertStaticCont4[0]
                n2.anchor = _hostInsertStaticCont4[1]
              } else {
                n2.el = n1.el
                n2.anchor = n1.anchor
              }
            }

            var moveStaticNode = function moveStaticNode(
              _ref17,
              container,
              nextSibling
            ) {
              var el = _ref17.el,
                anchor = _ref17.anchor
              var next

              while (el && el !== anchor) {
                next = hostNextSibling(el)
                hostInsert(el, container, nextSibling)
                el = next
              }

              hostInsert(anchor, container, nextSibling)
            }

            var removeStaticNode = function removeStaticNode(_ref18) {
              var el = _ref18.el,
                anchor = _ref18.anchor
              var next

              while (el && el !== anchor) {
                next = hostNextSibling(el)
                hostRemove(el)
                el = next
              }

              hostRemove(anchor)
            }

            var processElement = function processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              isSVG = isSVG || n2.type === 'svg'

              if (n1 == null) {
                mountElement(
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              } else {
                patchElement(
                  n1,
                  n2,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              }
            }

            var mountElement = function mountElement(
              vnode,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              var el
              var vnodeHook
              var type = vnode.type,
                props = vnode.props,
                shapeFlag = vnode.shapeFlag,
                transition = vnode.transition,
                scopeId = vnode.scopeId,
                patchFlag = vnode.patchFlag,
                dirs = vnode.dirs
              {
                el = vnode.el = hostCreateElement(
                  vnode.type,
                  isSVG,
                  props && props.is
                ) // mount children first, since some props may rely on child content
                // being already rendered, e.g. `<select value>`

                if (
                  shapeFlag & 8
                  /* TEXT_CHILDREN */
                ) {
                  hostSetElementText(el, vnode.children)
                } else if (
                  shapeFlag & 16
                  /* ARRAY_CHILDREN */
                ) {
                  mountChildren(
                    vnode.children,
                    el,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVG && type !== 'foreignObject',
                    optimized || !!vnode.dynamicChildren
                  )
                }

                if (dirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'created')
                } // props

                if (props) {
                  for (var key in props) {
                    if (!isReservedProp(key)) {
                      hostPatchProp(
                        el,
                        key,
                        null,
                        props[key],
                        isSVG,
                        vnode.children,
                        parentComponent,
                        parentSuspense,
                        unmountChildren
                      )
                    }
                  }

                  if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode)
                  }
                } // scopeId

                setScopeId(el, scopeId, vnode, parentComponent)
              }
              {
                Object.defineProperty(el, '__vnode', {
                  value: vnode,
                  enumerable: false
                })
                Object.defineProperty(el, '__vueParentComponent', {
                  value: parentComponent,
                  enumerable: false
                })
              }

              if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount')
              } // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
              // #1689 For inside suspense + suspense resolved case, just call it

              var needCallTransitionHooks =
                (!parentSuspense ||
                  (parentSuspense && !parentSuspense.pendingBranch)) &&
                transition &&
                !transition.persisted

              if (needCallTransitionHooks) {
                transition.beforeEnter(el)
              }

              hostInsert(el, container, anchor)

              if (
                (vnodeHook = props && props.onVnodeMounted) ||
                needCallTransitionHooks ||
                dirs
              ) {
                queuePostRenderEffect(function() {
                  vnodeHook &&
                    invokeVNodeHook(vnodeHook, parentComponent, vnode)
                  needCallTransitionHooks && transition.enter(el)
                  dirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'mounted')
                }, parentSuspense)
              }
            }

            var setScopeId = function setScopeId(
              el,
              scopeId,
              vnode,
              parentComponent
            ) {
              if (scopeId) {
                hostSetScopeId(el, scopeId)
              }

              if (parentComponent) {
                var treeOwnerId = parentComponent.type.__scopeId // vnode's own scopeId and the current patched component's scopeId is
                // different - this is a slot content node.

                if (treeOwnerId && treeOwnerId !== scopeId) {
                  hostSetScopeId(el, treeOwnerId + '-s')
                }

                var subTree = parentComponent.subTree

                if (subTree.type === Fragment) {
                  subTree = filterSingleRoot(subTree.children) || subTree
                }

                if (vnode === subTree) {
                  setScopeId(
                    el,
                    parentComponent.vnode.scopeId,
                    parentComponent.vnode,
                    parentComponent.parent
                  )
                }
              }
            }

            var mountChildren = function mountChildren(
              children,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              var start =
                arguments.length > 7 && arguments[7] !== undefined
                  ? arguments[7]
                  : 0

              for (var i = start; i < children.length; i++) {
                var child = (children[i] = optimized
                  ? cloneIfMounted(children[i])
                  : normalizeVNode(children[i]))
                patch(
                  null,
                  child,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              }
            }

            var patchElement = function patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              var el = (n2.el = n1.el)
              var patchFlag = n2.patchFlag,
                dynamicChildren = n2.dynamicChildren,
                dirs = n2.dirs // #1426 take the old vnode's patch flag into account since user may clone a
              // compiler-generated vnode, which de-opts to FULL_PROPS

              patchFlag |= n1.patchFlag & 16
              /* FULL_PROPS */
              var oldProps = n1.props || EMPTY_OBJ
              var newProps = n2.props || EMPTY_OBJ
              var vnodeHook

              if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
                invokeVNodeHook(vnodeHook, parentComponent, n2, n1)
              }

              if (dirs) {
                invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate')
              }

              if (isHmrUpdating) {
                // HMR updated, force full diff
                patchFlag = 0
                optimized = false
                dynamicChildren = null
              }

              if (patchFlag > 0) {
                // the presence of a patchFlag means this element's render code was
                // generated by the compiler and can take the fast path.
                // in this path old node and new node are guaranteed to have the same shape
                // (i.e. at the exact same position in the source template)
                if (
                  patchFlag & 16
                  /* FULL_PROPS */
                ) {
                  // element props contain dynamic keys, full diff needed
                  patchProps(
                    el,
                    n2,
                    oldProps,
                    newProps,
                    parentComponent,
                    parentSuspense,
                    isSVG
                  )
                } else {
                  // class
                  // this flag is matched when the element has dynamic class bindings.
                  if (
                    patchFlag & 2
                    /* CLASS */
                  ) {
                    if (oldProps['class'] !== newProps['class']) {
                      hostPatchProp(el, 'class', null, newProps['class'], isSVG)
                    }
                  } // style
                  // this flag is matched when the element has dynamic style bindings

                  if (
                    patchFlag & 4
                    /* STYLE */
                  ) {
                    hostPatchProp(
                      el,
                      'style',
                      oldProps.style,
                      newProps.style,
                      isSVG
                    )
                  } // props
                  // This flag is matched when the element has dynamic prop/attr bindings
                  // other than class and style. The keys of dynamic prop/attrs are saved for
                  // faster iteration.
                  // Note dynamic keys like :[foo]="bar" will cause this optimization to
                  // bail out and go through a full diff because we need to unset the old key

                  if (
                    patchFlag & 8
                    /* PROPS */
                  ) {
                    // if the flag is present then dynamicProps must be non-null
                    var propsToUpdate = n2.dynamicProps

                    for (var i = 0; i < propsToUpdate.length; i++) {
                      var key = propsToUpdate[i]
                      var prev = oldProps[key]
                      var next = newProps[key]

                      if (
                        next !== prev ||
                        (hostForcePatchProp && hostForcePatchProp(el, key))
                      ) {
                        hostPatchProp(
                          el,
                          key,
                          prev,
                          next,
                          isSVG,
                          n1.children,
                          parentComponent,
                          parentSuspense,
                          unmountChildren
                        )
                      }
                    }
                  }
                } // text
                // This flag is matched when the element has only dynamic text children.

                if (
                  patchFlag & 1
                  /* TEXT */
                ) {
                  if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children)
                  }
                }
              } else if (!optimized && dynamicChildren == null) {
                // unoptimized, full diff
                patchProps(
                  el,
                  n2,
                  oldProps,
                  newProps,
                  parentComponent,
                  parentSuspense,
                  isSVG
                )
              }

              var areChildrenSVG = isSVG && n2.type !== 'foreignObject'

              if (dynamicChildren) {
                patchBlockChildren(
                  n1.dynamicChildren,
                  dynamicChildren,
                  el,
                  parentComponent,
                  parentSuspense,
                  areChildrenSVG
                )

                if (parentComponent && parentComponent.type.__hmrId) {
                  traverseStaticChildren(n1, n2)
                }
              } else if (!optimized) {
                // full diff
                patchChildren(
                  n1,
                  n2,
                  el,
                  null,
                  parentComponent,
                  parentSuspense,
                  areChildrenSVG
                )
              }

              if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
                queuePostRenderEffect(function() {
                  vnodeHook &&
                    invokeVNodeHook(vnodeHook, parentComponent, n2, n1)
                  dirs &&
                    invokeDirectiveHook(n2, n1, parentComponent, 'updated')
                }, parentSuspense)
              }
            } // The fast path for blocks.

            var patchBlockChildren = function patchBlockChildren(
              oldChildren,
              newChildren,
              fallbackContainer,
              parentComponent,
              parentSuspense,
              isSVG
            ) {
              for (var i = 0; i < newChildren.length; i++) {
                var oldVNode = oldChildren[i]
                var newVNode = newChildren[i] // Determine the container (parent element) for the patch.

                var container = // - In the case of a Fragment, we need to provide the actual parent
                  // of the Fragment itself so it can move its children.
                  oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
                  // which also requires the correct parent container
                  !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
                  oldVNode.shapeFlag & 6 ||
                  /* COMPONENT */
                  oldVNode.shapeFlag & 64
                    ? /* TELEPORT */
                      hostParentNode(oldVNode.el) // In other cases, the parent container is not actually used so we
                    : // just pass the block element here to avoid a DOM parentNode call.
                      fallbackContainer
                patch(
                  oldVNode,
                  newVNode,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  true
                )
              }
            }

            var patchProps = function patchProps(
              el,
              vnode,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG
            ) {
              if (oldProps !== newProps) {
                for (var key in newProps) {
                  // empty string is not valid prop
                  if (isReservedProp(key)) continue
                  var next = newProps[key]
                  var prev = oldProps[key]

                  if (
                    next !== prev ||
                    (hostForcePatchProp && hostForcePatchProp(el, key))
                  ) {
                    hostPatchProp(
                      el,
                      key,
                      prev,
                      next,
                      isSVG,
                      vnode.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    )
                  }
                }

                if (oldProps !== EMPTY_OBJ) {
                  for (var _key12 in oldProps) {
                    if (!isReservedProp(_key12) && !(_key12 in newProps)) {
                      hostPatchProp(
                        el,
                        _key12,
                        oldProps[_key12],
                        null,
                        isSVG,
                        vnode.children,
                        parentComponent,
                        parentSuspense,
                        unmountChildren
                      )
                    }
                  }
                }
              }
            }

            var processFragment = function processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              var fragmentStartAnchor = (n2.el = n1
                ? n1.el
                : hostCreateText(''))
              var fragmentEndAnchor = (n2.anchor = n1
                ? n1.anchor
                : hostCreateText(''))
              var patchFlag = n2.patchFlag,
                dynamicChildren = n2.dynamicChildren

              if (patchFlag > 0) {
                optimized = true
              }

              if (isHmrUpdating) {
                // HMR updated, force full diff
                patchFlag = 0
                optimized = false
                dynamicChildren = null
              }

              if (n1 == null) {
                hostInsert(fragmentStartAnchor, container, anchor)
                hostInsert(fragmentEndAnchor, container, anchor) // a fragment can only have array children
                // since they are either generated by the compiler, or implicitly created
                // from arrays.

                mountChildren(
                  n2.children,
                  container,
                  fragmentEndAnchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              } else {
                if (
                  patchFlag > 0 &&
                  patchFlag & 64 &&
                  /* STABLE_FRAGMENT */
                  dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
                  // of renderSlot() with no valid children
                  n1.dynamicChildren
                ) {
                  // a stable fragment (template root or <template v-for>) doesn't need to
                  // patch children order, but it may contain dynamicChildren.
                  patchBlockChildren(
                    n1.dynamicChildren,
                    dynamicChildren,
                    container,
                    parentComponent,
                    parentSuspense,
                    isSVG
                  )

                  if (parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2)
                  } else if (
                    // #2080 if the stable fragment has a key, it's a <template v-for> that may
                    //  get moved around. Make sure all root level vnodes inherit el.
                    // #2134 or if it's a component root, it may also get moved around
                    // as the component is being moved.
                    n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)
                  ) {
                    traverseStaticChildren(
                      n1,
                      n2,
                      true
                      /* shallow */
                    )
                  }
                } else {
                  // keyed / unkeyed, or manual fragments.
                  // for keyed & unkeyed, since they are compiler generated from v-for,
                  // each child is guaranteed to be a block so the fragment will never
                  // have dynamicChildren.
                  patchChildren(
                    n1,
                    n2,
                    container,
                    fragmentEndAnchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                }
              }
            }

            var processComponent = function processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              if (n1 == null) {
                if (
                  n2.shapeFlag & 512
                  /* COMPONENT_KEPT_ALIVE */
                ) {
                  parentComponent.ctx.activate(
                    n2,
                    container,
                    anchor,
                    isSVG,
                    optimized
                  )
                } else {
                  mountComponent(
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                }
              } else {
                updateComponent(n1, n2, optimized)
              }
            }

            var mountComponent = function mountComponent(
              initialVNode,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              var instance = (initialVNode.component = createComponentInstance(
                initialVNode,
                parentComponent,
                parentSuspense
              ))

              if (instance.type.__hmrId) {
                registerHMR(instance)
              }

              {
                pushWarningContext(initialVNode)
                startMeasure(instance, 'mount')
              } // inject renderer internals for keepAlive

              if (isKeepAlive(initialVNode)) {
                instance.ctx.renderer = internals
              } // resolve props and slots for setup context

              {
                startMeasure(instance, 'init')
              }
              setupComponent(instance)
              {
                endMeasure(instance, 'init')
              } // setup() is async. This component relies on async logic to be resolved
              // before proceeding

              if (instance.asyncDep) {
                parentSuspense &&
                  parentSuspense.registerDep(instance, setupRenderEffect) // Give it a placeholder if this is not hydration
                // TODO handle self-defined fallback

                if (!initialVNode.el) {
                  var placeholder = (instance.subTree = createVNode(Comment))
                  processCommentNode(null, placeholder, container, anchor)
                }

                return
              }

              setupRenderEffect(
                instance,
                initialVNode,
                container,
                anchor,
                parentSuspense,
                isSVG,
                optimized
              )
              {
                popWarningContext()
                endMeasure(instance, 'mount')
              }
            }

            var updateComponent = function updateComponent(n1, n2, optimized) {
              var instance = (n2.component = n1.component)

              if (shouldUpdateComponent(n1, n2, optimized)) {
                if (instance.asyncDep && !instance.asyncResolved) {
                  // async & still pending - just update props and slots
                  // since the component's reactive effect for render isn't set-up yet
                  {
                    pushWarningContext(n2)
                  }
                  updateComponentPreRender(instance, n2, optimized)
                  {
                    popWarningContext()
                  }
                  return
                } else {
                  // normal update
                  instance.next = n2 // in case the child component is also queued, remove it to avoid
                  // double updating the same child component in the same flush.

                  invalidateJob(instance.update) // instance.update is the reactive effect runner.

                  instance.update()
                }
              } else {
                // no update needed. just copy over properties
                n2.component = n1.component
                n2.el = n1.el
                instance.vnode = n2
              }
            }

            var setupRenderEffect = function setupRenderEffect(
              instance,
              initialVNode,
              container,
              anchor,
              parentSuspense,
              isSVG,
              optimized
            ) {
              // create reactive effect for rendering
              instance.update = effect(function componentEffect() {
                if (!instance.isMounted) {
                  var vnodeHook
                  var _initialVNode = initialVNode,
                    el = _initialVNode.el,
                    props = _initialVNode.props
                  var bm = instance.bm,
                    m = instance.m,
                    parent = instance.parent // beforeMount hook

                  if (bm) {
                    invokeArrayFns(bm)
                  } // onVnodeBeforeMount

                  if ((vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode)
                  } // render

                  {
                    startMeasure(instance, 'render')
                  }
                  var subTree = (instance.subTree = renderComponentRoot(
                    instance
                  ))
                  {
                    endMeasure(instance, 'render')
                  }

                  if (el && hydrateNode) {
                    {
                      startMeasure(instance, 'hydrate')
                    } // vnode has adopted host node - perform hydration instead of mount.

                    hydrateNode(
                      initialVNode.el,
                      subTree,
                      instance,
                      parentSuspense
                    )
                    {
                      endMeasure(instance, 'hydrate')
                    }
                  } else {
                    {
                      startMeasure(instance, 'patch')
                    }
                    patch(
                      null,
                      subTree,
                      container,
                      anchor,
                      instance,
                      parentSuspense,
                      isSVG
                    )
                    {
                      endMeasure(instance, 'patch')
                    }
                    initialVNode.el = subTree.el
                  } // mounted hook

                  if (m) {
                    queuePostRenderEffect(m, parentSuspense)
                  } // onVnodeMounted

                  if ((vnodeHook = props && props.onVnodeMounted)) {
                    var scopedInitialVNode = initialVNode
                    queuePostRenderEffect(function() {
                      invokeVNodeHook(vnodeHook, parent, scopedInitialVNode)
                    }, parentSuspense)
                  } // activated hook for keep-alive roots.
                  // #1742 activated hook must be accessed after first render
                  // since the hook may be injected by a child keep-alive

                  var a = instance.a

                  if (
                    a &&
                    initialVNode.shapeFlag & 256
                    /* COMPONENT_SHOULD_KEEP_ALIVE */
                  ) {
                    queuePostRenderEffect(a, parentSuspense)
                  }

                  instance.isMounted = true
                  {
                    devtoolsComponentAdded(instance)
                  } // #2458: deference mount-only object parameters to prevent memleaks

                  initialVNode = container = anchor = null
                } else {
                  // updateComponent
                  // This is triggered by mutation of component's own state (next: null)
                  // OR parent calling processComponent (next: VNode)
                  var next = instance.next,
                    bu = instance.bu,
                    u = instance.u,
                    _parent = instance.parent,
                    vnode = instance.vnode
                  var originNext = next

                  var _vnodeHook

                  {
                    pushWarningContext(next || instance.vnode)
                  }

                  if (next) {
                    next.el = vnode.el
                    updateComponentPreRender(instance, next, optimized)
                  } else {
                    next = vnode
                  } // beforeUpdate hook

                  if (bu) {
                    invokeArrayFns(bu)
                  } // onVnodeBeforeUpdate

                  if (
                    (_vnodeHook = next.props && next.props.onVnodeBeforeUpdate)
                  ) {
                    invokeVNodeHook(_vnodeHook, _parent, next, vnode)
                  } // render

                  {
                    startMeasure(instance, 'render')
                  }
                  var nextTree = renderComponentRoot(instance)
                  {
                    endMeasure(instance, 'render')
                  }
                  var prevTree = instance.subTree
                  instance.subTree = nextTree
                  {
                    startMeasure(instance, 'patch')
                  }
                  patch(
                    prevTree,
                    nextTree, // parent may have changed if it's in a teleport
                    hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                    getNextHostNode(prevTree),
                    instance,
                    parentSuspense,
                    isSVG
                  )
                  {
                    endMeasure(instance, 'patch')
                  }
                  next.el = nextTree.el

                  if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el)
                  } // updated hook

                  if (u) {
                    queuePostRenderEffect(u, parentSuspense)
                  } // onVnodeUpdated

                  if ((_vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(function() {
                      invokeVNodeHook(_vnodeHook, _parent, next, vnode)
                    }, parentSuspense)
                  }

                  {
                    devtoolsComponentUpdated(instance)
                  }
                  {
                    popWarningContext()
                  }
                }
              }, createDevEffectOptions(instance))
            }

            var updateComponentPreRender = function updateComponentPreRender(
              instance,
              nextVNode,
              optimized
            ) {
              nextVNode.component = instance
              var prevProps = instance.vnode.props
              instance.vnode = nextVNode
              instance.next = null
              updateProps(instance, nextVNode.props, prevProps, optimized)
              updateSlots(instance, nextVNode.children) // props update may have triggered pre-flush watchers.
              // flush them before the render update.

              flushPreFlushCbs(undefined, instance.update)
            }

            var patchChildren = function patchChildren(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG
            ) {
              var optimized =
                arguments.length > 7 && arguments[7] !== undefined
                  ? arguments[7]
                  : false
              var c1 = n1 && n1.children
              var prevShapeFlag = n1 ? n1.shapeFlag : 0
              var c2 = n2.children
              var patchFlag = n2.patchFlag,
                shapeFlag = n2.shapeFlag // fast path

              if (patchFlag > 0) {
                if (
                  patchFlag & 128
                  /* KEYED_FRAGMENT */
                ) {
                  // this could be either fully-keyed or mixed (some keyed some not)
                  // presence of patchFlag means children are guaranteed to be arrays
                  patchKeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                  return
                } else if (
                  patchFlag & 256
                  /* UNKEYED_FRAGMENT */
                ) {
                  // unkeyed
                  patchUnkeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                  return
                }
              } // children has 3 possibilities: text, array or no children.

              if (
                shapeFlag & 8
                /* TEXT_CHILDREN */
              ) {
                // text children fast path
                if (
                  prevShapeFlag & 16
                  /* ARRAY_CHILDREN */
                ) {
                  unmountChildren(c1, parentComponent, parentSuspense)
                }

                if (c2 !== c1) {
                  hostSetElementText(container, c2)
                }
              } else {
                if (
                  prevShapeFlag & 16
                  /* ARRAY_CHILDREN */
                ) {
                  // prev children was array
                  if (
                    shapeFlag & 16
                    /* ARRAY_CHILDREN */
                  ) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(
                      c1,
                      c2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  } else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true)
                  }
                } else {
                  // prev children was text OR null
                  // new children is array OR null
                  if (
                    prevShapeFlag & 8
                    /* TEXT_CHILDREN */
                  ) {
                    hostSetElementText(container, '')
                  } // mount new if array

                  if (
                    shapeFlag & 16
                    /* ARRAY_CHILDREN */
                  ) {
                    mountChildren(
                      c2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  }
                }
              }
            }

            var patchUnkeyedChildren = function patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              c1 = c1 || EMPTY_ARR
              c2 = c2 || EMPTY_ARR
              var oldLength = c1.length
              var newLength = c2.length
              var commonLength = Math.min(oldLength, newLength)
              var i

              for (i = 0; i < commonLength; i++) {
                var nextChild = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]))
                patch(
                  c1[i],
                  nextChild,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              }

              if (oldLength > newLength) {
                // remove old
                unmountChildren(
                  c1,
                  parentComponent,
                  parentSuspense,
                  true,
                  false,
                  commonLength
                )
              } else {
                // mount new
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized,
                  commonLength
                )
              }
            } // can be all-keyed or mixed

            var patchKeyedChildren = function patchKeyedChildren(
              c1,
              c2,
              container,
              parentAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) {
              var i = 0
              var l2 = c2.length
              var e1 = c1.length - 1 // prev ending index

              var e2 = l2 - 1 // next ending index
              // 1. sync from start
              // (a b) c
              // (a b) d e

              while (i <= e1 && i <= e2) {
                var n1 = c1[i]
                var n2 = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]))

                if (isSameVNodeType(n1, n2)) {
                  patch(
                    n1,
                    n2,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                } else {
                  break
                }

                i++
              } // 2. sync from end
              // a (b c)
              // d e (b c)

              while (i <= e1 && i <= e2) {
                var _n2 = c1[e1]

                var _n3 = (c2[e2] = optimized
                  ? cloneIfMounted(c2[e2])
                  : normalizeVNode(c2[e2]))

                if (isSameVNodeType(_n2, _n3)) {
                  patch(
                    _n2,
                    _n3,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                } else {
                  break
                }

                e1--
                e2--
              } // 3. common sequence + mount
              // (a b)
              // (a b) c
              // i = 2, e1 = 1, e2 = 2
              // (a b)
              // c (a b)
              // i = 0, e1 = -1, e2 = 0

              if (i > e1) {
                if (i <= e2) {
                  var nextPos = e2 + 1
                  var anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor

                  while (i <= e2) {
                    patch(
                      null,
                      (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])),
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG
                    )
                    i++
                  }
                }
              } // 4. common sequence + unmount
              // (a b) c
              // (a b)
              // i = 2, e1 = 2, e2 = 1
              // a (b c)
              // (b c)
              // i = 0, e1 = 0, e2 = -1
              else if (i > e2) {
                while (i <= e1) {
                  unmount(c1[i], parentComponent, parentSuspense, true)
                  i++
                }
              } // 5. unknown sequence
              // [i ... e1 + 1]: a b [c d e] f g
              // [i ... e2 + 1]: a b [e d c h] f g
              // i = 2, e1 = 4, e2 = 5
              else {
                var s1 = i // prev starting index

                var s2 = i // next starting index
                // 5.1 build key:index map for newChildren

                var keyToNewIndexMap = new Map()

                for (i = s2; i <= e2; i++) {
                  var nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]))

                  if (nextChild.key != null) {
                    if (keyToNewIndexMap.has(nextChild.key)) {
                      warn(
                        'Duplicate keys found during update:',
                        JSON.stringify(nextChild.key),
                        'Make sure keys are unique.'
                      )
                    }

                    keyToNewIndexMap.set(nextChild.key, i)
                  }
                } // 5.2 loop through old children left to be patched and try to patch
                // matching nodes & remove nodes that are no longer present

                var j
                var patched = 0
                var toBePatched = e2 - s2 + 1
                var moved = false // used to track whether any node has moved

                var maxNewIndexSoFar = 0 // works as Map<newIndex, oldIndex>
                // Note that oldIndex is offset by +1
                // and oldIndex = 0 is a special value indicating the new node has
                // no corresponding old node.
                // used for determining longest stable subsequence

                var newIndexToOldIndexMap = new Array(toBePatched)

                for (i = 0; i < toBePatched; i++) {
                  newIndexToOldIndexMap[i] = 0
                }

                for (i = s1; i <= e1; i++) {
                  var prevChild = c1[i]

                  if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true)
                    continue
                  }

                  var newIndex = void 0

                  if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key)
                  } else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                      if (
                        newIndexToOldIndexMap[j - s2] === 0 &&
                        isSameVNodeType(prevChild, c2[j])
                      ) {
                        newIndex = j
                        break
                      }
                    }
                  }

                  if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true)
                  } else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1

                    if (newIndex >= maxNewIndexSoFar) {
                      maxNewIndexSoFar = newIndex
                    } else {
                      moved = true
                    }

                    patch(
                      prevChild,
                      c2[newIndex],
                      container,
                      null,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                    patched++
                  }
                } // 5.3 move and mount
                // generate longest stable subsequence only when nodes have moved

                var increasingNewIndexSequence = moved
                  ? getSequence(newIndexToOldIndexMap)
                  : EMPTY_ARR
                j = increasingNewIndexSequence.length - 1 // looping backwards so that we can use last patched node as anchor

                for (i = toBePatched - 1; i >= 0; i--) {
                  var nextIndex = s2 + i
                  var _nextChild = c2[nextIndex]

                  var _anchor2 =
                    nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor

                  if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(
                      null,
                      _nextChild,
                      container,
                      _anchor2,
                      parentComponent,
                      parentSuspense,
                      isSVG
                    )
                  } else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                      move(
                        _nextChild,
                        container,
                        _anchor2,
                        2
                        /* REORDER */
                      )
                    } else {
                      j--
                    }
                  }
                }
              }
            }

            var move = function move(vnode, container, anchor, moveType) {
              var parentSuspense =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : null
              var el = vnode.el,
                type = vnode.type,
                transition = vnode.transition,
                children = vnode.children,
                shapeFlag = vnode.shapeFlag

              if (
                shapeFlag & 6
                /* COMPONENT */
              ) {
                move(vnode.component.subTree, container, anchor, moveType)
                return
              }

              if (
                shapeFlag & 128
                /* SUSPENSE */
              ) {
                vnode.suspense.move(container, anchor, moveType)
                return
              }

              if (
                shapeFlag & 64
                /* TELEPORT */
              ) {
                type.move(vnode, container, anchor, internals)
                return
              }

              if (type === Fragment) {
                hostInsert(el, container, anchor)

                for (var i = 0; i < children.length; i++) {
                  move(children[i], container, anchor, moveType)
                }

                hostInsert(vnode.anchor, container, anchor)
                return
              }

              if (type === Static) {
                moveStaticNode(vnode, container, anchor)
                return
              } // single nodes

              var needTransition =
                moveType !== 2 &&
                /* REORDER */
                shapeFlag & 1 &&
                /* ELEMENT */
                transition

              if (needTransition) {
                if (
                  moveType === 0
                  /* ENTER */
                ) {
                  transition.beforeEnter(el)
                  hostInsert(el, container, anchor)
                  queuePostRenderEffect(function() {
                    return transition.enter(el)
                  }, parentSuspense)
                } else {
                  var leave = transition.leave,
                    delayLeave = transition.delayLeave,
                    afterLeave = transition.afterLeave

                  var _remove = function _remove() {
                    return hostInsert(el, container, anchor)
                  }

                  var performLeave = function performLeave() {
                    leave(el, function() {
                      _remove()

                      afterLeave && afterLeave()
                    })
                  }

                  if (delayLeave) {
                    delayLeave(el, _remove, performLeave)
                  } else {
                    performLeave()
                  }
                }
              } else {
                hostInsert(el, container, anchor)
              }
            }

            var unmount = function unmount(
              vnode,
              parentComponent,
              parentSuspense
            ) {
              var doRemove =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false
              var optimized =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : false
              var type = vnode.type,
                props = vnode.props,
                ref = vnode.ref,
                children = vnode.children,
                dynamicChildren = vnode.dynamicChildren,
                shapeFlag = vnode.shapeFlag,
                patchFlag = vnode.patchFlag,
                dirs = vnode.dirs // unset ref

              if (ref != null) {
                setRef(ref, null, parentSuspense, null)
              }

              if (
                shapeFlag & 256
                /* COMPONENT_SHOULD_KEEP_ALIVE */
              ) {
                parentComponent.ctx.deactivate(vnode)
                return
              }

              var shouldInvokeDirs =
                shapeFlag & 1 &&
                /* ELEMENT */
                dirs
              var vnodeHook

              if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {
                invokeVNodeHook(vnodeHook, parentComponent, vnode)
              }

              if (
                shapeFlag & 6
                /* COMPONENT */
              ) {
                unmountComponent(vnode.component, parentSuspense, doRemove)
              } else {
                if (
                  shapeFlag & 128
                  /* SUSPENSE */
                ) {
                  vnode.suspense.unmount(parentSuspense, doRemove)
                  return
                }

                if (shouldInvokeDirs) {
                  invokeDirectiveHook(
                    vnode,
                    null,
                    parentComponent,
                    'beforeUnmount'
                  )
                }

                if (
                  dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
                  (type !== Fragment || (patchFlag > 0 && patchFlag & 64))
                  /* STABLE_FRAGMENT */
                ) {
                  // fast path for block nodes: only need to unmount dynamic children.
                  unmountChildren(
                    dynamicChildren,
                    parentComponent,
                    parentSuspense,
                    false,
                    true
                  )
                } else if (
                  (type === Fragment &&
                    (patchFlag & 128 ||
                      /* KEYED_FRAGMENT */
                      patchFlag & 256)) ||
                    /* UNKEYED_FRAGMENT */
                  (!optimized && shapeFlag & 16)
                  /* ARRAY_CHILDREN */
                ) {
                  unmountChildren(children, parentComponent, parentSuspense)
                } // an unmounted teleport should always remove its children if not disabled

                if (
                  shapeFlag & 64 &&
                  /* TELEPORT */
                  (doRemove || !isTeleportDisabled(vnode.props))
                ) {
                  vnode.type.remove(vnode, internals)
                }

                if (doRemove) {
                  remove(vnode)
                }
              }

              if (
                (vnodeHook = props && props.onVnodeUnmounted) ||
                shouldInvokeDirs
              ) {
                queuePostRenderEffect(function() {
                  vnodeHook &&
                    invokeVNodeHook(vnodeHook, parentComponent, vnode)
                  shouldInvokeDirs &&
                    invokeDirectiveHook(
                      vnode,
                      null,
                      parentComponent,
                      'unmounted'
                    )
                }, parentSuspense)
              }
            }

            var remove = function remove(vnode) {
              var type = vnode.type,
                el = vnode.el,
                anchor = vnode.anchor,
                transition = vnode.transition

              if (type === Fragment) {
                removeFragment(el, anchor)
                return
              }

              if (type === Static) {
                removeStaticNode(vnode)
                return
              }

              var performRemove = function performRemove() {
                hostRemove(el)

                if (
                  transition &&
                  !transition.persisted &&
                  transition.afterLeave
                ) {
                  transition.afterLeave()
                }
              }

              if (
                vnode.shapeFlag & 1 &&
                /* ELEMENT */
                transition &&
                !transition.persisted
              ) {
                var leave = transition.leave,
                  delayLeave = transition.delayLeave

                var performLeave = function performLeave() {
                  return leave(el, performRemove)
                }

                if (delayLeave) {
                  delayLeave(vnode.el, performRemove, performLeave)
                } else {
                  performLeave()
                }
              } else {
                performRemove()
              }
            }

            var removeFragment = function removeFragment(cur, end) {
              // For fragments, directly remove all contained DOM nodes.
              // (fragment child nodes cannot have transition)
              var next

              while (cur !== end) {
                next = hostNextSibling(cur)
                hostRemove(cur)
                cur = next
              }

              hostRemove(end)
            }

            var unmountComponent = function unmountComponent(
              instance,
              parentSuspense,
              doRemove
            ) {
              if (instance.type.__hmrId) {
                unregisterHMR(instance)
              }

              var bum = instance.bum,
                effects = instance.effects,
                update = instance.update,
                subTree = instance.subTree,
                um = instance.um // beforeUnmount hook

              if (bum) {
                invokeArrayFns(bum)
              }

              if (effects) {
                for (var i = 0; i < effects.length; i++) {
                  stop(effects[i])
                }
              } // update may be null if a component is unmounted before its async
              // setup has resolved.

              if (update) {
                stop(update)
                unmount(subTree, instance, parentSuspense, doRemove)
              } // unmounted hook

              if (um) {
                queuePostRenderEffect(um, parentSuspense)
              }

              queuePostRenderEffect(function() {
                instance.isUnmounted = true
              }, parentSuspense) // A component with async dep inside a pending suspense is unmounted before
              // its async dep resolves. This should remove the dep from the suspense, and
              // cause the suspense to resolve immediately if that was the last dep.

              if (
                parentSuspense &&
                parentSuspense.pendingBranch &&
                !parentSuspense.isUnmounted &&
                instance.asyncDep &&
                !instance.asyncResolved &&
                instance.suspenseId === parentSuspense.pendingId
              ) {
                parentSuspense.deps--

                if (parentSuspense.deps === 0) {
                  parentSuspense.resolve()
                }
              }

              {
                devtoolsComponentRemoved(instance)
              }
            }

            var unmountChildren = function unmountChildren(
              children,
              parentComponent,
              parentSuspense
            ) {
              var doRemove =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false
              var optimized =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : false
              var start =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : 0

              for (var i = start; i < children.length; i++) {
                unmount(
                  children[i],
                  parentComponent,
                  parentSuspense,
                  doRemove,
                  optimized
                )
              }
            }

            var getNextHostNode = function getNextHostNode(vnode) {
              if (
                vnode.shapeFlag & 6
                /* COMPONENT */
              ) {
                return getNextHostNode(vnode.component.subTree)
              }

              if (
                vnode.shapeFlag & 128
                /* SUSPENSE */
              ) {
                return vnode.suspense.next()
              }

              return hostNextSibling(vnode.anchor || vnode.el)
            }

            var render = function render(vnode, container) {
              if (vnode == null) {
                if (container._vnode) {
                  unmount(container._vnode, null, null, true)
                }
              } else {
                patch(container._vnode || null, vnode, container)
              }

              flushPostFlushCbs()
              container._vnode = vnode
            }

            var internals = {
              p: patch,
              um: unmount,
              m: move,
              r: remove,
              mt: mountComponent,
              mc: mountChildren,
              pc: patchChildren,
              pbc: patchBlockChildren,
              n: getNextHostNode,
              o: options
            }
            var hydrate
            var hydrateNode

            if (createHydrationFns) {
              var _createHydrationFns = createHydrationFns(internals)

              var _createHydrationFns2 = _slicedToArray(_createHydrationFns, 2)

              hydrate = _createHydrationFns2[0]
              hydrateNode = _createHydrationFns2[1]
            }

            return {
              render: render,
              hydrate: hydrate,
              createApp: createAppAPI(render, hydrate)
            }
          }

          function invokeVNodeHook(hook, instance, vnode) {
            var prevVNode =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : null
            callWithAsyncErrorHandling(
              hook,
              instance,
              7,
              /* VNODE_HOOK */
              [vnode, prevVNode]
            )
          }
          /**
           * #1156
           * When a component is HMR-enabled, we need to make sure that all static nodes
           * inside a block also inherit the DOM element from the previous tree so that
           * HMR updates (which are full updates) can retrieve the element for patching.
           *
           * #2080
           * Inside keyed `template` fragment static children, if a fragment is moved,
           * the children will always moved so that need inherit el form previous nodes
           * to ensure correct moved position.
           */

          function traverseStaticChildren(n1, n2) {
            var shallow =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : false
            var ch1 = n1.children
            var ch2 = n2.children

            if (isArray(ch1) && isArray(ch2)) {
              for (var i = 0; i < ch1.length; i++) {
                // this is only called in the optimized path so array children are
                // guaranteed to be vnodes
                var c1 = ch1[i]
                var c2 = ch2[i]

                if (
                  c2.shapeFlag & 1 &&
                  /* ELEMENT */
                  !c2.dynamicChildren
                ) {
                  if (
                    c2.patchFlag <= 0 ||
                    c2.patchFlag === 32
                    /* HYDRATE_EVENTS */
                  ) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i])
                    c2.el = c1.el
                  }

                  if (!shallow) traverseStaticChildren(c1, c2)
                } // also inherit for comment nodes, but not placeholders (e.g. v-if which
                // would have received .el during block patch)

                if (c2.type === Comment && !c2.el) {
                  c2.el = c1.el
                }
              }
            }
          } // https://en.wikipedia.org/wiki/Longest_increasing_subsequence

          function getSequence(arr) {
            var p = arr.slice()
            var result = [0]
            var i, j, u, v, c
            var len = arr.length

            for (i = 0; i < len; i++) {
              var arrI = arr[i]

              if (arrI !== 0) {
                j = result[result.length - 1]

                if (arr[j] < arrI) {
                  p[i] = j
                  result.push(i)
                  continue
                }

                u = 0
                v = result.length - 1

                while (u < v) {
                  c = ((u + v) / 2) | 0

                  if (arr[result[c]] < arrI) {
                    u = c + 1
                  } else {
                    v = c
                  }
                }

                if (arrI < arr[result[u]]) {
                  if (u > 0) {
                    p[i] = result[u - 1]
                  }

                  result[u] = i
                }
              }
            }

            u = result.length
            v = result[u - 1]

            while (u-- > 0) {
              result[u] = v
              v = p[v]
            }

            return result
          }

          var isTeleport = function isTeleport(type) {
            return type.__isTeleport
          }

          var isTeleportDisabled = function isTeleportDisabled(props) {
            return props && (props.disabled || props.disabled === '')
          }

          var isTargetSVG = function isTargetSVG(target) {
            return (
              typeof SVGElement !== 'undefined' && target instanceof SVGElement
            )
          }

          var resolveTarget = function resolveTarget(props, select) {
            var targetSelector = props && props.to

            if (isString(targetSelector)) {
              if (!select) {
                warn(
                  'Current renderer does not support string target for Teleports. ' +
                    '(missing querySelector renderer option)'
                )
                return null
              } else {
                var target = select(targetSelector)

                if (!target) {
                  warn(
                    'Failed to locate Teleport target with selector "'.concat(
                      targetSelector,
                      '". '
                    ) +
                      'Note the target element must exist before the component is mounted - ' +
                      'i.e. the target cannot be rendered by the component itself, and ' +
                      'ideally should be outside of the entire Vue component tree.'
                  )
                }

                return target
              }
            } else {
              if (!targetSelector && !isTeleportDisabled(props)) {
                warn('Invalid Teleport target: '.concat(targetSelector))
              }

              return targetSelector
            }
          }

          var TeleportImpl = {
            __isTeleport: true,
            process: function process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized,
              internals
            ) {
              var mountChildren = internals.mc,
                patchChildren = internals.pc,
                patchBlockChildren = internals.pbc,
                _internals$o = internals.o,
                insert = _internals$o.insert,
                querySelector = _internals$o.querySelector,
                createText = _internals$o.createText,
                createComment = _internals$o.createComment
              var disabled = isTeleportDisabled(n2.props)
              var shapeFlag = n2.shapeFlag,
                children = n2.children

              if (n1 == null) {
                // insert anchors in the main view
                var placeholder = (n2.el = createComment('teleport start'))
                var mainAnchor = (n2.anchor = createComment('teleport end'))
                insert(placeholder, container, anchor)
                insert(mainAnchor, container, anchor)
                var target = (n2.target = resolveTarget(
                  n2.props,
                  querySelector
                ))
                var targetAnchor = (n2.targetAnchor = createText(''))

                if (target) {
                  insert(targetAnchor, target) // #2652 we could be teleporting from a non-SVG tree into an SVG tree

                  isSVG = isSVG || isTargetSVG(target)
                } else if (!disabled) {
                  warn(
                    'Invalid Teleport target on mount:',
                    target,
                    '('.concat(_typeof(target), ')')
                  )
                }

                var mount = function mount(container, anchor) {
                  // Teleport *always* has Array children. This is enforced in both the
                  // compiler and vnode children normalization.
                  if (
                    shapeFlag & 16
                    /* ARRAY_CHILDREN */
                  ) {
                    mountChildren(
                      children,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  }
                }

                if (disabled) {
                  mount(container, mainAnchor)
                } else if (target) {
                  mount(target, targetAnchor)
                }
              } else {
                // update content
                n2.el = n1.el

                var _mainAnchor = (n2.anchor = n1.anchor)

                var _target = (n2.target = n1.target)

                var _targetAnchor = (n2.targetAnchor = n1.targetAnchor)

                var wasDisabled = isTeleportDisabled(n1.props)
                var currentContainer = wasDisabled ? container : _target
                var currentAnchor = wasDisabled ? _mainAnchor : _targetAnchor
                isSVG = isSVG || isTargetSVG(_target)

                if (n2.dynamicChildren) {
                  // fast path when the teleport happens to be a block root
                  patchBlockChildren(
                    n1.dynamicChildren,
                    n2.dynamicChildren,
                    currentContainer,
                    parentComponent,
                    parentSuspense,
                    isSVG
                  ) // even in block tree mode we need to make sure all root-level nodes
                  // in the teleport inherit previous DOM references so that they can
                  // be moved in future patches.

                  traverseStaticChildren(n1, n2, true)
                } else if (!optimized) {
                  patchChildren(
                    n1,
                    n2,
                    currentContainer,
                    currentAnchor,
                    parentComponent,
                    parentSuspense,
                    isSVG
                  )
                }

                if (disabled) {
                  if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(
                      n2,
                      container,
                      _mainAnchor,
                      internals,
                      1
                      /* TOGGLE */
                    )
                  }
                } else {
                  // target changed
                  if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    var nextTarget = (n2.target = resolveTarget(
                      n2.props,
                      querySelector
                    ))

                    if (nextTarget) {
                      moveTeleport(
                        n2,
                        nextTarget,
                        null,
                        internals,
                        0
                        /* TARGET_CHANGE */
                      )
                    } else {
                      warn(
                        'Invalid Teleport target on update:',
                        _target,
                        '('.concat(_typeof(_target), ')')
                      )
                    }
                  } else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(
                      n2,
                      _target,
                      _targetAnchor,
                      internals,
                      1
                      /* TOGGLE */
                    )
                  }
                }
              }
            },
            remove: function remove(vnode, _ref19) {
              var remove = _ref19.r,
                hostRemove = _ref19.o.remove
              var shapeFlag = vnode.shapeFlag,
                children = vnode.children,
                anchor = vnode.anchor
              hostRemove(anchor)

              if (
                shapeFlag & 16
                /* ARRAY_CHILDREN */
              ) {
                for (var i = 0; i < children.length; i++) {
                  remove(children[i])
                }
              }
            },
            move: moveTeleport,
            hydrate: hydrateTeleport
          }

          function moveTeleport(
            vnode,
            container,
            parentAnchor,
            _ref20
          ) /* REORDER */
          {
            var insert = _ref20.o.insert,
              move = _ref20.m
            var moveType =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : 2

            // move target anchor if this is a target change.
            if (
              moveType === 0
              /* TARGET_CHANGE */
            ) {
              insert(vnode.targetAnchor, container, parentAnchor)
            }

            var el = vnode.el,
              anchor = vnode.anchor,
              shapeFlag = vnode.shapeFlag,
              children = vnode.children,
              props = vnode.props
            var isReorder = moveType === 2
            /* REORDER */ // move main view anchor if this is a re-order.

            if (isReorder) {
              insert(el, container, parentAnchor)
            } // if this is a re-order and teleport is enabled (content is in target)
            // do not move children. So the opposite is: only move children if this
            // is not a reorder, or the teleport is disabled

            if (!isReorder || isTeleportDisabled(props)) {
              // Teleport has either Array children or no children.
              if (
                shapeFlag & 16
                /* ARRAY_CHILDREN */
              ) {
                for (var i = 0; i < children.length; i++) {
                  move(
                    children[i],
                    container,
                    parentAnchor,
                    2
                    /* REORDER */
                  )
                }
              }
            } // move main view anchor if this is a re-order.

            if (isReorder) {
              insert(anchor, container, parentAnchor)
            }
          }

          function hydrateTeleport(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            optimized,
            _ref21,
            hydrateChildren
          ) {
            var _ref21$o = _ref21.o,
              nextSibling = _ref21$o.nextSibling,
              parentNode = _ref21$o.parentNode,
              querySelector = _ref21$o.querySelector
            var target = (vnode.target = resolveTarget(
              vnode.props,
              querySelector
            ))

            if (target) {
              // if multiple teleports rendered to the same target element, we need to
              // pick up from where the last teleport finished instead of the first node
              var targetNode = target._lpa || target.firstChild

              if (
                vnode.shapeFlag & 16
                /* ARRAY_CHILDREN */
              ) {
                if (isTeleportDisabled(vnode.props)) {
                  vnode.anchor = hydrateChildren(
                    nextSibling(node),
                    vnode,
                    parentNode(node),
                    parentComponent,
                    parentSuspense,
                    optimized
                  )
                  vnode.targetAnchor = targetNode
                } else {
                  vnode.anchor = nextSibling(node)
                  vnode.targetAnchor = hydrateChildren(
                    targetNode,
                    vnode,
                    target,
                    parentComponent,
                    parentSuspense,
                    optimized
                  )
                }

                target._lpa =
                  vnode.targetAnchor && nextSibling(vnode.targetAnchor)
              }
            }

            return vnode.anchor && nextSibling(vnode.anchor)
          } // Force-casted public typing for h and TSX props inference

          var Teleport = TeleportImpl
          var COMPONENTS = 'components'
          var DIRECTIVES = 'directives'
          /**
           * @private
           */

          function resolveComponent(name) {
            return resolveAsset(COMPONENTS, name) || name
          }

          var NULL_DYNAMIC_COMPONENT = Symbol()
          /**
           * @private
           */

          function resolveDynamicComponent(component) {
            if (isString(component)) {
              return resolveAsset(COMPONENTS, component, false) || component
            } else {
              // invalid types will fallthrough to createVNode and raise warning
              return component || NULL_DYNAMIC_COMPONENT
            }
          }
          /**
           * @private
           */

          function resolveDirective(name) {
            return resolveAsset(DIRECTIVES, name)
          } // implementation

          function resolveAsset(type, name) {
            var warnMissing =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : true
            var instance = currentRenderingInstance || currentInstance

            if (instance) {
              var Component = instance.type // self name has highest priority

              if (type === COMPONENTS) {
                // special self referencing call generated by compiler
                // inferred from SFC filename
                if (name === '_self') {
                  return Component
                }

                var selfName = getComponentName(Component)

                if (
                  selfName &&
                  (selfName === name ||
                    selfName === camelize(name) ||
                    selfName === capitalize(camelize(name)))
                ) {
                  return Component
                }
              }

              var res = // local registration
                // check instance[type] first for components with mixin or extends.
                resolve(instance[type] || Component[type], name) || // global registration
                resolve(instance.appContext[type], name)

              if (warnMissing && !res) {
                warn(
                  'Failed to resolve '
                    .concat(type.slice(0, -1), ': ')
                    .concat(name)
                )
              }

              return res
            } else {
              warn(
                'resolve'.concat(capitalize(type.slice(0, -1)), ' ') +
                  'can only be used in render() or setup().'
              )
            }
          }

          function resolve(registry, name) {
            return (
              registry &&
              (registry[name] ||
                registry[camelize(name)] ||
                registry[capitalize(camelize(name))])
            )
          }

          var Fragment = Symbol('Fragment')
          var Text = Symbol('Text')
          var Comment = Symbol('Comment')
          var Static = Symbol('Static') // Since v-if and v-for are the two possible ways node structure can dynamically
          // change, once we consider v-if branches and each v-for fragment a block, we
          // can divide a template into nested blocks, and within each block the node
          // structure would be stable. This allows us to skip most children diffing
          // and only worry about the dynamic nodes (indicated by patch flags).

          var blockStack = []
          var currentBlock = null
          /**
           * Open a block.
           * This must be called before `createBlock`. It cannot be part of `createBlock`
           * because the children of the block are evaluated before `createBlock` itself
           * is called. The generated code typically looks like this:
           *
           * ```js
           * function render() {
           *   return (openBlock(),createBlock('div', null, [...]))
           * }
           * ```
           * disableTracking is true when creating a v-for fragment block, since a v-for
           * fragment always diffs its children.
           *
           * @private
           */

          function openBlock() {
            var disableTracking =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : false
            blockStack.push((currentBlock = disableTracking ? null : []))
          }

          function closeBlock() {
            blockStack.pop()
            currentBlock = blockStack[blockStack.length - 1] || null
          } // Whether we should be tracking dynamic child nodes inside a block.
          // Only tracks when this value is > 0
          // We are not using a simple boolean because this value may need to be
          // incremented/decremented by nested usage of v-once (see below)

          var shouldTrack$1 = 1
          /**
           * Block tracking sometimes needs to be disabled, for example during the
           * creation of a tree that needs to be cached by v-once. The compiler generates
           * code like this:
           *
           * ``` js
           * _cache[1] || (
           *   setBlockTracking(-1),
           *   _cache[1] = createVNode(...),
           *   setBlockTracking(1),
           *   _cache[1]
           * )
           * ```
           *
           * @private
           */

          function setBlockTracking(value) {
            shouldTrack$1 += value
          }
          /**
           * Create a block root vnode. Takes the same exact arguments as `createVNode`.
           * A block root keeps track of dynamic nodes within the block in the
           * `dynamicChildren` array.
           *
           * @private
           */

          function createBlock(type, props, children, patchFlag, dynamicProps) {
            var vnode = createVNode(
              type,
              props,
              children,
              patchFlag,
              dynamicProps,
              true
              /* isBlock: prevent a block from tracking itself */
            ) // save current block children on the block vnode

            vnode.dynamicChildren = currentBlock || EMPTY_ARR // close block

            closeBlock() // a block is always going to be patched, so track it as a child of its
            // parent block

            if (shouldTrack$1 > 0 && currentBlock) {
              currentBlock.push(vnode)
            }

            return vnode
          }

          function isVNode(value) {
            return value ? value.__v_isVNode === true : false
          }

          function isSameVNodeType(n1, n2) {
            if (
              n2.shapeFlag & 6 &&
              /* COMPONENT */
              hmrDirtyComponents.has(n2.type)
            ) {
              // HMR only: if the component has been hot-updated, force a reload.
              return false
            }

            return n1.type === n2.type && n1.key === n2.key
          }

          var vnodeArgsTransformer
          /**
           * Internal API for registering an arguments transform for createVNode
           * used for creating stubs in the test-utils
           * It is *internal* but needs to be exposed for test-utils to pick up proper
           * typings
           */

          function transformVNodeArgs(transformer) {
            vnodeArgsTransformer = transformer
          }

          var createVNodeWithArgsTransform = function createVNodeWithArgsTransform() {
            for (
              var _len8 = arguments.length, args = new Array(_len8), _key13 = 0;
              _key13 < _len8;
              _key13++
            ) {
              args[_key13] = arguments[_key13]
            }

            return _createVNode.apply(
              void 0,
              _toConsumableArray(
                vnodeArgsTransformer
                  ? vnodeArgsTransformer(args, currentRenderingInstance)
                  : args
              )
            )
          }

          var InternalObjectKey = '__vInternal'

          var normalizeKey = function normalizeKey(_ref22) {
            var key = _ref22.key
            return key != null ? key : null
          }

          var normalizeRef = function normalizeRef(_ref23) {
            var ref = _ref23.ref
            return ref != null
              ? isString(ref) || isRef(ref) || isFunction(ref)
                ? {
                    i: currentRenderingInstance,
                    r: ref
                  }
                : ref
              : null
          }

          var createVNode = createVNodeWithArgsTransform

          function _createVNode(type) {
            var _vnode

            var props =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : null
            var children =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : null
            var patchFlag =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : 0
            var dynamicProps =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : null
            var isBlockNode =
              arguments.length > 5 && arguments[5] !== undefined
                ? arguments[5]
                : false

            if (!type || type === NULL_DYNAMIC_COMPONENT) {
              if (!type) {
                warn(
                  'Invalid vnode type when creating vnode: '.concat(type, '.')
                )
              }

              type = Comment
            }

            if (isVNode(type)) {
              // createVNode receiving an existing vnode. This happens in cases like
              // <component :is="vnode"/>
              // #2078 make sure to merge refs during the clone instead of overwriting it
              var cloned = cloneVNode(
                type,
                props,
                true
                /* mergeRef: true */
              )

              if (children) {
                normalizeChildren(cloned, children)
              }

              return cloned
            } // class component normalization.

            if (isClassComponent(type)) {
              type = type.__vccOpts
            } // class & style normalization.

            if (props) {
              // for reactive or proxy objects, we need to clone it to enable mutation.
              if (isProxy(props) || InternalObjectKey in props) {
                props = extend({}, props)
              }

              var _props = props,
                klass = _props['class'],
                style = _props.style

              if (klass && !isString(klass)) {
                props['class'] = normalizeClass(klass)
              }

              if (isObject(style)) {
                // reactive state objects need to be cloned since they are likely to be
                // mutated
                if (isProxy(style) && !isArray(style)) {
                  style = extend({}, style)
                }

                props.style = normalizeStyle(style)
              }
            } // encode the vnode type information into a bitmap

            var shapeFlag = isString(type)
              ? 1
              : /* ELEMENT */
                isSuspense(type)
                ? 128
                : /* SUSPENSE */
                  isTeleport(type)
                  ? 64
                  : /* TELEPORT */
                    isObject(type)
                    ? 4
                    : /* STATEFUL_COMPONENT */
                      isFunction(type)
                      ? 2
                      : /* FUNCTIONAL_COMPONENT */
                        0

            if (
              shapeFlag & 4 &&
              /* STATEFUL_COMPONENT */
              isProxy(type)
            ) {
              type = toRaw(type)
              warn(
                'Vue received a Component which was made a reactive object. This can ' +
                  'lead to unnecessary performance overhead, and should be avoided by ' +
                  'marking the component with `markRaw` or using `shallowRef` ' +
                  'instead of `ref`.',
                '\nComponent that was made reactive: ',
                type
              )
            }

            var vnode = ((_vnode = {
              __v_isVNode: true
            }),
            _defineProperty(
              _vnode,
              '__v_skip',
              /* SKIP */
              true
            ),
            _defineProperty(_vnode, 'type', type),
            _defineProperty(_vnode, 'props', props),
            _defineProperty(_vnode, 'key', props && normalizeKey(props)),
            _defineProperty(_vnode, 'ref', props && normalizeRef(props)),
            _defineProperty(_vnode, 'scopeId', currentScopeId),
            _defineProperty(_vnode, 'children', null),
            _defineProperty(_vnode, 'component', null),
            _defineProperty(_vnode, 'suspense', null),
            _defineProperty(_vnode, 'ssContent', null),
            _defineProperty(_vnode, 'ssFallback', null),
            _defineProperty(_vnode, 'dirs', null),
            _defineProperty(_vnode, 'transition', null),
            _defineProperty(_vnode, 'el', null),
            _defineProperty(_vnode, 'anchor', null),
            _defineProperty(_vnode, 'target', null),
            _defineProperty(_vnode, 'targetAnchor', null),
            _defineProperty(_vnode, 'staticCount', 0),
            _defineProperty(_vnode, 'shapeFlag', shapeFlag),
            _defineProperty(_vnode, 'patchFlag', patchFlag),
            _defineProperty(_vnode, 'dynamicProps', dynamicProps),
            _defineProperty(_vnode, 'dynamicChildren', null),
            _defineProperty(_vnode, 'appContext', null),
            _vnode) // validate key

            if (vnode.key !== vnode.key) {
              warn(
                'VNode created with invalid key (NaN). VNode type:',
                vnode.type
              )
            }

            normalizeChildren(vnode, children) // normalize suspense children

            if (
              shapeFlag & 128
              /* SUSPENSE */
            ) {
              var _normalizeSuspenseChi = normalizeSuspenseChildren(vnode),
                content = _normalizeSuspenseChi.content,
                fallback = _normalizeSuspenseChi.fallback

              vnode.ssContent = content
              vnode.ssFallback = fallback
            }

            if (
              shouldTrack$1 > 0 && // avoid a block node from tracking itself
              !isBlockNode && // has current parent block
              currentBlock && // presence of a patch flag indicates this node needs patching on updates.
              // component nodes also should always be patched, because even if the
              // component doesn't need to update, it needs to persist the instance on to
              // the next vnode so that it can be properly unmounted later.
              (patchFlag > 0 || shapeFlag & 6) &&
              /* COMPONENT */ // the EVENTS flag is only for hydration and if it is the only flag, the
              // vnode should not be considered dynamic due to handler caching.
              patchFlag !== 32
              /* HYDRATE_EVENTS */
            ) {
              currentBlock.push(vnode)
            }

            return vnode
          }

          function cloneVNode(vnode, extraProps) {
            var _ref24

            var mergeRef =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : false
            // This is intentionally NOT using spread or extend to avoid the runtime
            // key enumeration cost.
            var props = vnode.props,
              ref = vnode.ref,
              patchFlag = vnode.patchFlag,
              children = vnode.children
            var mergedProps = extraProps
              ? mergeProps(props || {}, extraProps)
              : props
            return (
              (_ref24 = {
                __v_isVNode: true
              }),
              _defineProperty(
                _ref24,
                '__v_skip',
                /* SKIP */
                true
              ),
              _defineProperty(_ref24, 'type', vnode.type),
              _defineProperty(_ref24, 'props', mergedProps),
              _defineProperty(
                _ref24,
                'key',
                mergedProps && normalizeKey(mergedProps)
              ),
              _defineProperty(
                _ref24,
                'ref',
                extraProps && extraProps.ref // #2078 in the case of <component :is="vnode" ref="extra"/>
                  ? // if the vnode itself already has a ref, cloneVNode will need to merge
                    // the refs so the single vnode can be set on multiple refs
                    mergeRef && ref
                    ? isArray(ref)
                      ? ref.concat(normalizeRef(extraProps))
                      : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
                  : ref
              ),
              _defineProperty(_ref24, 'scopeId', vnode.scopeId),
              _defineProperty(
                _ref24,
                'children',
                patchFlag === -1 &&
                /* HOISTED */
                isArray(children)
                  ? children.map(deepCloneVNode)
                  : children
              ),
              _defineProperty(_ref24, 'target', vnode.target),
              _defineProperty(_ref24, 'targetAnchor', vnode.targetAnchor),
              _defineProperty(_ref24, 'staticCount', vnode.staticCount),
              _defineProperty(_ref24, 'shapeFlag', vnode.shapeFlag),
              _defineProperty(
                _ref24,
                'patchFlag',
                extraProps && vnode.type !== Fragment
                  ? patchFlag === -1 // hoisted node
                    ? 16
                    : /* FULL_PROPS */
                      patchFlag | 16
                  : /* FULL_PROPS */
                    patchFlag
              ),
              _defineProperty(_ref24, 'dynamicProps', vnode.dynamicProps),
              _defineProperty(_ref24, 'dynamicChildren', vnode.dynamicChildren),
              _defineProperty(_ref24, 'appContext', vnode.appContext),
              _defineProperty(_ref24, 'dirs', vnode.dirs),
              _defineProperty(_ref24, 'transition', vnode.transition),
              _defineProperty(_ref24, 'component', vnode.component),
              _defineProperty(_ref24, 'suspense', vnode.suspense),
              _defineProperty(
                _ref24,
                'ssContent',
                vnode.ssContent && cloneVNode(vnode.ssContent)
              ),
              _defineProperty(
                _ref24,
                'ssFallback',
                vnode.ssFallback && cloneVNode(vnode.ssFallback)
              ),
              _defineProperty(_ref24, 'el', vnode.el),
              _defineProperty(_ref24, 'anchor', vnode.anchor),
              _ref24
            )
          }
          /**
           * Dev only, for HMR of hoisted vnodes reused in v-for
           * https://github.com/vitejs/vite/issues/2022
           */

          function deepCloneVNode(vnode) {
            var cloned = cloneVNode(vnode)

            if (isArray(vnode.children)) {
              cloned.children = vnode.children.map(deepCloneVNode)
            }

            return cloned
          }
          /**
           * @private
           */

          function createTextVNode() {
            var text =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : ' '
            var flag =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : 0
            return createVNode(Text, null, text, flag)
          }
          /**
           * @private
           */

          function createStaticVNode(content, numberOfNodes) {
            // A static vnode can contain multiple stringified elements, and the number
            // of elements is necessary for hydration.
            var vnode = createVNode(Static, null, content)
            vnode.staticCount = numberOfNodes
            return vnode
          }
          /**
           * @private
           */

          function createCommentVNode() {
            var text =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : ''
            var asBlock =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false
            return asBlock
              ? (openBlock(), createBlock(Comment, null, text))
              : createVNode(Comment, null, text)
          }

          function normalizeVNode(child) {
            if (child == null || typeof child === 'boolean') {
              // empty placeholder
              return createVNode(Comment)
            } else if (isArray(child)) {
              // fragment
              return createVNode(Fragment, null, child)
            } else if (_typeof(child) === 'object') {
              // already vnode, this should be the most common since compiled templates
              // always produce all-vnode children arrays
              return child.el === null ? child : cloneVNode(child)
            } else {
              // strings and numbers
              return createVNode(Text, null, String(child))
            }
          } // optimized normalization for template-compiled render fns

          function cloneIfMounted(child) {
            return child.el === null ? child : cloneVNode(child)
          }

          function normalizeChildren(vnode, children) {
            var type = 0
            var shapeFlag = vnode.shapeFlag

            if (children == null) {
              children = null
            } else if (isArray(children)) {
              type = 16
              /* ARRAY_CHILDREN */
            } else if (_typeof(children) === 'object') {
              if (
                shapeFlag & 1 ||
                /* ELEMENT */
                shapeFlag & 64
                /* TELEPORT */
              ) {
                // Normalize slot to plain children for plain element and Teleport
                var slot = children['default']

                if (slot) {
                  // _c marker is added by withCtx() indicating this is a compiled slot
                  slot._c && setCompiledSlotRendering(1)
                  normalizeChildren(vnode, slot())
                  slot._c && setCompiledSlotRendering(-1)
                }

                return
              } else {
                type = 32
                /* SLOTS_CHILDREN */
                var slotFlag = children._

                if (!slotFlag && !(InternalObjectKey in children)) {
                  children._ctx = currentRenderingInstance
                } else if (
                  slotFlag === 3 &&
                  /* FORWARDED */
                  currentRenderingInstance
                ) {
                  // a child component receives forwarded slots from the parent.
                  // its slot type is determined by its parent's slot type.
                  if (
                    currentRenderingInstance.vnode.patchFlag & 1024
                    /* DYNAMIC_SLOTS */
                  ) {
                    children._ = 2
                    /* DYNAMIC */
                    vnode.patchFlag |= 1024
                    /* DYNAMIC_SLOTS */
                  } else {
                    children._ = 1
                    /* STABLE */
                  }
                }
              }
            } else if (isFunction(children)) {
              children = {
                default: children,
                _ctx: currentRenderingInstance
              }
              type = 32
              /* SLOTS_CHILDREN */
            } else {
              children = String(children) // force teleport children to array so it can be moved around

              if (
                shapeFlag & 64
                /* TELEPORT */
              ) {
                type = 16
                /* ARRAY_CHILDREN */
                children = [createTextVNode(children)]
              } else {
                type = 8
                /* TEXT_CHILDREN */
              }
            }

            vnode.children = children
            vnode.shapeFlag |= type
          }

          function mergeProps() {
            var ret = extend(
              {},
              arguments.length <= 0 ? undefined : arguments[0]
            )

            for (var i = 1; i < arguments.length; i++) {
              var toMerge =
                i < 0 || arguments.length <= i ? undefined : arguments[i]

              for (var key in toMerge) {
                if (key === 'class') {
                  if (ret['class'] !== toMerge['class']) {
                    ret['class'] = normalizeClass([
                      ret['class'],
                      toMerge['class']
                    ])
                  }
                } else if (key === 'style') {
                  ret.style = normalizeStyle([ret.style, toMerge.style])
                } else if (isOn(key)) {
                  var existing = ret[key]
                  var incoming = toMerge[key]

                  if (existing !== incoming) {
                    ret[key] = existing
                      ? [].concat(existing, toMerge[key])
                      : incoming
                  }
                } else if (key !== '') {
                  ret[key] = toMerge[key]
                }
              }
            }

            return ret
          }

          function provide(key, value) {
            if (!currentInstance) {
              {
                warn('provide() can only be used inside setup().')
              }
            } else {
              var provides = currentInstance.provides // by default an instance inherits its parent's provides object
              // but when it needs to provide values of its own, it creates its
              // own provides object using parent provides object as prototype.
              // this way in `inject` we can simply look up injections from direct
              // parent and let the prototype chain do the work.

              var parentProvides =
                currentInstance.parent && currentInstance.parent.provides

              if (parentProvides === provides) {
                provides = currentInstance.provides = Object.create(
                  parentProvides
                )
              } // TS doesn't allow symbol as index type

              provides[key] = value
            }
          }

          function inject(key, defaultValue) {
            var treatDefaultAsFactory =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : false
            // fallback to `currentRenderingInstance` so that this can be called in
            // a functional component
            var instance = currentInstance || currentRenderingInstance

            if (instance) {
              // #2400
              // to support `app.use` plugins,
              // fallback to appContext's `provides` if the intance is at root
              var provides =
                instance.parent == null
                  ? instance.vnode.appContext &&
                    instance.vnode.appContext.provides
                  : instance.parent.provides

              if (provides && key in provides) {
                // TS doesn't allow symbol as index type
                return provides[key]
              } else if (arguments.length > 1) {
                return treatDefaultAsFactory && isFunction(defaultValue)
                  ? defaultValue()
                  : defaultValue
              } else {
                warn('injection "'.concat(String(key), '" not found.'))
              }
            } else {
              warn(
                'inject() can only be used inside setup() or functional components.'
              )
            }
          }

          function createDuplicateChecker() {
            var cache = Object.create(null)
            return function(type, key) {
              if (cache[key]) {
                warn(
                  ''
                    .concat(type, ' property "')
                    .concat(key, '" is already defined in ')
                    .concat(cache[key], '.')
                )
              } else {
                cache[key] = type
              }
            }
          }

          var isInBeforeCreate = false

          function applyOptions(instance, options) {
            var deferredData =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : []
            var deferredWatch =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : []
            var deferredProvide =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : []
            var asMixin =
              arguments.length > 5 && arguments[5] !== undefined
                ? arguments[5]
                : false
            var mixins = options.mixins,
              extendsOptions = options['extends'],
              dataOptions = options.data,
              computedOptions = options.computed,
              methods = options.methods,
              watchOptions = options.watch,
              provideOptions = options.provide,
              injectOptions = options.inject,
              components = options.components,
              directives = options.directives,
              beforeMount = options.beforeMount,
              mounted = options.mounted,
              beforeUpdate = options.beforeUpdate,
              updated = options.updated,
              activated = options.activated,
              deactivated = options.deactivated,
              beforeDestroy = options.beforeDestroy,
              beforeUnmount = options.beforeUnmount,
              destroyed = options.destroyed,
              unmounted = options.unmounted,
              render = options.render,
              renderTracked = options.renderTracked,
              renderTriggered = options.renderTriggered,
              errorCaptured = options.errorCaptured,
              expose = options.expose
            var publicThis = instance.proxy
            var ctx = instance.ctx
            var globalMixins = instance.appContext.mixins

            if (asMixin && render && instance.render === NOOP) {
              instance.render = render
            } // applyOptions is called non-as-mixin once per instance

            if (!asMixin) {
              isInBeforeCreate = true
              callSyncHook(
                'beforeCreate',
                'bc',
                /* BEFORE_CREATE */
                options,
                instance,
                globalMixins
              )
              isInBeforeCreate = false // global mixins are applied first

              applyMixins(
                instance,
                globalMixins,
                deferredData,
                deferredWatch,
                deferredProvide
              )
            } // extending a base component...

            if (extendsOptions) {
              applyOptions(
                instance,
                extendsOptions,
                deferredData,
                deferredWatch,
                deferredProvide,
                true
              )
            } // local mixins

            if (mixins) {
              applyMixins(
                instance,
                mixins,
                deferredData,
                deferredWatch,
                deferredProvide
              )
            }

            var checkDuplicateProperties = createDuplicateChecker()
            {
              var _instance$propsOption5 = _slicedToArray(
                  instance.propsOptions,
                  1
                ),
                propsOptions = _instance$propsOption5[0]

              if (propsOptions) {
                for (var key in propsOptions) {
                  checkDuplicateProperties(
                    'Props',
                    /* PROPS */
                    key
                  )
                }
              }
            } // options initialization order (to be consistent with Vue 2):
            // - props (already done outside of this function)
            // - inject
            // - methods
            // - data (deferred since it relies on `this` access)
            // - computed
            // - watch (deferred since it relies on `this` access)

            if (injectOptions) {
              if (isArray(injectOptions)) {
                for (var i = 0; i < injectOptions.length; i++) {
                  var _key14 = injectOptions[i]
                  ctx[_key14] = inject(_key14)
                  {
                    checkDuplicateProperties(
                      'Inject',
                      /* INJECT */
                      _key14
                    )
                  }
                }
              } else {
                for (var _key15 in injectOptions) {
                  var opt = injectOptions[_key15]

                  if (isObject(opt)) {
                    ctx[_key15] = inject(
                      opt.from || _key15,
                      opt['default'],
                      true
                      /* treat default function as factory */
                    )
                  } else {
                    ctx[_key15] = inject(opt)
                  }

                  {
                    checkDuplicateProperties(
                      'Inject',
                      /* INJECT */
                      _key15
                    )
                  }
                }
              }
            }

            if (methods) {
              for (var _key16 in methods) {
                var methodHandler = methods[_key16]

                if (isFunction(methodHandler)) {
                  // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,
                  // and those are read-only but reconfigurable, so it needs to be redefined here
                  {
                    Object.defineProperty(ctx, _key16, {
                      value: methodHandler.bind(publicThis),
                      configurable: true,
                      enumerable: false
                    })
                  }
                  {
                    checkDuplicateProperties(
                      'Methods',
                      /* METHODS */
                      _key16
                    )
                  }
                } else {
                  warn(
                    'Method "'
                      .concat(_key16, '" has type "')
                      .concat(
                        _typeof(methodHandler),
                        '" in the component definition. '
                      ) + 'Did you reference the function correctly?'
                  )
                }
              }
            }

            if (!asMixin) {
              if (deferredData.length) {
                deferredData.forEach(function(dataFn) {
                  return resolveData(instance, dataFn, publicThis)
                })
              }

              if (dataOptions) {
                // @ts-ignore dataOptions is not fully type safe
                resolveData(instance, dataOptions, publicThis)
              }

              {
                ;(function() {
                  var rawData = toRaw(instance.data)

                  var _loop = function _loop(_key17) {
                    checkDuplicateProperties(
                      'Data',
                      /* DATA */
                      _key17
                    ) // expose data on ctx during dev

                    if (_key17[0] !== '$' && _key17[0] !== '_') {
                      Object.defineProperty(ctx, _key17, {
                        configurable: true,
                        enumerable: true,
                        get: function get() {
                          return rawData[_key17]
                        },
                        set: NOOP
                      })
                    }
                  }

                  for (var _key17 in rawData) {
                    _loop(_key17)
                  }
                })()
              }
            } else if (dataOptions) {
              deferredData.push(dataOptions)
            }

            if (computedOptions) {
              var _loop2 = function _loop2(_key18) {
                var opt = computedOptions[_key18]
                var get = isFunction(opt)
                  ? opt.bind(publicThis, publicThis)
                  : isFunction(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : NOOP

                if (get === NOOP) {
                  warn('Computed property "'.concat(_key18, '" has no getter.'))
                }

                var set =
                  !isFunction(opt) && isFunction(opt.set)
                    ? opt.set.bind(publicThis)
                    : function() {
                        warn(
                          'Write operation failed: computed property "'.concat(
                            _key18,
                            '" is readonly.'
                          )
                        )
                      }
                var c = computed$1({
                  get: get,
                  set: set
                })
                Object.defineProperty(ctx, _key18, {
                  enumerable: true,
                  configurable: true,
                  get: function get() {
                    return c.value
                  },
                  set: function set(v) {
                    return (c.value = v)
                  }
                })
                {
                  checkDuplicateProperties(
                    'Computed',
                    /* COMPUTED */
                    _key18
                  )
                }
              }

              for (var _key18 in computedOptions) {
                _loop2(_key18)
              }
            }

            if (watchOptions) {
              deferredWatch.push(watchOptions)
            }

            if (!asMixin && deferredWatch.length) {
              deferredWatch.forEach(function(watchOptions) {
                for (var _key19 in watchOptions) {
                  createWatcher(watchOptions[_key19], ctx, publicThis, _key19)
                }
              })
            }

            if (provideOptions) {
              deferredProvide.push(provideOptions)
            }

            if (!asMixin && deferredProvide.length) {
              deferredProvide.forEach(function(provideOptions) {
                var provides = isFunction(provideOptions)
                  ? provideOptions.call(publicThis)
                  : provideOptions
                Reflect.ownKeys(provides).forEach(function(key) {
                  provide(key, provides[key])
                })
              })
            } // asset options.
            // To reduce memory usage, only components with mixins or extends will have
            // resolved asset registry attached to instance.

            if (asMixin) {
              if (components) {
                extend(
                  instance.components ||
                    (instance.components = extend(
                      {},
                      instance.type.components
                    )),
                  components
                )
              }

              if (directives) {
                extend(
                  instance.directives ||
                    (instance.directives = extend(
                      {},
                      instance.type.directives
                    )),
                  directives
                )
              }
            } // lifecycle options

            if (!asMixin) {
              callSyncHook(
                'created',
                'c',
                /* CREATED */
                options,
                instance,
                globalMixins
              )
            }

            if (beforeMount) {
              onBeforeMount(beforeMount.bind(publicThis))
            }

            if (mounted) {
              onMounted(mounted.bind(publicThis))
            }

            if (beforeUpdate) {
              onBeforeUpdate(beforeUpdate.bind(publicThis))
            }

            if (updated) {
              onUpdated(updated.bind(publicThis))
            }

            if (activated) {
              onActivated(activated.bind(publicThis))
            }

            if (deactivated) {
              onDeactivated(deactivated.bind(publicThis))
            }

            if (errorCaptured) {
              onErrorCaptured(errorCaptured.bind(publicThis))
            }

            if (renderTracked) {
              onRenderTracked(renderTracked.bind(publicThis))
            }

            if (renderTriggered) {
              onRenderTriggered(renderTriggered.bind(publicThis))
            }

            if (beforeDestroy) {
              warn('`beforeDestroy` has been renamed to `beforeUnmount`.')
            }

            if (beforeUnmount) {
              onBeforeUnmount(beforeUnmount.bind(publicThis))
            }

            if (destroyed) {
              warn('`destroyed` has been renamed to `unmounted`.')
            }

            if (unmounted) {
              onUnmounted(unmounted.bind(publicThis))
            }

            if (isArray(expose)) {
              if (!asMixin) {
                if (expose.length) {
                  var exposed =
                    instance.exposed || (instance.exposed = proxyRefs({}))
                  expose.forEach(function(key) {
                    exposed[key] = toRef(publicThis, key)
                  })
                } else if (!instance.exposed) {
                  instance.exposed = EMPTY_OBJ
                }
              } else {
                warn('The `expose` option is ignored when used in mixins.')
              }
            }
          }

          function callSyncHook(name, type, options, instance, globalMixins) {
            callHookFromMixins(name, type, globalMixins, instance)
            var base = options['extends'],
              mixins = options.mixins

            if (base) {
              callHookFromExtends(name, type, base, instance)
            }

            if (mixins) {
              callHookFromMixins(name, type, mixins, instance)
            }

            var selfHook = options[name]

            if (selfHook) {
              callWithAsyncErrorHandling(
                selfHook.bind(instance.proxy),
                instance,
                type
              )
            }
          }

          function callHookFromExtends(name, type, base, instance) {
            if (base['extends']) {
              callHookFromExtends(name, type, base['extends'], instance)
            }

            var baseHook = base[name]

            if (baseHook) {
              callWithAsyncErrorHandling(
                baseHook.bind(instance.proxy),
                instance,
                type
              )
            }
          }

          function callHookFromMixins(name, type, mixins, instance) {
            for (var i = 0; i < mixins.length; i++) {
              var chainedMixins = mixins[i].mixins

              if (chainedMixins) {
                callHookFromMixins(name, type, chainedMixins, instance)
              }

              var fn = mixins[i][name]

              if (fn) {
                callWithAsyncErrorHandling(
                  fn.bind(instance.proxy),
                  instance,
                  type
                )
              }
            }
          }

          function applyMixins(
            instance,
            mixins,
            deferredData,
            deferredWatch,
            deferredProvide
          ) {
            for (var i = 0; i < mixins.length; i++) {
              applyOptions(
                instance,
                mixins[i],
                deferredData,
                deferredWatch,
                deferredProvide,
                true
              )
            }
          }

          function resolveData(instance, dataFn, publicThis) {
            if (!isFunction(dataFn)) {
              warn(
                'The data option must be a function. ' +
                  'Plain object usage is no longer supported.'
              )
            }

            var data = dataFn.call(publicThis, publicThis)

            if (isPromise(data)) {
              warn(
                'data() returned a Promise - note data() cannot be async; If you ' +
                  'intend to perform data fetching before component renders, use ' +
                  'async setup() + <Suspense>.'
              )
            }

            if (!isObject(data)) {
              warn('data() should return an object.')
            } else if (instance.data === EMPTY_OBJ) {
              instance.data = reactive(data)
            } else {
              // existing data: this is a mixin or extends.
              extend(instance.data, data)
            }
          }

          function createWatcher(raw, ctx, publicThis, key) {
            var getter = key.includes('.')
              ? createPathGetter(publicThis, key)
              : function() {
                  return publicThis[key]
                }

            if (isString(raw)) {
              var handler = ctx[raw]

              if (isFunction(handler)) {
                watch(getter, handler)
              } else {
                warn(
                  'Invalid watch handler specified by key "'.concat(raw, '"'),
                  handler
                )
              }
            } else if (isFunction(raw)) {
              watch(getter, raw.bind(publicThis))
            } else if (isObject(raw)) {
              if (isArray(raw)) {
                raw.forEach(function(r) {
                  return createWatcher(r, ctx, publicThis, key)
                })
              } else {
                var _handler = isFunction(raw.handler)
                  ? raw.handler.bind(publicThis)
                  : ctx[raw.handler]

                if (isFunction(_handler)) {
                  watch(getter, _handler, raw)
                } else {
                  warn(
                    'Invalid watch handler specified by key "'.concat(
                      raw.handler,
                      '"'
                    ),
                    _handler
                  )
                }
              }
            } else {
              warn('Invalid watch option: "'.concat(key, '"'), raw)
            }
          }

          function createPathGetter(ctx, path) {
            var segments = path.split('.')
            return function() {
              var cur = ctx

              for (var i = 0; i < segments.length && cur; i++) {
                cur = cur[segments[i]]
              }

              return cur
            }
          }

          function resolveMergedOptions(instance) {
            var raw = instance.type
            var __merged = raw.__merged,
              mixins = raw.mixins,
              extendsOptions = raw['extends']
            if (__merged) return __merged
            var globalMixins = instance.appContext.mixins
            if (!globalMixins.length && !mixins && !extendsOptions) return raw
            var options = {}
            globalMixins.forEach(function(m) {
              return mergeOptions(options, m, instance)
            })
            mergeOptions(options, raw, instance)
            return (raw.__merged = options)
          }

          function mergeOptions(to, from, instance) {
            var strats = instance.appContext.config.optionMergeStrategies
            var mixins = from.mixins,
              extendsOptions = from['extends']
            extendsOptions && mergeOptions(to, extendsOptions, instance)
            mixins &&
              mixins.forEach(function(m) {
                return mergeOptions(to, m, instance)
              })

            for (var key in from) {
              if (strats && hasOwn(strats, key)) {
                to[key] = strats[key](to[key], from[key], instance.proxy, key)
              } else {
                to[key] = from[key]
              }
            }
          }
          /**
           * #2437 In Vue 3, functional components do not have a public instance proxy but
           * they exist in the internal parent chain. For code that relies on traversing
           * public $parent chains, skip functional ones and go to the parent instead.
           */

          var getPublicInstance = function getPublicInstance(i) {
            if (!i) return null
            if (isStatefulComponent(i)) return i.exposed ? i.exposed : i.proxy
            return getPublicInstance(i.parent)
          }

          var publicPropertiesMap = extend(Object.create(null), {
            $: function $(i) {
              return i
            },
            $el: function $el(i) {
              return i.vnode.el
            },
            $data: function $data(i) {
              return i.data
            },
            $props: function $props(i) {
              return shallowReadonly(i.props)
            },
            $attrs: function $attrs(i) {
              return shallowReadonly(i.attrs)
            },
            $slots: function $slots(i) {
              return shallowReadonly(i.slots)
            },
            $refs: function $refs(i) {
              return shallowReadonly(i.refs)
            },
            $parent: function $parent(i) {
              return getPublicInstance(i.parent)
            },
            $root: function $root(i) {
              return getPublicInstance(i.root)
            },
            $emit: function $emit(i) {
              return i.emit
            },
            $options: function $options(i) {
              return resolveMergedOptions(i)
            },
            $forceUpdate: function $forceUpdate(i) {
              return function() {
                return queueJob(i.update)
              }
            },
            $nextTick: function $nextTick(i) {
              return nextTick.bind(i.proxy)
            },
            $watch: function $watch(i) {
              return instanceWatch.bind(i)
            }
          })
          var PublicInstanceProxyHandlers = {
            get: function get(_ref25, key) {
              var instance = _ref25._
              var ctx = instance.ctx,
                setupState = instance.setupState,
                data = instance.data,
                props = instance.props,
                accessCache = instance.accessCache,
                type = instance.type,
                appContext = instance.appContext // let @vue/reactivity know it should never observe Vue public instances.

              if (
                key === '__v_skip'
                /* SKIP */
              ) {
                return true
              } // for internal formatters to know that this is a Vue instance

              if (key === '__isVue') {
                return true
              } // data / props / ctx
              // This getter gets called for every property access on the render context
              // during render and is a major hotspot. The most expensive part of this
              // is the multiple hasOwn() calls. It's much faster to do a simple property
              // access on a plain object, so we use an accessCache object (with null
              // prototype) to memoize what access type a key corresponds to.

              var normalizedProps

              if (key[0] !== '$') {
                var n = accessCache[key]

                if (n !== undefined) {
                  switch (n) {
                    case 0:
                      /* SETUP */
                      return setupState[key]

                    case 1:
                      /* DATA */
                      return data[key]

                    case 3:
                      /* CONTEXT */
                      return ctx[key]

                    case 2:
                      /* PROPS */
                      return props[key]
                    // default: just fallthrough
                  }
                } else if (
                  setupState !== EMPTY_OBJ &&
                  hasOwn(setupState, key)
                ) {
                  accessCache[key] = 0
                  /* SETUP */
                  return setupState[key]
                } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                  accessCache[key] = 1
                  /* DATA */
                  return data[key]
                } else if (
                  // only cache other properties when instance has declared (thus stable)
                  // props
                  (normalizedProps = instance.propsOptions[0]) &&
                  hasOwn(normalizedProps, key)
                ) {
                  accessCache[key] = 2
                  /* PROPS */
                  return props[key]
                } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                  accessCache[key] = 3
                  /* CONTEXT */
                  return ctx[key]
                } else if (!isInBeforeCreate) {
                  accessCache[key] = 4
                  /* OTHER */
                }
              }

              var publicGetter = publicPropertiesMap[key]
              var cssModule, globalProperties // public $xxx properties

              if (publicGetter) {
                if (key === '$attrs') {
                  track(
                    instance,
                    'get',
                    /* GET */
                    key
                  )
                  markAttrsAccessed()
                }

                return publicGetter(instance)
              } else if (
                // css module (injected by vue-loader)
                (cssModule = type.__cssModules) &&
                (cssModule = cssModule[key])
              ) {
                return cssModule
              } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                // user may set custom properties to `this` that start with `$`
                accessCache[key] = 3
                /* CONTEXT */
                return ctx[key]
              } else if (
                // global properties
                ((globalProperties = appContext.config.globalProperties),
                hasOwn(globalProperties, key))
              ) {
                return globalProperties[key]
              } else if (
                currentRenderingInstance &&
                (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
                  // to infinite warning loop
                  key.indexOf('__v') !== 0)
              ) {
                if (
                  data !== EMPTY_OBJ &&
                  (key[0] === '$' || key[0] === '_') &&
                  hasOwn(data, key)
                ) {
                  warn(
                    'Property '.concat(
                      JSON.stringify(key),
                      ' must be accessed via $data because it starts with a reserved '
                    ) +
                      'character ("$" or "_") and is not proxied on the render context.'
                  )
                } else if (instance === currentRenderingInstance) {
                  warn(
                    'Property '.concat(
                      JSON.stringify(key),
                      ' was accessed during render '
                    ) + 'but is not defined on instance.'
                  )
                }
              }
            },
            set: function set(_ref26, key, value) {
              var instance = _ref26._
              var data = instance.data,
                setupState = instance.setupState,
                ctx = instance.ctx

              if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
                setupState[key] = value
              } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                data[key] = value
              } else if (hasOwn(instance.props, key)) {
                warn(
                  'Attempting to mutate prop "'.concat(
                    key,
                    '". Props are readonly.'
                  ),
                  instance
                )
                return false
              }

              if (key[0] === '$' && key.slice(1) in instance) {
                warn(
                  'Attempting to mutate public property "'.concat(key, '". ') +
                    'Properties starting with $ are reserved and readonly.',
                  instance
                )
                return false
              } else {
                if (key in instance.appContext.config.globalProperties) {
                  Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value: value
                  })
                } else {
                  ctx[key] = value
                }
              }

              return true
            },
            has: function has(_ref27, key) {
              var _ref27$_ = _ref27._,
                data = _ref27$_.data,
                setupState = _ref27$_.setupState,
                accessCache = _ref27$_.accessCache,
                ctx = _ref27$_.ctx,
                appContext = _ref27$_.appContext,
                propsOptions = _ref27$_.propsOptions
              var normalizedProps
              return (
                accessCache[key] !== undefined ||
                (data !== EMPTY_OBJ && hasOwn(data, key)) ||
                (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||
                ((normalizedProps = propsOptions[0]) &&
                  hasOwn(normalizedProps, key)) ||
                hasOwn(ctx, key) ||
                hasOwn(publicPropertiesMap, key) ||
                hasOwn(appContext.config.globalProperties, key)
              )
            }
          }
          {
            PublicInstanceProxyHandlers.ownKeys = function(target) {
              warn(
                'Avoid app logic that relies on enumerating keys on a component instance. ' +
                  'The keys will be empty in production mode to avoid performance overhead.'
              )
              return Reflect.ownKeys(target)
            }
          }
          var RuntimeCompiledPublicInstanceProxyHandlers = extend(
            {},
            PublicInstanceProxyHandlers,
            {
              get: function get(target, key) {
                // fast path for unscopables when using `with` block
                if (key === Symbol.unscopables) {
                  return
                }

                return PublicInstanceProxyHandlers.get(target, key, target)
              },
              has: function has(_, key) {
                var has = key[0] !== '_' && !isGloballyWhitelisted(key)

                if (!has && PublicInstanceProxyHandlers.has(_, key)) {
                  warn(
                    'Property '.concat(
                      JSON.stringify(key),
                      ' should not start with _ which is a reserved prefix for Vue internals.'
                    )
                  )
                }

                return has
              }
            }
          ) // In dev mode, the proxy target exposes the same properties as seen on `this`
          // for easier console inspection. In prod mode it will be an empty object so
          // these properties definitions can be skipped.

          function createRenderContext(instance) {
            var target = {} // expose internal instance for proxy handlers

            Object.defineProperty(target, '_', {
              configurable: true,
              enumerable: false,
              get: function get() {
                return instance
              }
            }) // expose public properties

            Object.keys(publicPropertiesMap).forEach(function(key) {
              Object.defineProperty(target, key, {
                configurable: true,
                enumerable: false,
                get: function get() {
                  return publicPropertiesMap[key](instance)
                },
                // intercepted by the proxy so no need for implementation,
                // but needed to prevent set errors
                set: NOOP
              })
            }) // expose global properties

            var globalProperties = instance.appContext.config.globalProperties
            Object.keys(globalProperties).forEach(function(key) {
              Object.defineProperty(target, key, {
                configurable: true,
                enumerable: false,
                get: function get() {
                  return globalProperties[key]
                },
                set: NOOP
              })
            })
            return target
          } // dev only

          function exposePropsOnRenderContext(instance) {
            var ctx = instance.ctx,
              _instance$propsOption6 = _slicedToArray(instance.propsOptions, 1),
              propsOptions = _instance$propsOption6[0]

            if (propsOptions) {
              Object.keys(propsOptions).forEach(function(key) {
                Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: function get() {
                    return instance.props[key]
                  },
                  set: NOOP
                })
              })
            }
          } // dev only

          function exposeSetupStateOnRenderContext(instance) {
            var ctx = instance.ctx,
              setupState = instance.setupState
            Object.keys(toRaw(setupState)).forEach(function(key) {
              if (key[0] === '$' || key[0] === '_') {
                warn(
                  'setup() return property '.concat(
                    JSON.stringify(key),
                    ' should not start with "$" or "_" '
                  ) + 'which are reserved prefixes for Vue internals.'
                )
                return
              }

              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: function get() {
                  return setupState[key]
                },
                set: NOOP
              })
            })
          }

          var emptyAppContext = createAppContext()
          var uid$2 = 0

          function createComponentInstance(vnode, parent, suspense) {
            var type = vnode.type // inherit parent app context - or - if root, adopt from root vnode

            var appContext =
              (parent ? parent.appContext : vnode.appContext) || emptyAppContext
            var instance = {
              uid: uid$2++,
              vnode: vnode,
              type: type,
              parent: parent,
              appContext: appContext,
              root: null,
              next: null,
              subTree: null,
              update: null,
              render: null,
              proxy: null,
              exposed: null,
              withProxy: null,
              effects: null,
              provides: parent
                ? parent.provides
                : Object.create(appContext.provides),
              accessCache: null,
              renderCache: [],
              // local resovled assets
              components: null,
              directives: null,
              // resolved props and emits options
              propsOptions: normalizePropsOptions(type, appContext),
              emitsOptions: normalizeEmitsOptions(type, appContext),
              // emit
              emit: null,
              emitted: null,
              // state
              ctx: EMPTY_OBJ,
              data: EMPTY_OBJ,
              props: EMPTY_OBJ,
              attrs: EMPTY_OBJ,
              slots: EMPTY_OBJ,
              refs: EMPTY_OBJ,
              setupState: EMPTY_OBJ,
              setupContext: null,
              // suspense related
              suspense: suspense,
              suspenseId: suspense ? suspense.pendingId : 0,
              asyncDep: null,
              asyncResolved: false,
              // lifecycle hooks
              // not using enums here because it results in computed properties
              isMounted: false,
              isUnmounted: false,
              isDeactivated: false,
              bc: null,
              c: null,
              bm: null,
              m: null,
              bu: null,
              u: null,
              um: null,
              bum: null,
              da: null,
              a: null,
              rtg: null,
              rtc: null,
              ec: null
            }
            {
              instance.ctx = createRenderContext(instance)
            }
            instance.root = parent ? parent.root : instance
            instance.emit = emit.bind(null, instance)
            return instance
          }

          var currentInstance = null

          var getCurrentInstance = function getCurrentInstance() {
            return currentInstance || currentRenderingInstance
          }

          var setCurrentInstance = function setCurrentInstance(instance) {
            currentInstance = instance
          }

          var isBuiltInTag = /*#__PURE__*/ makeMap('slot,component')

          function validateComponentName(name, config) {
            var appIsNativeTag = config.isNativeTag || NO

            if (isBuiltInTag(name) || appIsNativeTag(name)) {
              warn(
                'Do not use built-in or reserved HTML elements as component id: ' +
                  name
              )
            }
          }

          function isStatefulComponent(instance) {
            return (
              instance.vnode.shapeFlag & 4
              /* STATEFUL_COMPONENT */
            )
          }

          var isInSSRComponentSetup = false

          function setupComponent(instance) {
            var isSSR =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : false
            isInSSRComponentSetup = isSSR
            var _instance$vnode = instance.vnode,
              props = _instance$vnode.props,
              children = _instance$vnode.children
            var isStateful = isStatefulComponent(instance)
            initProps(instance, props, isStateful, isSSR)
            initSlots(instance, children)
            var setupResult = isStateful
              ? setupStatefulComponent(instance, isSSR)
              : undefined
            isInSSRComponentSetup = false
            return setupResult
          }

          function setupStatefulComponent(instance, isSSR) {
            var Component = instance.type
            {
              if (Component.name) {
                validateComponentName(
                  Component.name,
                  instance.appContext.config
                )
              }

              if (Component.components) {
                var names = Object.keys(Component.components)

                for (var i = 0; i < names.length; i++) {
                  validateComponentName(names[i], instance.appContext.config)
                }
              }

              if (Component.directives) {
                var _names = Object.keys(Component.directives)

                for (var _i3 = 0; _i3 < _names.length; _i3++) {
                  validateDirectiveName(_names[_i3])
                }
              }
            } // 0. create render proxy property access cache

            instance.accessCache = Object.create(null) // 1. create public instance / render proxy
            // also mark it raw so it's never observed

            instance.proxy = new Proxy(
              instance.ctx,
              PublicInstanceProxyHandlers
            )
            {
              exposePropsOnRenderContext(instance)
            } // 2. call setup()

            var setup = Component.setup

            if (setup) {
              var setupContext = (instance.setupContext =
                setup.length > 1 ? createSetupContext(instance) : null)
              currentInstance = instance
              pauseTracking()
              var setupResult = callWithErrorHandling(
                setup,
                instance,
                0,
                /* SETUP_FUNCTION */
                [shallowReadonly(instance.props), setupContext]
              )
              resetTracking()
              currentInstance = null

              if (isPromise(setupResult)) {
                if (isSSR) {
                  // return the promise so server-renderer can wait on it
                  return setupResult.then(function(resolvedResult) {
                    handleSetupResult(instance, resolvedResult)
                  })
                } else {
                  // async setup returned Promise.
                  // bail here and wait for re-entry.
                  instance.asyncDep = setupResult
                }
              } else {
                handleSetupResult(instance, setupResult)
              }
            } else {
              finishComponentSetup(instance)
            }
          }

          function handleSetupResult(instance, setupResult, isSSR) {
            if (isFunction(setupResult)) {
              // setup returned an inline render function
              {
                instance.render = setupResult
              }
            } else if (isObject(setupResult)) {
              if (isVNode(setupResult)) {
                warn(
                  'setup() should not return VNodes directly - ' +
                    'return a render function instead.'
                )
              } // setup returned bindings.
              // assuming a render function compiled from template is present.

              {
                instance.devtoolsRawSetupState = setupResult
              }
              instance.setupState = proxyRefs(setupResult)
              {
                exposeSetupStateOnRenderContext(instance)
              }
            } else if (setupResult !== undefined) {
              warn(
                'setup() should return an object. Received: '.concat(
                  setupResult === null ? 'null' : _typeof(setupResult)
                )
              )
            }

            finishComponentSetup(instance)
          }

          var compile // dev only

          var isRuntimeOnly = function isRuntimeOnly() {
            return !compile
          }
          /**
           * For runtime-dom to register the compiler.
           * Note the exported method uses any to avoid d.ts relying on the compiler types.
           */

          function registerRuntimeCompiler(_compile) {
            compile = _compile
          }

          function finishComponentSetup(instance, isSSR) {
            var Component = instance.type // template / render function normalization

            if (!instance.render) {
              // could be set from setup()
              if (compile && Component.template && !Component.render) {
                {
                  startMeasure(instance, 'compile')
                }
                Component.render = compile(Component.template, {
                  isCustomElement: instance.appContext.config.isCustomElement,
                  delimiters: Component.delimiters
                })
                {
                  endMeasure(instance, 'compile')
                }
              }

              instance.render = Component.render || NOOP // for runtime-compiled render functions using `with` blocks, the render
              // proxy used needs a different `has` handler which is more performant and
              // also only allows a whitelist of globals to fallthrough.

              if (instance.render._rc) {
                instance.withProxy = new Proxy(
                  instance.ctx,
                  RuntimeCompiledPublicInstanceProxyHandlers
                )
              }
            } // support for 2.x options

            {
              currentInstance = instance
              pauseTracking()
              applyOptions(instance, Component)
              resetTracking()
              currentInstance = null
            } // warn missing template/render

            if (!Component.render && instance.render === NOOP) {
              /* istanbul ignore if */
              if (!compile && Component.template) {
                warn(
                  'Component provided template option but ' +
                    'runtime compilation is not supported in this build of Vue.' +
                    ' Use "vue.esm-browser.js" instead.'
                  /* should not happen */
                )
              } else {
                warn('Component is missing template or render function.')
              }
            }
          }

          var attrHandlers = {
            get: function get(target, key) {
              {
                markAttrsAccessed()
              }
              return target[key]
            },
            set: function set() {
              warn('setupContext.attrs is readonly.')
              return false
            },
            deleteProperty: function deleteProperty() {
              warn('setupContext.attrs is readonly.')
              return false
            }
          }

          function createSetupContext(instance) {
            var expose = function expose(exposed) {
              if (instance.exposed) {
                warn('expose() should be called only once per setup().')
              }

              instance.exposed = proxyRefs(exposed)
            }

            {
              // We use getters in dev in case libs like test-utils overwrite instance
              // properties (overwrites should not be done in prod)
              return Object.freeze({
                get props() {
                  return instance.props
                },

                get attrs() {
                  return new Proxy(instance.attrs, attrHandlers)
                },

                get slots() {
                  return shallowReadonly(instance.slots)
                },

                get emit() {
                  return function(event) {
                    for (
                      var _len9 = arguments.length,
                        args = new Array(_len9 > 1 ? _len9 - 1 : 0),
                        _key20 = 1;
                      _key20 < _len9;
                      _key20++
                    ) {
                      args[_key20 - 1] = arguments[_key20]
                    }

                    return instance.emit.apply(instance, [event].concat(args))
                  }
                },

                expose: expose
              })
            }
          } // record effects created during a component's setup() so that they can be
          // stopped when the component unmounts

          function recordInstanceBoundEffect(effect) {
            var instance =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : currentInstance

            if (instance) {
              ;(instance.effects || (instance.effects = [])).push(effect)
            }
          }

          var classifyRE = /(?:^|[-_])(\w)/g

          var classify = function classify(str) {
            return str
              .replace(classifyRE, function(c) {
                return c.toUpperCase()
              })
              .replace(/[-_]/g, '')
          }

          function getComponentName(Component) {
            return isFunction(Component)
              ? Component.displayName || Component.name
              : Component.name
          }
          /* istanbul ignore next */

          function formatComponentName(instance, Component) {
            var isRoot =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : false
            var name = getComponentName(Component)

            if (!name && Component.__file) {
              var match = Component.__file.match(/([^/\\]+)\.\w+$/)

              if (match) {
                name = match[1]
              }
            }

            if (!name && instance && instance.parent) {
              // try to infer the name based on reverse resolution
              var inferFromRegistry = function inferFromRegistry(registry) {
                for (var key in registry) {
                  if (registry[key] === Component) {
                    return key
                  }
                }
              }

              name =
                inferFromRegistry(
                  instance.components || instance.parent.type.components
                ) || inferFromRegistry(instance.appContext.components)
            }

            return name ? classify(name) : isRoot ? 'App' : 'Anonymous'
          }

          function isClassComponent(value) {
            return isFunction(value) && '__vccOpts' in value
          }

          function computed$1(getterOrOptions) {
            var c = computed(getterOrOptions)
            recordInstanceBoundEffect(c.effect)
            return c
          } // implementation

          function defineProps() {
            {
              warn(
                'defineProps() is a compiler-hint helper that is only usable inside ' +
                  '<script setup> of a single file component. Its arguments should be ' +
                  'compiled away and passing it at runtime has no effect.'
              )
            }
            return null
          } // implementation

          function defineEmit() {
            {
              warn(
                'defineEmit() is a compiler-hint helper that is only usable inside ' +
                  '<script setup> of a single file component. Its arguments should be ' +
                  'compiled away and passing it at runtime has no effect.'
              )
            }
            return null
          }

          function useContext() {
            var i = getCurrentInstance()

            if (!i) {
              warn('useContext() called without active instance.')
            }

            return i.setupContext || (i.setupContext = createSetupContext(i))
          } // Actual implementation

          function h(type, propsOrChildren, children) {
            var l = arguments.length

            if (l === 2) {
              if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
                // single vnode without props
                if (isVNode(propsOrChildren)) {
                  return createVNode(type, null, [propsOrChildren])
                } // props without children

                return createVNode(type, propsOrChildren)
              } else {
                // omit props
                return createVNode(type, null, propsOrChildren)
              }
            } else {
              if (l > 3) {
                children = Array.prototype.slice.call(arguments, 2)
              } else if (l === 3 && isVNode(children)) {
                children = [children]
              }

              return createVNode(type, propsOrChildren, children)
            }
          }

          var ssrContextKey = Symbol('ssrContext')

          var useSSRContext = function useSSRContext() {
            {
              var ctx = inject(ssrContextKey)

              if (!ctx) {
                warn(
                  'Server rendering context not provided. Make sure to only call ' +
                    'useSSRContext() conditionally in the server build.'
                )
              }

              return ctx
            }
          }

          function initCustomFormatter() {
            /* eslint-disable no-restricted-globals */
            if (typeof window === 'undefined') {
              return
            }

            var vueStyle = {
              style: 'color:#3ba776'
            }
            var numberStyle = {
              style: 'color:#0b1bc9'
            }
            var stringStyle = {
              style: 'color:#b62e24'
            }
            var keywordStyle = {
              style: 'color:#9d288c'
            } // custom formatter for Chrome
            // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html

            var formatter = {
              header: function header(obj) {
                // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
                if (!isObject(obj)) {
                  return null
                }

                if (obj.__isVue) {
                  return ['div', vueStyle, 'VueInstance']
                } else if (isRef(obj)) {
                  return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    '>'
                  ]
                } else if (isReactive(obj)) {
                  return [
                    'div',
                    {},
                    ['span', vueStyle, 'Reactive'],
                    '<',
                    formatValue(obj),
                    '>'.concat(isReadonly(obj) ? ' (readonly)' : '')
                  ]
                } else if (isReadonly(obj)) {
                  return [
                    'div',
                    {},
                    ['span', vueStyle, 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                  ]
                }

                return null
              },
              hasBody: function hasBody(obj) {
                return obj && obj.__isVue
              },
              body: function body(obj) {
                if (obj && obj.__isVue) {
                  return ['div', {}].concat(
                    _toConsumableArray(formatInstance(obj.$))
                  )
                }
              }
            }

            function formatInstance(instance) {
              var blocks = []

              if (instance.type.props && instance.props) {
                blocks.push(createInstanceBlock('props', toRaw(instance.props)))
              }

              if (instance.setupState !== EMPTY_OBJ) {
                blocks.push(createInstanceBlock('setup', instance.setupState))
              }

              if (instance.data !== EMPTY_OBJ) {
                blocks.push(createInstanceBlock('data', toRaw(instance.data)))
              }

              var computed = extractKeys(instance, 'computed')

              if (computed) {
                blocks.push(createInstanceBlock('computed', computed))
              }

              var injected = extractKeys(instance, 'inject')

              if (injected) {
                blocks.push(createInstanceBlock('injected', injected))
              }

              blocks.push([
                'div',
                {},
                [
                  'span',
                  {
                    style: keywordStyle.style + ';opacity:0.66'
                  },
                  '$ (internal): '
                ],
                [
                  'object',
                  {
                    object: instance
                  }
                ]
              ])
              return blocks
            }

            function createInstanceBlock(type, target) {
              target = extend({}, target)

              if (!Object.keys(target).length) {
                return ['span', {}]
              }

              return [
                'div',
                {
                  style: 'line-height:1.25em;margin-bottom:0.6em'
                },
                [
                  'div',
                  {
                    style: 'color:#476582'
                  },
                  type
                ],
                [
                  'div',
                  {
                    style: 'padding-left:1.25em'
                  }
                ].concat(
                  _toConsumableArray(
                    Object.keys(target).map(function(key) {
                      return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                      ]
                    })
                  )
                )
              ]
            }

            function formatValue(v) {
              var asRaw =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : true

              if (typeof v === 'number') {
                return ['span', numberStyle, v]
              } else if (typeof v === 'string') {
                return ['span', stringStyle, JSON.stringify(v)]
              } else if (typeof v === 'boolean') {
                return ['span', keywordStyle, v]
              } else if (isObject(v)) {
                return [
                  'object',
                  {
                    object: asRaw ? toRaw(v) : v
                  }
                ]
              } else {
                return ['span', stringStyle, String(v)]
              }
            }

            function extractKeys(instance, type) {
              var Comp = instance.type

              if (isFunction(Comp)) {
                return
              }

              var extracted = {}

              for (var key in instance.ctx) {
                if (isKeyOfType(Comp, key, type)) {
                  extracted[key] = instance.ctx[key]
                }
              }

              return extracted
            }

            function isKeyOfType(Comp, key, type) {
              var opts = Comp[type]

              if (
                (isArray(opts) && opts.includes(key)) ||
                (isObject(opts) && key in opts)
              ) {
                return true
              }

              if (Comp['extends'] && isKeyOfType(Comp['extends'], key, type)) {
                return true
              }

              if (
                Comp.mixins &&
                Comp.mixins.some(function(m) {
                  return isKeyOfType(m, key, type)
                })
              ) {
                return true
              }
            }

            function genRefFlag(v) {
              if (v._shallow) {
                return 'ShallowRef'
              }

              if (v.effect) {
                return 'ComputedRef'
              }

              return 'Ref'
            }

            if (window.devtoolsFormatters) {
              window.devtoolsFormatters.push(formatter)
            } else {
              window.devtoolsFormatters = [formatter]
            }
          }
          /**
           * Actual implementation
           */

          function renderList(source, renderItem) {
            var ret

            if (isArray(source) || isString(source)) {
              ret = new Array(source.length)

              for (var i = 0, l = source.length; i < l; i++) {
                ret[i] = renderItem(source[i], i)
              }
            } else if (typeof source === 'number') {
              if (!Number.isInteger(source)) {
                warn(
                  'The v-for range expect an integer value but got '.concat(
                    source,
                    '.'
                  )
                )
                return []
              }

              ret = new Array(source)

              for (var _i4 = 0; _i4 < source; _i4++) {
                ret[_i4] = renderItem(_i4 + 1, _i4)
              }
            } else if (isObject(source)) {
              if (source[Symbol.iterator]) {
                ret = Array.from(source, renderItem)
              } else {
                var keys = Object.keys(source)
                ret = new Array(keys.length)

                for (var _i5 = 0, _l = keys.length; _i5 < _l; _i5++) {
                  var key = keys[_i5]
                  ret[_i5] = renderItem(source[key], key, _i5)
                }
              }
            } else {
              ret = []
            }

            return ret
          }
          /**
           * For prefixing keys in v-on="obj" with "on"
           * @private
           */

          function toHandlers(obj) {
            var ret = {}

            if (!isObject(obj)) {
              warn('v-on with no argument expects an object value.')
              return ret
            }

            for (var key in obj) {
              ret[toHandlerKey(key)] = obj[key]
            }

            return ret
          }
          /**
           * Compiler runtime helper for creating dynamic slots object
           * @private
           */

          function createSlots(slots, dynamicSlots) {
            for (var i = 0; i < dynamicSlots.length; i++) {
              var slot = dynamicSlots[i] // array of dynamic slot generated by <template v-for="..." #[...]>

              if (isArray(slot)) {
                for (var j = 0; j < slot.length; j++) {
                  slots[slot[j].name] = slot[j].fn
                }
              } else if (slot) {
                // conditional single slot generated by <template v-if="..." #foo>
                slots[slot.name] = slot.fn
              }
            }

            return slots
          } // Core API ------------------------------------------------------------------

          var version = '3.0.6'
          /**
           * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
           * @internal
           */

          var ssrUtils = null
          var svgNS = 'http://www.w3.org/2000/svg'
          var doc = typeof document !== 'undefined' ? document : null
          var tempContainer
          var tempSVGContainer
          var nodeOps = {
            insert: function insert(child, parent, anchor) {
              parent.insertBefore(child, anchor || null)
            },
            remove: function remove(child) {
              var parent = child.parentNode

              if (parent) {
                parent.removeChild(child)
              }
            },
            createElement: function createElement(tag, isSVG, is) {
              return isSVG
                ? doc.createElementNS(svgNS, tag)
                : doc.createElement(
                    tag,
                    is
                      ? {
                          is: is
                        }
                      : undefined
                  )
            },
            createText: function createText(text) {
              return doc.createTextNode(text)
            },
            createComment: function createComment(text) {
              return doc.createComment(text)
            },
            setText: function setText(node, text) {
              node.nodeValue = text
            },
            setElementText: function setElementText(el, text) {
              el.textContent = text
            },
            parentNode: function parentNode(node) {
              return node.parentNode
            },
            nextSibling: function nextSibling(node) {
              return node.nextSibling
            },
            querySelector: function querySelector(selector) {
              return doc.querySelector(selector)
            },
            setScopeId: function setScopeId(el, id) {
              el.setAttribute(id, '')
            },
            cloneNode: function cloneNode(el) {
              return el.cloneNode(true)
            },
            // __UNSAFE__
            // Reason: innerHTML.
            // Static content here can only come from compiled templates.
            // As long as the user only uses trusted templates, this is safe.
            insertStaticContent: function insertStaticContent(
              content,
              parent,
              anchor,
              isSVG
            ) {
              var temp = isSVG
                ? tempSVGContainer ||
                  (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))
                : tempContainer || (tempContainer = doc.createElement('div'))
              temp.innerHTML = content
              var first = temp.firstChild
              var node = first
              var last = node

              while (node) {
                last = node
                nodeOps.insert(node, parent, anchor)
                node = temp.firstChild
              }

              return [first, last]
            }
          } // compiler should normalize class + :class bindings on the same element
          // into a single binding ['staticClass', dynamic]

          function patchClass(el, value, isSVG) {
            if (value == null) {
              value = ''
            }

            if (isSVG) {
              el.setAttribute('class', value)
            } else {
              // directly setting className should be faster than setAttribute in theory
              // if this is an element during a transition, take the temporary transition
              // classes into account.
              var transitionClasses = el._vtc

              if (transitionClasses) {
                value = (value
                  ? [value].concat(_toConsumableArray(transitionClasses))
                  : _toConsumableArray(transitionClasses)
                ).join(' ')
              }

              el.className = value
            }
          }

          function patchStyle(el, prev, next) {
            var style = el.style

            if (!next) {
              el.removeAttribute('style')
            } else if (isString(next)) {
              if (prev !== next) {
                style.cssText = next
              }
            } else {
              for (var key in next) {
                setStyle(style, key, next[key])
              }

              if (prev && !isString(prev)) {
                for (var _key21 in prev) {
                  if (next[_key21] == null) {
                    setStyle(style, _key21, '')
                  }
                }
              }
            }
          }

          var importantRE = /\s*!important$/

          function setStyle(style, name, val) {
            if (isArray(val)) {
              val.forEach(function(v) {
                return setStyle(style, name, v)
              })
            } else {
              if (name.startsWith('--')) {
                // custom property definition
                style.setProperty(name, val)
              } else {
                var prefixed = autoPrefix(style, name)

                if (importantRE.test(val)) {
                  // !important
                  style.setProperty(
                    hyphenate(prefixed),
                    val.replace(importantRE, ''),
                    'important'
                  )
                } else {
                  style[prefixed] = val
                }
              }
            }
          }

          var prefixes = ['Webkit', 'Moz', 'ms']
          var prefixCache = {}

          function autoPrefix(style, rawName) {
            var cached = prefixCache[rawName]

            if (cached) {
              return cached
            }

            var name = camelize(rawName)

            if (name !== 'filter' && name in style) {
              return (prefixCache[rawName] = name)
            }

            name = capitalize(name)

            for (var i = 0; i < prefixes.length; i++) {
              var prefixed = prefixes[i] + name

              if (prefixed in style) {
                return (prefixCache[rawName] = prefixed)
              }
            }

            return rawName
          }

          var xlinkNS = 'http://www.w3.org/1999/xlink'

          function patchAttr(el, key, value, isSVG) {
            if (isSVG && key.startsWith('xlink:')) {
              if (value == null) {
                el.removeAttributeNS(xlinkNS, key.slice(6, key.length))
              } else {
                el.setAttributeNS(xlinkNS, key, value)
              }
            } else {
              // note we are only checking boolean attributes that don't have a
              // corresponding dom prop of the same name here.
              var _isBoolean = isSpecialBooleanAttr(key)

              if (value == null || (_isBoolean && value === false)) {
                el.removeAttribute(key)
              } else {
                el.setAttribute(key, _isBoolean ? '' : value)
              }
            }
          } // __UNSAFE__
          // functions. The user is responsible for using them with only trusted content.

          function patchDOMProp(
            el,
            key,
            value, // the following args are passed only due to potential innerHTML/textContent
            // overriding existing VNodes, in which case the old tree must be properly
            // unmounted.
            prevChildren,
            parentComponent,
            parentSuspense,
            unmountChildren
          ) {
            if (key === 'innerHTML' || key === 'textContent') {
              if (prevChildren) {
                unmountChildren(prevChildren, parentComponent, parentSuspense)
              }

              el[key] = value == null ? '' : value
              return
            }

            if (key === 'value' && el.tagName !== 'PROGRESS') {
              // store value as _value as well since
              // non-string values will be stringified.
              el._value = value
              var newValue = value == null ? '' : value

              if (el.value !== newValue) {
                el.value = newValue
              }

              return
            }

            if (value === '' || value == null) {
              var type = _typeof(el[key])

              if (value === '' && type === 'boolean') {
                // e.g. <select multiple> compiles to { multiple: '' }
                el[key] = true
                return
              } else if (value == null && type === 'string') {
                // e.g. <div :id="null">
                el[key] = ''
                el.removeAttribute(key)
                return
              } else if (type === 'number') {
                // e.g. <img :width="null">
                el[key] = 0
                el.removeAttribute(key)
                return
              }
            } // some properties perform value validation and throw

            try {
              el[key] = value
            } catch (e) {
              {
                warn(
                  'Failed setting prop "'
                    .concat(key, '" on <')
                    .concat(el.tagName.toLowerCase(), '>: ') +
                    'value '.concat(value, ' is invalid.'),
                  e
                )
              }
            }
          } // Async edge case fix requires storing an event listener's attach timestamp.

          var _getNow = Date.now // Determine what event timestamp the browser is using. Annoyingly, the
          // timestamp can either be hi-res (relative to page load) or low-res
          // (relative to UNIX epoch), so in order to compare time we have to use the
          // same timestamp type when saving the flush timestamp.

          if (
            typeof document !== 'undefined' &&
            _getNow() > document.createEvent('Event').timeStamp
          ) {
            // if the low-res timestamp which is bigger than the event timestamp
            // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
            // and we need to use the hi-res version for event listeners as well.
            _getNow = function _getNow() {
              return performance.now()
            }
          } // To avoid the overhead of repeatedly calling performance.now(), we cache
          // and use the same timestamp for all event listeners attached in the same tick.

          var cachedNow = 0
          var p = Promise.resolve()

          var reset = function reset() {
            cachedNow = 0
          }

          var getNow = function getNow() {
            return cachedNow || (p.then(reset), (cachedNow = _getNow()))
          }

          function addEventListener(el, event, handler, options) {
            el.addEventListener(event, handler, options)
          }

          function removeEventListener(el, event, handler, options) {
            el.removeEventListener(event, handler, options)
          }

          function patchEvent(el, rawName, prevValue, nextValue) {
            var instance =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : null
            // vei = vue event invokers
            var invokers = el._vei || (el._vei = {})
            var existingInvoker = invokers[rawName]

            if (nextValue && existingInvoker) {
              // patch
              existingInvoker.value = nextValue
            } else {
              var _parseName = parseName(rawName),
                _parseName2 = _slicedToArray(_parseName, 2),
                name = _parseName2[0],
                options = _parseName2[1]

              if (nextValue) {
                // add
                var invoker = (invokers[rawName] = createInvoker(
                  nextValue,
                  instance
                ))
                addEventListener(el, name, invoker, options)
              } else if (existingInvoker) {
                // remove
                removeEventListener(el, name, existingInvoker, options)
                invokers[rawName] = undefined
              }
            }
          }

          var optionsModifierRE = /(?:Once|Passive|Capture)$/

          function parseName(name) {
            var options

            if (optionsModifierRE.test(name)) {
              options = {}
              var m

              while ((m = name.match(optionsModifierRE))) {
                name = name.slice(0, name.length - m[0].length)
                options[m[0].toLowerCase()] = true
              }
            }

            return [hyphenate(name.slice(2)), options]
          }

          function createInvoker(initialValue, instance) {
            var invoker = function invoker(e) {
              // async edge case #6566: inner click event triggers patch, event handler
              // attached to outer element during patch, and triggered again. This
              // happens because browsers fire microtask ticks between event propagation.
              // the solution is simple: we save the timestamp when a handler is attached,
              // and the handler would only fire if the event passed to it was fired
              // AFTER it was attached.
              var timeStamp = e.timeStamp || _getNow()

              if (timeStamp >= invoker.attached - 1) {
                callWithAsyncErrorHandling(
                  patchStopImmediatePropagation(e, invoker.value),
                  instance,
                  5,
                  /* NATIVE_EVENT_HANDLER */
                  [e]
                )
              }
            }

            invoker.value = initialValue
            invoker.attached = getNow()
            return invoker
          }

          function patchStopImmediatePropagation(e, value) {
            if (isArray(value)) {
              var originalStop = e.stopImmediatePropagation

              e.stopImmediatePropagation = function() {
                originalStop.call(e)
                e._stopped = true
              }

              return value.map(function(fn) {
                return function(e) {
                  return !e._stopped && fn(e)
                }
              })
            } else {
              return value
            }
          }

          var nativeOnRE = /^on[a-z]/

          var forcePatchProp = function forcePatchProp(_, key) {
            return key === 'value'
          }

          var patchProp = function patchProp(el, key, prevValue, nextValue) {
            var isSVG =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : false
            var prevChildren = arguments.length > 5 ? arguments[5] : undefined
            var parentComponent =
              arguments.length > 6 ? arguments[6] : undefined
            var parentSuspense = arguments.length > 7 ? arguments[7] : undefined
            var unmountChildren =
              arguments.length > 8 ? arguments[8] : undefined

            switch (key) {
              // special
              case 'class':
                patchClass(el, nextValue, isSVG)
                break

              case 'style':
                patchStyle(el, prevValue, nextValue)
                break

              default:
                if (isOn(key)) {
                  // ignore v-model listeners
                  if (!isModelListener(key)) {
                    patchEvent(el, key, prevValue, nextValue, parentComponent)
                  }
                } else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
                  patchDOMProp(
                    el,
                    key,
                    nextValue,
                    prevChildren,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  )
                } else {
                  // special case for <input v-model type="checkbox"> with
                  // :true-value & :false-value
                  // store value as dom properties since non-string values will be
                  // stringified.
                  if (key === 'true-value') {
                    el._trueValue = nextValue
                  } else if (key === 'false-value') {
                    el._falseValue = nextValue
                  }

                  patchAttr(el, key, nextValue, isSVG)
                }

                break
            }
          }

          function shouldSetAsProp(el, key, value, isSVG) {
            if (isSVG) {
              // most keys must be set as attribute on svg elements to work
              // ...except innerHTML
              if (key === 'innerHTML') {
                return true
              } // or native onclick with function values

              if (key in el && nativeOnRE.test(key) && isFunction(value)) {
                return true
              }

              return false
            } // spellcheck and draggable are numerated attrs, however their
            // corresponding DOM properties are actually booleans - this leads to
            // setting it with a string "false" value leading it to be coerced to
            // `true`, so we need to always treat them as attributes.
            // Note that `contentEditable` doesn't have this problem: its DOM
            // property is also enumerated string values.

            if (key === 'spellcheck' || key === 'draggable') {
              return false
            } // #1787, #2840 form property on form elements is readonly and must be set as
            // attribute.

            if (key === 'form') {
              return false
            } // #1526 <input list> must be set as attribute

            if (key === 'list' && el.tagName === 'INPUT') {
              return false
            } // #2766 <textarea type> must be set as attribute

            if (key === 'type' && el.tagName === 'TEXTAREA') {
              return false
            } // native onclick with string value, must be set as attribute

            if (nativeOnRE.test(key) && isString(value)) {
              return false
            }

            return key in el
          }

          function useCssModule() {
            var name =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : '$style'

            /* istanbul ignore else */
            {
              var instance = getCurrentInstance()

              if (!instance) {
                warn('useCssModule must be called inside setup()')
                return EMPTY_OBJ
              }

              var modules = instance.type.__cssModules

              if (!modules) {
                warn('Current instance does not have CSS modules injected.')
                return EMPTY_OBJ
              }

              var mod = modules[name]

              if (!mod) {
                warn(
                  'Current instance does not have CSS module named "'.concat(
                    name,
                    '".'
                  )
                )
                return EMPTY_OBJ
              }

              return mod
            }
          }
          /**
           * Runtime helper for SFC's CSS variable injection feature.
           * @private
           */

          function useCssVars(getter) {
            var instance = getCurrentInstance()
            /* istanbul ignore next */

            if (!instance) {
              warn(
                'useCssVars is called without current active component instance.'
              )
              return
            }

            var setVars = function setVars() {
              return setVarsOnVNode(instance.subTree, getter(instance.proxy))
            }

            onMounted(function() {
              return watchEffect(setVars, {
                flush: 'post'
              })
            })
            onUpdated(setVars)
          }

          function setVarsOnVNode(vnode, vars) {
            if (
              vnode.shapeFlag & 128
              /* SUSPENSE */
            ) {
              var suspense = vnode.suspense
              vnode = suspense.activeBranch

              if (suspense.pendingBranch && !suspense.isHydrating) {
                suspense.effects.push(function() {
                  setVarsOnVNode(suspense.activeBranch, vars)
                })
              }
            } // drill down HOCs until it's a non-component vnode

            while (vnode.component) {
              vnode = vnode.component.subTree
            }

            if (
              vnode.shapeFlag & 1 &&
              /* ELEMENT */
              vnode.el
            ) {
              var style = vnode.el.style

              for (var key in vars) {
                style.setProperty('--'.concat(key), vars[key])
              }
            } else if (vnode.type === Fragment) {
              vnode.children.forEach(function(c) {
                return setVarsOnVNode(c, vars)
              })
            }
          }

          var TRANSITION = 'transition'
          var ANIMATION = 'animation' // DOM Transition is a higher-order-component based on the platform-agnostic
          // base Transition component, with DOM-specific logic.

          var Transition = function Transition(props, _ref28) {
            var slots = _ref28.slots
            return h(BaseTransition, resolveTransitionProps(props), slots)
          }

          Transition.displayName = 'Transition'
          var DOMTransitionPropsValidators = {
            name: String,
            type: String,
            css: {
              type: Boolean,
              default: true
            },
            duration: [String, Number, Object],
            enterFromClass: String,
            enterActiveClass: String,
            enterToClass: String,
            appearFromClass: String,
            appearActiveClass: String,
            appearToClass: String,
            leaveFromClass: String,
            leaveActiveClass: String,
            leaveToClass: String
          }
          var TransitionPropsValidators = (Transition.props = /*#__PURE__*/ extend(
            {},
            BaseTransition.props,
            DOMTransitionPropsValidators
          ))

          function resolveTransitionProps(rawProps) {
            var _rawProps$name = rawProps.name,
              name = _rawProps$name === void 0 ? 'v' : _rawProps$name,
              type = rawProps.type,
              _rawProps$css = rawProps.css,
              css = _rawProps$css === void 0 ? true : _rawProps$css,
              duration = rawProps.duration,
              _rawProps$enterFromCl = rawProps.enterFromClass,
              enterFromClass =
                _rawProps$enterFromCl === void 0
                  ? ''.concat(name, '-enter-from')
                  : _rawProps$enterFromCl,
              _rawProps$enterActive = rawProps.enterActiveClass,
              enterActiveClass =
                _rawProps$enterActive === void 0
                  ? ''.concat(name, '-enter-active')
                  : _rawProps$enterActive,
              _rawProps$enterToClas = rawProps.enterToClass,
              enterToClass =
                _rawProps$enterToClas === void 0
                  ? ''.concat(name, '-enter-to')
                  : _rawProps$enterToClas,
              _rawProps$appearFromC = rawProps.appearFromClass,
              appearFromClass =
                _rawProps$appearFromC === void 0
                  ? enterFromClass
                  : _rawProps$appearFromC,
              _rawProps$appearActiv = rawProps.appearActiveClass,
              appearActiveClass =
                _rawProps$appearActiv === void 0
                  ? enterActiveClass
                  : _rawProps$appearActiv,
              _rawProps$appearToCla = rawProps.appearToClass,
              appearToClass =
                _rawProps$appearToCla === void 0
                  ? enterToClass
                  : _rawProps$appearToCla,
              _rawProps$leaveFromCl = rawProps.leaveFromClass,
              leaveFromClass =
                _rawProps$leaveFromCl === void 0
                  ? ''.concat(name, '-leave-from')
                  : _rawProps$leaveFromCl,
              _rawProps$leaveActive = rawProps.leaveActiveClass,
              leaveActiveClass =
                _rawProps$leaveActive === void 0
                  ? ''.concat(name, '-leave-active')
                  : _rawProps$leaveActive,
              _rawProps$leaveToClas = rawProps.leaveToClass,
              leaveToClass =
                _rawProps$leaveToClas === void 0
                  ? ''.concat(name, '-leave-to')
                  : _rawProps$leaveToClas
            var baseProps = {}

            for (var key in rawProps) {
              if (!(key in DOMTransitionPropsValidators)) {
                baseProps[key] = rawProps[key]
              }
            }

            if (!css) {
              return baseProps
            }

            var durations = normalizeDuration(duration)
            var enterDuration = durations && durations[0]
            var leaveDuration = durations && durations[1]

            var _onBeforeEnter = baseProps.onBeforeEnter,
              onEnter = baseProps.onEnter,
              _onEnterCancelled = baseProps.onEnterCancelled,
              _onLeave = baseProps.onLeave,
              _onLeaveCancelled = baseProps.onLeaveCancelled,
              _baseProps$onBeforeAp = baseProps.onBeforeAppear,
              _onBeforeAppear =
                _baseProps$onBeforeAp === void 0
                  ? _onBeforeEnter
                  : _baseProps$onBeforeAp,
              _baseProps$onAppear = baseProps.onAppear,
              onAppear =
                _baseProps$onAppear === void 0 ? onEnter : _baseProps$onAppear,
              _baseProps$onAppearCa = baseProps.onAppearCancelled,
              _onAppearCancelled =
                _baseProps$onAppearCa === void 0
                  ? _onEnterCancelled
                  : _baseProps$onAppearCa

            var finishEnter = function finishEnter(el, isAppear, done) {
              removeTransitionClass(el, isAppear ? appearToClass : enterToClass)
              removeTransitionClass(
                el,
                isAppear ? appearActiveClass : enterActiveClass
              )
              done && done()
            }

            var finishLeave = function finishLeave(el, done) {
              removeTransitionClass(el, leaveToClass)
              removeTransitionClass(el, leaveActiveClass)
              done && done()
            }

            var makeEnterHook = function makeEnterHook(isAppear) {
              return function(el, done) {
                var hook = isAppear ? onAppear : onEnter

                var resolve = function resolve() {
                  return finishEnter(el, isAppear, done)
                }

                hook && hook(el, resolve)
                nextFrame(function() {
                  removeTransitionClass(
                    el,
                    isAppear ? appearFromClass : enterFromClass
                  )
                  addTransitionClass(
                    el,
                    isAppear ? appearToClass : enterToClass
                  )

                  if (!(hook && hook.length > 1)) {
                    whenTransitionEnds(el, type, enterDuration, resolve)
                  }
                })
              }
            }

            return extend(baseProps, {
              onBeforeEnter: function onBeforeEnter(el) {
                _onBeforeEnter && _onBeforeEnter(el)
                addTransitionClass(el, enterFromClass)
                addTransitionClass(el, enterActiveClass)
              },
              onBeforeAppear: function onBeforeAppear(el) {
                _onBeforeAppear && _onBeforeAppear(el)
                addTransitionClass(el, appearFromClass)
                addTransitionClass(el, appearActiveClass)
              },
              onEnter: makeEnterHook(false),
              onAppear: makeEnterHook(true),
              onLeave: function onLeave(el, done) {
                var resolve = function resolve() {
                  return finishLeave(el, done)
                }

                addTransitionClass(el, leaveFromClass) // force reflow so *-leave-from classes immediately take effect (#2593)

                forceReflow()
                addTransitionClass(el, leaveActiveClass)
                nextFrame(function() {
                  removeTransitionClass(el, leaveFromClass)
                  addTransitionClass(el, leaveToClass)

                  if (!(_onLeave && _onLeave.length > 1)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve)
                  }
                })
                _onLeave && _onLeave(el, resolve)
              },
              onEnterCancelled: function onEnterCancelled(el) {
                finishEnter(el, false)
                _onEnterCancelled && _onEnterCancelled(el)
              },
              onAppearCancelled: function onAppearCancelled(el) {
                finishEnter(el, true)
                _onAppearCancelled && _onAppearCancelled(el)
              },
              onLeaveCancelled: function onLeaveCancelled(el) {
                finishLeave(el)
                _onLeaveCancelled && _onLeaveCancelled(el)
              }
            })
          }

          function normalizeDuration(duration) {
            if (duration == null) {
              return null
            } else if (isObject(duration)) {
              return [NumberOf(duration.enter), NumberOf(duration.leave)]
            } else {
              var n = NumberOf(duration)
              return [n, n]
            }
          }

          function NumberOf(val) {
            var res = toNumber(val)
            validateDuration(res)
            return res
          }

          function validateDuration(val) {
            if (typeof val !== 'number') {
              warn(
                '<transition> explicit duration is not a valid number - ' +
                  'got '.concat(JSON.stringify(val), '.')
              )
            } else if (isNaN(val)) {
              warn(
                '<transition> explicit duration is NaN - ' +
                  'the duration expression might be incorrect.'
              )
            }
          }

          function addTransitionClass(el, cls) {
            cls.split(/\s+/).forEach(function(c) {
              return c && el.classList.add(c)
            })
            ;(el._vtc || (el._vtc = new Set())).add(cls)
          }

          function removeTransitionClass(el, cls) {
            cls.split(/\s+/).forEach(function(c) {
              return c && el.classList.remove(c)
            })
            var _vtc = el._vtc

            if (_vtc) {
              _vtc['delete'](cls)

              if (!_vtc.size) {
                el._vtc = undefined
              }
            }
          }

          function nextFrame(cb) {
            requestAnimationFrame(function() {
              requestAnimationFrame(cb)
            })
          }

          var endId = 0

          function whenTransitionEnds(
            el,
            expectedType,
            explicitTimeout,
            resolve
          ) {
            var id = (el._endId = ++endId)

            var resolveIfNotStale = function resolveIfNotStale() {
              if (id === el._endId) {
                resolve()
              }
            }

            if (explicitTimeout) {
              return setTimeout(resolveIfNotStale, explicitTimeout)
            }

            var _getTransitionInfo = getTransitionInfo(el, expectedType),
              type = _getTransitionInfo.type,
              timeout = _getTransitionInfo.timeout,
              propCount = _getTransitionInfo.propCount

            if (!type) {
              return resolve()
            }

            var endEvent = type + 'end'
            var ended = 0

            var end = function end() {
              el.removeEventListener(endEvent, onEnd)
              resolveIfNotStale()
            }

            var onEnd = function onEnd(e) {
              if (e.target === el && ++ended >= propCount) {
                end()
              }
            }

            setTimeout(function() {
              if (ended < propCount) {
                end()
              }
            }, timeout + 1)
            el.addEventListener(endEvent, onEnd)
          }

          function getTransitionInfo(el, expectedType) {
            var styles = window.getComputedStyle(el) // JSDOM may return undefined for transition properties

            var getStyleProperties = function getStyleProperties(key) {
              return (styles[key] || '').split(', ')
            }

            var transitionDelays = getStyleProperties(TRANSITION + 'Delay')
            var transitionDurations = getStyleProperties(
              TRANSITION + 'Duration'
            )
            var transitionTimeout = getTimeout(
              transitionDelays,
              transitionDurations
            )
            var animationDelays = getStyleProperties(ANIMATION + 'Delay')
            var animationDurations = getStyleProperties(ANIMATION + 'Duration')
            var animationTimeout = getTimeout(
              animationDelays,
              animationDurations
            )
            var type = null
            var timeout = 0
            var propCount = 0
            /* istanbul ignore if */

            if (expectedType === TRANSITION) {
              if (transitionTimeout > 0) {
                type = TRANSITION
                timeout = transitionTimeout
                propCount = transitionDurations.length
              }
            } else if (expectedType === ANIMATION) {
              if (animationTimeout > 0) {
                type = ANIMATION
                timeout = animationTimeout
                propCount = animationDurations.length
              }
            } else {
              timeout = Math.max(transitionTimeout, animationTimeout)
              type =
                timeout > 0
                  ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                  : null
              propCount = type
                ? type === TRANSITION
                  ? transitionDurations.length
                  : animationDurations.length
                : 0
            }

            var hasTransform =
              type === TRANSITION &&
              /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property'])
            return {
              type: type,
              timeout: timeout,
              propCount: propCount,
              hasTransform: hasTransform
            }
          }

          function getTimeout(delays, durations) {
            while (delays.length < durations.length) {
              delays = delays.concat(delays)
            }

            return Math.max.apply(
              Math,
              _toConsumableArray(
                durations.map(function(d, i) {
                  return toMs(d) + toMs(delays[i])
                })
              )
            )
          } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
          // numbers in a locale-dependent way, using a comma instead of a dot.
          // If comma is not replaced with a dot, the input will be rounded down
          // (i.e. acting as a floor function) causing unexpected behaviors

          function toMs(s) {
            return Number(s.slice(0, -1).replace(',', '.')) * 1000
          } // synchronously force layout to put elements into a certain state

          function forceReflow() {
            return document.body.offsetHeight
          }

          var positionMap = new WeakMap()
          var newPositionMap = new WeakMap()
          var TransitionGroupImpl = {
            name: 'TransitionGroup',
            props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {
              tag: String,
              moveClass: String
            }),
            setup: function setup(props, _ref29) {
              var slots = _ref29.slots
              var instance = getCurrentInstance()
              var state = useTransitionState()
              var prevChildren
              var children
              onUpdated(function() {
                // children is guaranteed to exist after initial render
                if (!prevChildren.length) {
                  return
                }

                var moveClass =
                  props.moveClass || ''.concat(props.name || 'v', '-move')

                if (
                  !hasCSSTransform(
                    prevChildren[0].el,
                    instance.vnode.el,
                    moveClass
                  )
                ) {
                  return
                } // we divide the work into three loops to avoid mixing DOM reads and writes
                // in each iteration - which helps prevent layout thrashing.

                prevChildren.forEach(callPendingCbs)
                prevChildren.forEach(recordPosition)
                var movedChildren = prevChildren.filter(applyTranslation) // force reflow to put everything in position

                forceReflow()
                movedChildren.forEach(function(c) {
                  var el = c.el
                  var style = el.style
                  addTransitionClass(el, moveClass)
                  style.transform = style.webkitTransform = style.transitionDuration =
                    ''

                  var cb = (el._moveCb = function(e) {
                    if (e && e.target !== el) {
                      return
                    }

                    if (!e || /transform$/.test(e.propertyName)) {
                      el.removeEventListener('transitionend', cb)
                      el._moveCb = null
                      removeTransitionClass(el, moveClass)
                    }
                  })

                  el.addEventListener('transitionend', cb)
                })
              })
              return function() {
                var rawProps = toRaw(props)
                var cssTransitionProps = resolveTransitionProps(rawProps)
                var tag = rawProps.tag || Fragment
                prevChildren = children
                children = slots['default']
                  ? getTransitionRawChildren(slots['default']())
                  : []

                for (var i = 0; i < children.length; i++) {
                  var child = children[i]

                  if (child.key != null) {
                    setTransitionHooks(
                      child,
                      resolveTransitionHooks(
                        child,
                        cssTransitionProps,
                        state,
                        instance
                      )
                    )
                  } else {
                    warn('<TransitionGroup> children must be keyed.')
                  }
                }

                if (prevChildren) {
                  for (var _i6 = 0; _i6 < prevChildren.length; _i6++) {
                    var _child = prevChildren[_i6]
                    setTransitionHooks(
                      _child,
                      resolveTransitionHooks(
                        _child,
                        cssTransitionProps,
                        state,
                        instance
                      )
                    )
                    positionMap.set(_child, _child.el.getBoundingClientRect())
                  }
                }

                return createVNode(tag, null, children)
              }
            }
          }
          var TransitionGroup = TransitionGroupImpl

          function callPendingCbs(c) {
            var el = c.el

            if (el._moveCb) {
              el._moveCb()
            }

            if (el._enterCb) {
              el._enterCb()
            }
          }

          function recordPosition(c) {
            newPositionMap.set(c, c.el.getBoundingClientRect())
          }

          function applyTranslation(c) {
            var oldPos = positionMap.get(c)
            var newPos = newPositionMap.get(c)
            var dx = oldPos.left - newPos.left
            var dy = oldPos.top - newPos.top

            if (dx || dy) {
              var s = c.el.style
              s.transform = s.webkitTransform = 'translate('
                .concat(dx, 'px,')
                .concat(dy, 'px)')
              s.transitionDuration = '0s'
              return c
            }
          }

          function hasCSSTransform(el, root, moveClass) {
            // Detect whether an element with the move class applied has
            // CSS transitions. Since the element may be inside an entering
            // transition at this very moment, we make a clone of it and remove
            // all other transition classes applied to ensure only the move class
            // is applied.
            var clone = el.cloneNode()

            if (el._vtc) {
              el._vtc.forEach(function(cls) {
                cls.split(/\s+/).forEach(function(c) {
                  return c && clone.classList.remove(c)
                })
              })
            }

            moveClass.split(/\s+/).forEach(function(c) {
              return c && clone.classList.add(c)
            })
            clone.style.display = 'none'
            var container = root.nodeType === 1 ? root : root.parentNode
            container.appendChild(clone)

            var _getTransitionInfo2 = getTransitionInfo(clone),
              hasTransform = _getTransitionInfo2.hasTransform

            container.removeChild(clone)
            return hasTransform
          }

          var getModelAssigner = function getModelAssigner(vnode) {
            var fn = vnode.props['onUpdate:modelValue']
            return isArray(fn)
              ? function(value) {
                  return invokeArrayFns(fn, value)
                }
              : fn
          }

          function onCompositionStart(e) {
            e.target.composing = true
          }

          function onCompositionEnd(e) {
            var target = e.target

            if (target.composing) {
              target.composing = false
              trigger$1(target, 'input')
            }
          }

          function trigger$1(el, type) {
            var e = document.createEvent('HTMLEvents')
            e.initEvent(type, true, true)
            el.dispatchEvent(e)
          } // We are exporting the v-model runtime directly as vnode hooks so that it can
          // be tree-shaken in case v-model is never used.

          var vModelText = {
            created: function created(el, _ref30, vnode) {
              var _ref30$modifiers = _ref30.modifiers,
                lazy = _ref30$modifiers.lazy,
                trim = _ref30$modifiers.trim,
                number = _ref30$modifiers.number
              el._assign = getModelAssigner(vnode)
              var castToNumber = number || el.type === 'number'
              addEventListener(el, lazy ? 'change' : 'input', function(e) {
                if (e.target.composing) return
                var domValue = el.value

                if (trim) {
                  domValue = domValue.trim()
                } else if (castToNumber) {
                  domValue = toNumber(domValue)
                }

                el._assign(domValue)
              })

              if (trim) {
                addEventListener(el, 'change', function() {
                  el.value = el.value.trim()
                })
              }

              if (!lazy) {
                addEventListener(el, 'compositionstart', onCompositionStart)
                addEventListener(el, 'compositionend', onCompositionEnd) // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.

                addEventListener(el, 'change', onCompositionEnd)
              }
            },
            // set value on mounted so it's after min/max for type="range"
            mounted: function mounted(el, _ref31) {
              var value = _ref31.value
              el.value = value == null ? '' : value
            },
            beforeUpdate: function beforeUpdate(el, _ref32, vnode) {
              var value = _ref32.value,
                _ref32$modifiers = _ref32.modifiers,
                trim = _ref32$modifiers.trim,
                number = _ref32$modifiers.number
              el._assign = getModelAssigner(vnode) // avoid clearing unresolved text. #2302

              if (el.composing) return

              if (document.activeElement === el) {
                if (trim && el.value.trim() === value) {
                  return
                }

                if (
                  (number || el.type === 'number') &&
                  toNumber(el.value) === value
                ) {
                  return
                }
              }

              var newValue = value == null ? '' : value

              if (el.value !== newValue) {
                el.value = newValue
              }
            }
          }
          var vModelCheckbox = {
            created: function created(el, _, vnode) {
              el._assign = getModelAssigner(vnode)
              addEventListener(el, 'change', function() {
                var modelValue = el._modelValue
                var elementValue = getValue(el)
                var checked = el.checked
                var assign = el._assign

                if (isArray(modelValue)) {
                  var index = looseIndexOf(modelValue, elementValue)
                  var found = index !== -1

                  if (checked && !found) {
                    assign(modelValue.concat(elementValue))
                  } else if (!checked && found) {
                    var filtered = _toConsumableArray(modelValue)

                    filtered.splice(index, 1)
                    assign(filtered)
                  }
                } else if (isSet(modelValue)) {
                  var cloned = new Set(modelValue)

                  if (checked) {
                    cloned.add(elementValue)
                  } else {
                    cloned['delete'](elementValue)
                  }

                  assign(cloned)
                } else {
                  assign(getCheckboxValue(el, checked))
                }
              })
            },
            // set initial checked on mount to wait for true-value/false-value
            mounted: setChecked,
            beforeUpdate: function beforeUpdate(el, binding, vnode) {
              el._assign = getModelAssigner(vnode)
              setChecked(el, binding, vnode)
            }
          }

          function setChecked(el, _ref33, vnode) {
            var value = _ref33.value,
              oldValue = _ref33.oldValue
            el._modelValue = value

            if (isArray(value)) {
              el.checked = looseIndexOf(value, vnode.props.value) > -1
            } else if (isSet(value)) {
              el.checked = value.has(vnode.props.value)
            } else if (value !== oldValue) {
              el.checked = looseEqual(value, getCheckboxValue(el, true))
            }
          }

          var vModelRadio = {
            created: function created(el, _ref34, vnode) {
              var value = _ref34.value
              el.checked = looseEqual(value, vnode.props.value)
              el._assign = getModelAssigner(vnode)
              addEventListener(el, 'change', function() {
                el._assign(getValue(el))
              })
            },
            beforeUpdate: function beforeUpdate(el, _ref35, vnode) {
              var value = _ref35.value,
                oldValue = _ref35.oldValue
              el._assign = getModelAssigner(vnode)

              if (value !== oldValue) {
                el.checked = looseEqual(value, vnode.props.value)
              }
            }
          }
          var vModelSelect = {
            created: function created(el, _ref36, vnode) {
              var value = _ref36.value,
                number = _ref36.modifiers.number
              var isSetModel = isSet(value)
              addEventListener(el, 'change', function() {
                var selectedVal = Array.prototype.filter
                  .call(el.options, function(o) {
                    return o.selected
                  })
                  .map(function(o) {
                    return number ? toNumber(getValue(o)) : getValue(o)
                  })

                el._assign(
                  el.multiple
                    ? isSetModel
                      ? new Set(selectedVal)
                      : selectedVal
                    : selectedVal[0]
                )
              })
              el._assign = getModelAssigner(vnode)
            },
            // set value in mounted & updated because <select> relies on its children
            // <option>s.
            mounted: function mounted(el, _ref37) {
              var value = _ref37.value
              setSelected(el, value)
            },
            beforeUpdate: function beforeUpdate(el, _binding, vnode) {
              el._assign = getModelAssigner(vnode)
            },
            updated: function updated(el, _ref38) {
              var value = _ref38.value
              setSelected(el, value)
            }
          }

          function setSelected(el, value) {
            var isMultiple = el.multiple

            if (isMultiple && !isArray(value) && !isSet(value)) {
              warn(
                '<select multiple v-model> expects an Array or Set value for its binding, ' +
                  'but got '.concat(
                    Object.prototype.toString.call(value).slice(8, -1),
                    '.'
                  )
              )
              return
            }

            for (var i = 0, l = el.options.length; i < l; i++) {
              var option = el.options[i]
              var optionValue = getValue(option)

              if (isMultiple) {
                if (isArray(value)) {
                  option.selected = looseIndexOf(value, optionValue) > -1
                } else {
                  option.selected = value.has(optionValue)
                }
              } else {
                if (looseEqual(getValue(option), value)) {
                  el.selectedIndex = i
                  return
                }
              }
            }

            if (!isMultiple) {
              el.selectedIndex = -1
            }
          } // retrieve raw value set via :value bindings

          function getValue(el) {
            return '_value' in el ? el._value : el.value
          } // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings

          function getCheckboxValue(el, checked) {
            var key = checked ? '_trueValue' : '_falseValue'
            return key in el ? el[key] : checked
          }

          var vModelDynamic = {
            created: function created(el, binding, vnode) {
              callModelHook(el, binding, vnode, null, 'created')
            },
            mounted: function mounted(el, binding, vnode) {
              callModelHook(el, binding, vnode, null, 'mounted')
            },
            beforeUpdate: function beforeUpdate(el, binding, vnode, prevVNode) {
              callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate')
            },
            updated: function updated(el, binding, vnode, prevVNode) {
              callModelHook(el, binding, vnode, prevVNode, 'updated')
            }
          }

          function callModelHook(el, binding, vnode, prevVNode, hook) {
            var modelToUse

            switch (el.tagName) {
              case 'SELECT':
                modelToUse = vModelSelect
                break

              case 'TEXTAREA':
                modelToUse = vModelText
                break

              default:
                switch (vnode.props && vnode.props.type) {
                  case 'checkbox':
                    modelToUse = vModelCheckbox
                    break

                  case 'radio':
                    modelToUse = vModelRadio
                    break

                  default:
                    modelToUse = vModelText
                }
            }

            var fn = modelToUse[hook]
            fn && fn(el, binding, vnode, prevVNode)
          }

          var systemModifiers = ['ctrl', 'shift', 'alt', 'meta']
          var modifierGuards = {
            stop: function stop(e) {
              return e.stopPropagation()
            },
            prevent: function prevent(e) {
              return e.preventDefault()
            },
            self: function self(e) {
              return e.target !== e.currentTarget
            },
            ctrl: function ctrl(e) {
              return !e.ctrlKey
            },
            shift: function shift(e) {
              return !e.shiftKey
            },
            alt: function alt(e) {
              return !e.altKey
            },
            meta: function meta(e) {
              return !e.metaKey
            },
            left: function left(e) {
              return 'button' in e && e.button !== 0
            },
            middle: function middle(e) {
              return 'button' in e && e.button !== 1
            },
            right: function right(e) {
              return 'button' in e && e.button !== 2
            },
            exact: function exact(e, modifiers) {
              return systemModifiers.some(function(m) {
                return e[''.concat(m, 'Key')] && !modifiers.includes(m)
              })
            }
          }
          /**
           * @private
           */

          var withModifiers = function withModifiers(fn, modifiers) {
            return function(event) {
              for (var i = 0; i < modifiers.length; i++) {
                var guard = modifierGuards[modifiers[i]]
                if (guard && guard(event, modifiers)) return
              }

              for (
                var _len10 = arguments.length,
                  args = new Array(_len10 > 1 ? _len10 - 1 : 0),
                  _key22 = 1;
                _key22 < _len10;
                _key22++
              ) {
                args[_key22 - 1] = arguments[_key22]
              }

              return fn.apply(void 0, [event].concat(args))
            }
          } // Kept for 2.x compat.
          // Note: IE11 compat for `spacebar` and `del` is removed for now.

          var keyNames = {
            esc: 'escape',
            space: ' ',
            up: 'arrow-up',
            left: 'arrow-left',
            right: 'arrow-right',
            down: 'arrow-down',
            delete: 'backspace'
          }
          /**
           * @private
           */

          var withKeys = function withKeys(fn, modifiers) {
            return function(event) {
              if (!('key' in event)) return
              var eventKey = hyphenate(event.key)

              if (
                // None of the provided key modifiers match the current event key
                !modifiers.some(function(k) {
                  return k === eventKey || keyNames[k] === eventKey
                })
              ) {
                return
              }

              return fn(event)
            }
          }

          var vShow = {
            beforeMount: function beforeMount(el, _ref39, _ref40) {
              var value = _ref39.value
              var transition = _ref40.transition
              el._vod = el.style.display === 'none' ? '' : el.style.display

              if (transition && value) {
                transition.beforeEnter(el)
              } else {
                setDisplay(el, value)
              }
            },
            mounted: function mounted(el, _ref41, _ref42) {
              var value = _ref41.value
              var transition = _ref42.transition

              if (transition && value) {
                transition.enter(el)
              }
            },
            updated: function updated(el, _ref43, _ref44) {
              var value = _ref43.value,
                oldValue = _ref43.oldValue
              var transition = _ref44.transition

              if (transition && value !== oldValue) {
                if (value) {
                  transition.beforeEnter(el)
                  setDisplay(el, true)
                  transition.enter(el)
                } else {
                  transition.leave(el, function() {
                    setDisplay(el, false)
                  })
                }
              } else {
                setDisplay(el, value)
              }
            },
            beforeUnmount: function beforeUnmount(el, _ref45) {
              var value = _ref45.value
              setDisplay(el, value)
            }
          }

          function setDisplay(el, value) {
            el.style.display = value ? el._vod : 'none'
          }

          var rendererOptions = extend(
            {
              patchProp: patchProp,
              forcePatchProp: forcePatchProp
            },
            nodeOps
          ) // lazy create the renderer - this makes core renderer logic tree-shakable
          // in case the user only imports reactivity utilities from Vue.

          var renderer
          var enabledHydration = false

          function ensureRenderer() {
            return renderer || (renderer = createRenderer(rendererOptions))
          }

          function ensureHydrationRenderer() {
            renderer = enabledHydration
              ? renderer
              : createHydrationRenderer(rendererOptions)
            enabledHydration = true
            return renderer
          } // use explicit type casts here to avoid import() calls in rolled-up d.ts

          var render = function render() {
            var _ensureRenderer

            ;(_ensureRenderer = ensureRenderer()).render.apply(
              _ensureRenderer,
              arguments
            )
          }

          var hydrate = function hydrate() {
            var _ensureHydrationRende

            ;(_ensureHydrationRende = ensureHydrationRenderer()).hydrate.apply(
              _ensureHydrationRende,
              arguments
            )
          }

          var createApp = function createApp() {
            var _ensureRenderer2

            var app = (_ensureRenderer2 = ensureRenderer()).createApp.apply(
              _ensureRenderer2,
              arguments
            )

            {
              injectNativeTagCheck(app)
              injectCustomElementCheck(app)
            }
            var mount = app.mount

            app.mount = function(containerOrSelector) {
              var container = normalizeContainer(containerOrSelector)
              if (!container) return
              var component = app._component

              if (
                !isFunction(component) &&
                !component.render &&
                !component.template
              ) {
                component.template = container.innerHTML
              } // clear content before mounting

              container.innerHTML = ''
              var proxy = mount(container)

              if (container instanceof Element) {
                container.removeAttribute('v-cloak')
                container.setAttribute('data-v-app', '')
              }

              return proxy
            }

            return app
          }

          var createSSRApp = function createSSRApp() {
            var _ensureHydrationRende2

            var app = (_ensureHydrationRende2 = ensureHydrationRenderer()).createApp.apply(
              _ensureHydrationRende2,
              arguments
            )

            {
              injectNativeTagCheck(app)
              injectCustomElementCheck(app)
            }
            var mount = app.mount

            app.mount = function(containerOrSelector) {
              var container = normalizeContainer(containerOrSelector)

              if (container) {
                return mount(container, true)
              }
            }

            return app
          }

          function injectNativeTagCheck(app) {
            // Inject `isNativeTag`
            // this is used for component name validation (dev only)
            Object.defineProperty(app.config, 'isNativeTag', {
              value: function value(tag) {
                return isHTMLTag(tag) || isSVGTag(tag)
              },
              writable: false
            })
          } // dev only

          function injectCustomElementCheck(app) {
            if (isRuntimeOnly()) {
              var value = app.config.isCustomElement
              Object.defineProperty(app.config, 'isCustomElement', {
                get: function get() {
                  return value
                },
                set: function set() {
                  warn(
                    'The `isCustomElement` config option is only respected when using the runtime compiler.' +
                      'If you are using the runtime-only build, `isCustomElement` must be passed to `@vue/compiler-dom` in the build setup instead' +
                      '- for example, via the `compilerOptions` option in vue-loader: https://vue-loader.vuejs.org/options.html#compileroptions.'
                  )
                }
              })
            }
          }

          function normalizeContainer(container) {
            if (isString(container)) {
              var res = document.querySelector(container)

              if (!res) {
                warn(
                  'Failed to mount app: mount target selector "'.concat(
                    container,
                    '" returned null.'
                  )
                )
              }

              return res
            }

            if (
              container instanceof window.ShadowRoot &&
              container.mode === 'closed'
            ) {
              warn(
                'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
              )
            }

            return container
          }

          function initDev() {
            {
              {
                console.info(
                  'You are running a development build of Vue.\n' +
                    'Make sure to use the production build (*.prod.js) when deploying for production.'
                )
              }
              initCustomFormatter()
            }
          } // This entry exports the runtime only, and is built as

          {
            initDev()
          }

          var compile$1 = function compile$1() {
            {
              warn(
                'Runtime compilation is not supported in this build of Vue.' +
                  ' Use "vue.esm-browser.js" instead.'
                /* should not happen */
              )
            }
          }

          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../node_modules/_webpack@4.46.0@webpack/buildin/global.js */ './node_modules/_webpack@4.46.0@webpack/buildin/global.js'
          )
        ))

        /***/
      },

    /***/ './dist/vue.runtime.esm-bundler.js':
      /*!*****************************************!*\
  !*** ./dist/vue.runtime.esm-bundler.js ***!
  \*****************************************/
      /*! exports provided: customRef, isProxy, isReactive, isReadonly, isRef, markRaw, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, camelize, capitalize, toDisplayString, toHandlerKey, BaseTransition, Comment, Fragment, KeepAlive, Static, Suspense, Teleport, Text, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, computed, createBlock, createCommentVNode, createHydrationRenderer, createRenderer, createSlots, createStaticVNode, createTextVNode, createVNode, defineAsyncComponent, defineComponent, defineEmit, defineProps, devtools, getCurrentInstance, getTransitionRawChildren, h, handleError, initCustomFormatter, inject, isVNode, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, openBlock, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useContext, useSSRContext, useTransitionState, version, warn, watch, watchEffect, withCtx, withDirectives, withScopeId, Transition, TransitionGroup, createApp, createSSRApp, hydrate, render, useCssModule, useCssVars, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, withKeys, withModifiers, compile */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        'use strict'
        __webpack_require__.r(__webpack_exports__)
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'compile',
          function() {
            return compile
          }
        )
        /* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @vue/runtime-dom */ './node_modules/_@vue_runtime-dom@3.0.6@@vue/runtime-dom/dist/runtime-dom.esm-bundler.js'
        )
        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'customRef',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['customRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isProxy',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['isProxy']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isReactive',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['isReactive']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isReadonly',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['isReadonly']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isRef',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['isRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'markRaw',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['markRaw']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'proxyRefs',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['proxyRefs']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'reactive',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['reactive']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'readonly',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['readonly']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'ref',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['ref']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowReactive',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'shallowReactive'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowReadonly',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'shallowReadonly'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowRef',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['shallowRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toRaw',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['toRaw']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toRef',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['toRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toRefs',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['toRefs']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'triggerRef',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['triggerRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'unref',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['unref']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'camelize',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['camelize']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'capitalize',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['capitalize']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toDisplayString',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'toDisplayString'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toHandlerKey',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['toHandlerKey']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'BaseTransition',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'BaseTransition'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Comment',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['Comment']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Fragment',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['Fragment']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'KeepAlive',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['KeepAlive']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Static',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['Static']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Suspense',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['Suspense']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Teleport',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['Teleport']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Text',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['Text']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'callWithAsyncErrorHandling',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'callWithAsyncErrorHandling'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'callWithErrorHandling',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'callWithErrorHandling'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'cloneVNode',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['cloneVNode']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'computed',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['computed']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createBlock',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['createBlock']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createCommentVNode',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'createCommentVNode'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createHydrationRenderer',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'createHydrationRenderer'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createRenderer',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'createRenderer'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createSlots',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['createSlots']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createStaticVNode',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'createStaticVNode'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createTextVNode',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'createTextVNode'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createVNode',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['createVNode']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'defineAsyncComponent',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'defineAsyncComponent'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'defineComponent',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'defineComponent'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'defineEmit',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['defineEmit']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'defineProps',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['defineProps']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'devtools',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['devtools']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'getCurrentInstance',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'getCurrentInstance'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'getTransitionRawChildren',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'getTransitionRawChildren'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'h',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['h']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'handleError',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['handleError']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'initCustomFormatter',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'initCustomFormatter'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'inject',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['inject']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isVNode',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['isVNode']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'mergeProps',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['mergeProps']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'nextTick',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['nextTick']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onActivated',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['onActivated']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onBeforeMount',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'onBeforeMount'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onBeforeUnmount',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'onBeforeUnmount'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onBeforeUpdate',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'onBeforeUpdate'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onDeactivated',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'onDeactivated'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onErrorCaptured',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'onErrorCaptured'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onMounted',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['onMounted']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onRenderTracked',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'onRenderTracked'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onRenderTriggered',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'onRenderTriggered'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onUnmounted',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['onUnmounted']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onUpdated',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['onUpdated']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'openBlock',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['openBlock']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'popScopeId',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['popScopeId']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'provide',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['provide']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'pushScopeId',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['pushScopeId']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'queuePostFlushCb',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'queuePostFlushCb'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'registerRuntimeCompiler',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'registerRuntimeCompiler'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'renderList',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['renderList']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'renderSlot',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['renderSlot']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'resolveComponent',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'resolveComponent'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'resolveDirective',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'resolveDirective'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'resolveDynamicComponent',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'resolveDynamicComponent'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'resolveTransitionHooks',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'resolveTransitionHooks'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'setBlockTracking',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'setBlockTracking'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'setDevtoolsHook',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'setDevtoolsHook'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'setTransitionHooks',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'setTransitionHooks'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'ssrContextKey',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'ssrContextKey'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'ssrUtils',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['ssrUtils']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toHandlers',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['toHandlers']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'transformVNodeArgs',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'transformVNodeArgs'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'useContext',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['useContext']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'useSSRContext',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'useSSRContext'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'useTransitionState',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'useTransitionState'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'version',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['version']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'warn',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['warn']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'watch',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['watch']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'watchEffect',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['watchEffect']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'withCtx',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['withCtx']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'withDirectives',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'withDirectives'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'withScopeId',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['withScopeId']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Transition',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['Transition']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'TransitionGroup',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'TransitionGroup'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createApp',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['createApp']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createSSRApp',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['createSSRApp']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'hydrate',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['hydrate']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'render',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['render']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'useCssModule',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['useCssModule']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'useCssVars',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['useCssVars']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelCheckbox',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'vModelCheckbox'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelDynamic',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'vModelDynamic'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelRadio',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['vModelRadio']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelSelect',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['vModelSelect']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelText',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['vModelText']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'vShow',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['vShow']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'withKeys',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['withKeys']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'withModifiers',
          function() {
            return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
              'withModifiers'
            ]
          }
        )

        function initDev() {
          {
            Object(
              _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[
                'initCustomFormatter'
              ]
            )()
          }
        } // This entry exports the runtime only, and is built as

        if (true) {
          initDev()
        }

        var compile = function compile() {
          if (true) {
            Object(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__['warn'])(
              'Runtime compilation is not supported in this build of Vue.' +
                ' Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
              /* should not happen */
            )
          }
        }

        /***/
      },

    /***/ './node_modules/_@vue_reactivity@3.0.6@@vue/reactivity/dist/reactivity.esm-bundler.js':
      /*!********************************************************************************************!*\
  !*** ./node_modules/_@vue_reactivity@3.0.6@@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \********************************************************************************************/
      /*! exports provided: ITERATE_KEY, computed, customRef, effect, enableTracking, isProxy, isReactive, isReadonly, isRef, markRaw, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        'use strict'
        __webpack_require__.r(__webpack_exports__)
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'ITERATE_KEY',
          function() {
            return ITERATE_KEY
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'computed',
          function() {
            return computed
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'customRef',
          function() {
            return customRef
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'effect',
          function() {
            return effect
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'enableTracking',
          function() {
            return enableTracking
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'isProxy',
          function() {
            return isProxy
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'isReactive',
          function() {
            return isReactive
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'isReadonly',
          function() {
            return isReadonly
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'isRef',
          function() {
            return isRef
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'markRaw',
          function() {
            return markRaw
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'pauseTracking',
          function() {
            return pauseTracking
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'proxyRefs',
          function() {
            return proxyRefs
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'reactive',
          function() {
            return reactive
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'readonly',
          function() {
            return readonly
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'ref',
          function() {
            return ref
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'resetTracking',
          function() {
            return resetTracking
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowReactive',
          function() {
            return shallowReactive
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowReadonly',
          function() {
            return shallowReadonly
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowRef',
          function() {
            return shallowRef
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'stop',
          function() {
            return stop
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'toRaw',
          function() {
            return toRaw
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'toRef',
          function() {
            return toRef
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'toRefs',
          function() {
            return toRefs
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'track',
          function() {
            return track
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'trigger',
          function() {
            return trigger
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'triggerRef',
          function() {
            return triggerRef
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'unref',
          function() {
            return unref
          }
        )
        /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @vue/shared */ './node_modules/_@vue_shared@3.0.6@@vue/shared/dist/shared.esm-bundler.js'
        )

        const targetMap = new WeakMap()
        const effectStack = []
        let activeEffect
        const ITERATE_KEY = Symbol(true ? 'iterate' : undefined)
        const MAP_KEY_ITERATE_KEY = Symbol(true ? 'Map key iterate' : undefined)
        function isEffect(fn) {
          return fn && fn._isEffect === true
        }
        function effect(
          fn,
          options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__['EMPTY_OBJ']
        ) {
          if (isEffect(fn)) {
            fn = fn.raw
          }
          const effect = createReactiveEffect(fn, options)
          if (!options.lazy) {
            effect()
          }
          return effect
        }
        function stop(effect) {
          if (effect.active) {
            cleanup(effect)
            if (effect.options.onStop) {
              effect.options.onStop()
            }
            effect.active = false
          }
        }
        let uid = 0
        function createReactiveEffect(fn, options) {
          const effect = function reactiveEffect() {
            if (!effect.active) {
              return options.scheduler ? undefined : fn()
            }
            if (!effectStack.includes(effect)) {
              cleanup(effect)
              try {
                enableTracking()
                effectStack.push(effect)
                activeEffect = effect
                return fn()
              } finally {
                effectStack.pop()
                resetTracking()
                activeEffect = effectStack[effectStack.length - 1]
              }
            }
          }
          effect.id = uid++
          effect.allowRecurse = !!options.allowRecurse
          effect._isEffect = true
          effect.active = true
          effect.raw = fn
          effect.deps = []
          effect.options = options
          return effect
        }
        function cleanup(effect) {
          const { deps } = effect
          if (deps.length) {
            for (let i = 0; i < deps.length; i++) {
              deps[i].delete(effect)
            }
            deps.length = 0
          }
        }
        let shouldTrack = true
        const trackStack = []
        function pauseTracking() {
          trackStack.push(shouldTrack)
          shouldTrack = false
        }
        function enableTracking() {
          trackStack.push(shouldTrack)
          shouldTrack = true
        }
        function resetTracking() {
          const last = trackStack.pop()
          shouldTrack = last === undefined ? true : last
        }
        function track(target, type, key) {
          if (!shouldTrack || activeEffect === undefined) {
            return
          }
          let depsMap = targetMap.get(target)
          if (!depsMap) {
            targetMap.set(target, (depsMap = new Map()))
          }
          let dep = depsMap.get(key)
          if (!dep) {
            depsMap.set(key, (dep = new Set()))
          }
          if (!dep.has(activeEffect)) {
            dep.add(activeEffect)
            activeEffect.deps.push(dep)
            if (true && activeEffect.options.onTrack) {
              activeEffect.options.onTrack({
                effect: activeEffect,
                target,
                type,
                key
              })
            }
          }
        }
        function trigger(target, type, key, newValue, oldValue, oldTarget) {
          const depsMap = targetMap.get(target)
          if (!depsMap) {
            // never been tracked
            return
          }
          const effects = new Set()
          const add = effectsToAdd => {
            if (effectsToAdd) {
              effectsToAdd.forEach(effect => {
                if (effect !== activeEffect || effect.allowRecurse) {
                  effects.add(effect)
                }
              })
            }
          }
          if (type === 'clear' /* CLEAR */) {
            // collection being cleared
            // trigger all effects for target
            depsMap.forEach(add)
          } else if (
            key === 'length' &&
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isArray'])(target)
          ) {
            depsMap.forEach((dep, key) => {
              if (key === 'length' || key >= newValue) {
                add(dep)
              }
            })
          } else {
            // schedule runs for SET | ADD | DELETE
            if (key !== void 0) {
              add(depsMap.get(key))
            }
            // also run for iteration key on ADD | DELETE | Map.SET
            switch (type) {
              case 'add' /* ADD */:
                if (
                  !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isArray'])(
                    target
                  )
                ) {
                  add(depsMap.get(ITERATE_KEY))
                  if (
                    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isMap'])(
                      target
                    )
                  ) {
                    add(depsMap.get(MAP_KEY_ITERATE_KEY))
                  }
                } else if (
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_0__['isIntegerKey']
                  )(key)
                ) {
                  // new index added to array -> length changes
                  add(depsMap.get('length'))
                }
                break
              case 'delete' /* DELETE */:
                if (
                  !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isArray'])(
                    target
                  )
                ) {
                  add(depsMap.get(ITERATE_KEY))
                  if (
                    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isMap'])(
                      target
                    )
                  ) {
                    add(depsMap.get(MAP_KEY_ITERATE_KEY))
                  }
                }
                break
              case 'set' /* SET */:
                if (
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isMap'])(
                    target
                  )
                ) {
                  add(depsMap.get(ITERATE_KEY))
                }
                break
            }
          }
          const run = effect => {
            if (true && effect.options.onTrigger) {
              effect.options.onTrigger({
                effect,
                target,
                key,
                type,
                newValue,
                oldValue,
                oldTarget
              })
            }
            if (effect.options.scheduler) {
              effect.options.scheduler(effect)
            } else {
              effect()
            }
          }
          effects.forEach(run)
        }

        const isNonTrackableKeys = /*#__PURE__*/ Object(
          _vue_shared__WEBPACK_IMPORTED_MODULE_0__['makeMap']
        )(`__proto__,__v_isRef,__isVue`)
        const builtInSymbols = new Set(
          Object.getOwnPropertyNames(Symbol)
            .map(key => Symbol[key])
            .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isSymbol'])
        )
        const get = /*#__PURE__*/ createGetter()
        const shallowGet = /*#__PURE__*/ createGetter(false, true)
        const readonlyGet = /*#__PURE__*/ createGetter(true)
        const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)
        const arrayInstrumentations = {}
        ;['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
          const method = Array.prototype[key]
          arrayInstrumentations[key] = function(...args) {
            const arr = toRaw(this)
            for (let i = 0, l = this.length; i < l; i++) {
              track(arr, 'get' /* GET */, i + '')
            }
            // we run the method using the original args first (which may be reactive)
            const res = method.apply(arr, args)
            if (res === -1 || res === false) {
              // if that didn't work, run it again using raw values.
              return method.apply(arr, args.map(toRaw))
            } else {
              return res
            }
          }
        })
        ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
          const method = Array.prototype[key]
          arrayInstrumentations[key] = function(...args) {
            pauseTracking()
            const res = method.apply(this, args)
            resetTracking()
            return res
          }
        })
        function createGetter(isReadonly = false, shallow = false) {
          return function get(target, key, receiver) {
            if (key === '__v_isReactive' /* IS_REACTIVE */) {
              return !isReadonly
            } else if (key === '__v_isReadonly' /* IS_READONLY */) {
              return isReadonly
            } else if (
              key === '__v_raw' /* RAW */ &&
              receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)
            ) {
              return target
            }
            const targetIsArray = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_0__['isArray']
            )(target)
            if (
              !isReadonly &&
              targetIsArray &&
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['hasOwn'])(
                arrayInstrumentations,
                key
              )
            ) {
              return Reflect.get(arrayInstrumentations, key, receiver)
            }
            const res = Reflect.get(target, key, receiver)
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isSymbol'])(key)
                ? builtInSymbols.has(key)
                : isNonTrackableKeys(key)
            ) {
              return res
            }
            if (!isReadonly) {
              track(target, 'get' /* GET */, key)
            }
            if (shallow) {
              return res
            }
            if (isRef(res)) {
              // ref unwrapping - does not apply for Array + integer key.
              const shouldUnwrap =
                !targetIsArray ||
                !Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_0__['isIntegerKey']
                )(key)
              return shouldUnwrap ? res.value : res
            }
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isObject'])(res)
            ) {
              // Convert returned value into a proxy as well. we do the isObject check
              // here to avoid invalid value warning. Also need to lazy access readonly
              // and reactive here to avoid circular dependency.
              return isReadonly ? readonly(res) : reactive(res)
            }
            return res
          }
        }
        const set = /*#__PURE__*/ createSetter()
        const shallowSet = /*#__PURE__*/ createSetter(true)
        function createSetter(shallow = false) {
          return function set(target, key, value, receiver) {
            const oldValue = target[key]
            if (!shallow) {
              value = toRaw(value)
              if (
                !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isArray'])(
                  target
                ) &&
                isRef(oldValue) &&
                !isRef(value)
              ) {
                oldValue.value = value
                return true
              }
            }
            const hadKey =
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isArray'])(
                target
              ) &&
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isIntegerKey'])(
                key
              )
                ? Number(key) < target.length
                : Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['hasOwn'])(
                    target,
                    key
                  )
            const result = Reflect.set(target, key, value, receiver)
            // don't trigger if target is something up in the prototype chain of original
            if (target === toRaw(receiver)) {
              if (!hadKey) {
                trigger(target, 'add' /* ADD */, key, value)
              } else if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['hasChanged'])(
                  value,
                  oldValue
                )
              ) {
                trigger(target, 'set' /* SET */, key, value, oldValue)
              }
            }
            return result
          }
        }
        function deleteProperty(target, key) {
          const hadKey = Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_0__['hasOwn']
          )(target, key)
          const oldValue = target[key]
          const result = Reflect.deleteProperty(target, key)
          if (result && hadKey) {
            trigger(target, 'delete' /* DELETE */, key, undefined, oldValue)
          }
          return result
        }
        function has(target, key) {
          const result = Reflect.has(target, key)
          if (
            !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isSymbol'])(
              key
            ) ||
            !builtInSymbols.has(key)
          ) {
            track(target, 'has' /* HAS */, key)
          }
          return result
        }
        function ownKeys(target) {
          track(
            target,
            'iterate' /* ITERATE */,
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isArray'])(target)
              ? 'length'
              : ITERATE_KEY
          )
          return Reflect.ownKeys(target)
        }
        const mutableHandlers = {
          get,
          set,
          deleteProperty,
          has,
          ownKeys
        }
        const readonlyHandlers = {
          get: readonlyGet,
          set(target, key) {
            if (true) {
              console.warn(
                `Set operation on key "${String(
                  key
                )}" failed: target is readonly.`,
                target
              )
            }
            return true
          },
          deleteProperty(target, key) {
            if (true) {
              console.warn(
                `Delete operation on key "${String(
                  key
                )}" failed: target is readonly.`,
                target
              )
            }
            return true
          }
        }
        const shallowReactiveHandlers = Object(
          _vue_shared__WEBPACK_IMPORTED_MODULE_0__['extend']
        )({}, mutableHandlers, {
          get: shallowGet,
          set: shallowSet
        })
        // Props handlers are special in the sense that it should not unwrap top-level
        // refs (in order to allow refs to be explicitly passed down), but should
        // retain the reactivity of the normal readonly object.
        const shallowReadonlyHandlers = Object(
          _vue_shared__WEBPACK_IMPORTED_MODULE_0__['extend']
        )({}, readonlyHandlers, {
          get: shallowReadonlyGet
        })

        const toReactive = value =>
          Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isObject'])(value)
            ? reactive(value)
            : value
        const toReadonly = value =>
          Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isObject'])(value)
            ? readonly(value)
            : value
        const toShallow = value => value
        const getProto = v => Reflect.getPrototypeOf(v)
        function get$1(target, key, isReadonly = false, isShallow = false) {
          // #1772: readonly(reactive(Map)) should return readonly + reactive version
          // of the value
          target = target['__v_raw' /* RAW */]
          const rawTarget = toRaw(target)
          const rawKey = toRaw(key)
          if (key !== rawKey) {
            !isReadonly && track(rawTarget, 'get' /* GET */, key)
          }
          !isReadonly && track(rawTarget, 'get' /* GET */, rawKey)
          const { has } = getProto(rawTarget)
          const wrap = isReadonly
            ? toReadonly
            : isShallow
              ? toShallow
              : toReactive
          if (has.call(rawTarget, key)) {
            return wrap(target.get(key))
          } else if (has.call(rawTarget, rawKey)) {
            return wrap(target.get(rawKey))
          }
        }
        function has$1(key, isReadonly = false) {
          const target = this['__v_raw' /* RAW */]
          const rawTarget = toRaw(target)
          const rawKey = toRaw(key)
          if (key !== rawKey) {
            !isReadonly && track(rawTarget, 'has' /* HAS */, key)
          }
          !isReadonly && track(rawTarget, 'has' /* HAS */, rawKey)
          return key === rawKey
            ? target.has(key)
            : target.has(key) || target.has(rawKey)
        }
        function size(target, isReadonly = false) {
          target = target['__v_raw' /* RAW */]
          !isReadonly &&
            track(toRaw(target), 'iterate' /* ITERATE */, ITERATE_KEY)
          return Reflect.get(target, 'size', target)
        }
        function add(value) {
          value = toRaw(value)
          const target = toRaw(this)
          const proto = getProto(target)
          const hadKey = proto.has.call(target, value)
          target.add(value)
          if (!hadKey) {
            trigger(target, 'add' /* ADD */, value, value)
          }
          return this
        }
        function set$1(key, value) {
          value = toRaw(value)
          const target = toRaw(this)
          const { has, get } = getProto(target)
          let hadKey = has.call(target, key)
          if (!hadKey) {
            key = toRaw(key)
            hadKey = has.call(target, key)
          } else if (true) {
            checkIdentityKeys(target, has, key)
          }
          const oldValue = get.call(target, key)
          target.set(key, value)
          if (!hadKey) {
            trigger(target, 'add' /* ADD */, key, value)
          } else if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['hasChanged'])(
              value,
              oldValue
            )
          ) {
            trigger(target, 'set' /* SET */, key, value, oldValue)
          }
          return this
        }
        function deleteEntry(key) {
          const target = toRaw(this)
          const { has, get } = getProto(target)
          let hadKey = has.call(target, key)
          if (!hadKey) {
            key = toRaw(key)
            hadKey = has.call(target, key)
          } else if (true) {
            checkIdentityKeys(target, has, key)
          }
          const oldValue = get ? get.call(target, key) : undefined
          // forward the operation before queueing reactions
          const result = target.delete(key)
          if (hadKey) {
            trigger(target, 'delete' /* DELETE */, key, undefined, oldValue)
          }
          return result
        }
        function clear() {
          const target = toRaw(this)
          const hadItems = target.size !== 0
          const oldTarget = true
            ? Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isMap'])(target)
              ? new Map(target)
              : new Set(target)
            : undefined
          // forward the operation before queueing reactions
          const result = target.clear()
          if (hadItems) {
            trigger(
              target,
              'clear' /* CLEAR */,
              undefined,
              undefined,
              oldTarget
            )
          }
          return result
        }
        function createForEach(isReadonly, isShallow) {
          return function forEach(callback, thisArg) {
            const observed = this
            const target = observed['__v_raw' /* RAW */]
            const rawTarget = toRaw(target)
            const wrap = isReadonly
              ? toReadonly
              : isShallow
                ? toShallow
                : toReactive
            !isReadonly &&
              track(rawTarget, 'iterate' /* ITERATE */, ITERATE_KEY)
            return target.forEach((value, key) => {
              // important: make sure the callback is
              // 1. invoked with the reactive map as `this` and 3rd arg
              // 2. the value received should be a corresponding reactive/readonly.
              return callback.call(thisArg, wrap(value), wrap(key), observed)
            })
          }
        }
        function createIterableMethod(method, isReadonly, isShallow) {
          return function(...args) {
            const target = this['__v_raw' /* RAW */]
            const rawTarget = toRaw(target)
            const targetIsMap = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_0__['isMap']
            )(rawTarget)
            const isPair =
              method === 'entries' ||
              (method === Symbol.iterator && targetIsMap)
            const isKeyOnly = method === 'keys' && targetIsMap
            const innerIterator = target[method](...args)
            const wrap = isReadonly
              ? toReadonly
              : isShallow
                ? toShallow
                : toReactive
            !isReadonly &&
              track(
                rawTarget,
                'iterate' /* ITERATE */,
                isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
              )
            // return a wrapped iterator which returns observed versions of the
            // values emitted from the real iterator
            return {
              // iterator protocol
              next() {
                const { value, done } = innerIterator.next()
                return done
                  ? { value, done }
                  : {
                      value: isPair
                        ? [wrap(value[0]), wrap(value[1])]
                        : wrap(value),
                      done
                    }
              },
              // iterable protocol
              [Symbol.iterator]() {
                return this
              }
            }
          }
        }
        function createReadonlyMethod(type) {
          return function(...args) {
            if (true) {
              const key = args[0] ? `on key "${args[0]}" ` : ``
              console.warn(
                `${Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_0__['capitalize']
                )(type)} operation ${key}failed: target is readonly.`,
                toRaw(this)
              )
            }
            return type === 'delete' /* DELETE */ ? false : this
          }
        }
        const mutableInstrumentations = {
          get(key) {
            return get$1(this, key)
          },
          get size() {
            return size(this)
          },
          has: has$1,
          add,
          set: set$1,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
        }
        const shallowInstrumentations = {
          get(key) {
            return get$1(this, key, false, true)
          },
          get size() {
            return size(this)
          },
          has: has$1,
          add,
          set: set$1,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
        }
        const readonlyInstrumentations = {
          get(key) {
            return get$1(this, key, true)
          },
          get size() {
            return size(this, true)
          },
          has(key) {
            return has$1.call(this, key, true)
          },
          add: createReadonlyMethod('add' /* ADD */),
          set: createReadonlyMethod('set' /* SET */),
          delete: createReadonlyMethod('delete' /* DELETE */),
          clear: createReadonlyMethod('clear' /* CLEAR */),
          forEach: createForEach(true, false)
        }
        const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]
        iteratorMethods.forEach(method => {
          mutableInstrumentations[method] = createIterableMethod(
            method,
            false,
            false
          )
          readonlyInstrumentations[method] = createIterableMethod(
            method,
            true,
            false
          )
          shallowInstrumentations[method] = createIterableMethod(
            method,
            false,
            true
          )
        })
        function createInstrumentationGetter(isReadonly, shallow) {
          const instrumentations = shallow
            ? shallowInstrumentations
            : isReadonly
              ? readonlyInstrumentations
              : mutableInstrumentations
          return (target, key, receiver) => {
            if (key === '__v_isReactive' /* IS_REACTIVE */) {
              return !isReadonly
            } else if (key === '__v_isReadonly' /* IS_READONLY */) {
              return isReadonly
            } else if (key === '__v_raw' /* RAW */) {
              return target
            }
            return Reflect.get(
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['hasOwn'])(
                instrumentations,
                key
              ) && key in target
                ? instrumentations
                : target,
              key,
              receiver
            )
          }
        }
        const mutableCollectionHandlers = {
          get: createInstrumentationGetter(false, false)
        }
        const shallowCollectionHandlers = {
          get: createInstrumentationGetter(false, true)
        }
        const readonlyCollectionHandlers = {
          get: createInstrumentationGetter(true, false)
        }
        function checkIdentityKeys(target, has, key) {
          const rawKey = toRaw(key)
          if (rawKey !== key && has.call(target, rawKey)) {
            const type = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_0__['toRawType']
            )(target)
            console.warn(
              `Reactive ${type} contains both the raw and reactive ` +
                `versions of the same object${
                  type === `Map` ? ` as keys` : ``
                }, ` +
                `which can lead to inconsistencies. ` +
                `Avoid differentiating between the raw and reactive versions ` +
                `of an object and only use the reactive version if possible.`
            )
          }
        }

        const reactiveMap = new WeakMap()
        const readonlyMap = new WeakMap()
        function targetTypeMap(rawType) {
          switch (rawType) {
            case 'Object':
            case 'Array':
              return 1 /* COMMON */
            case 'Map':
            case 'Set':
            case 'WeakMap':
            case 'WeakSet':
              return 2 /* COLLECTION */
            default:
              return 0 /* INVALID */
          }
        }
        function getTargetType(value) {
          return value['__v_skip' /* SKIP */] || !Object.isExtensible(value)
            ? 0 /* INVALID */
            : targetTypeMap(
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['toRawType'])(
                  value
                )
              )
        }
        function reactive(target) {
          // if trying to observe a readonly proxy, return the readonly version.
          if (target && target['__v_isReadonly' /* IS_READONLY */]) {
            return target
          }
          return createReactiveObject(
            target,
            false,
            mutableHandlers,
            mutableCollectionHandlers
          )
        }
        /**
         * Return a shallowly-reactive copy of the original object, where only the root
         * level properties are reactive. It also does not auto-unwrap refs (even at the
         * root level).
         */
        function shallowReactive(target) {
          return createReactiveObject(
            target,
            false,
            shallowReactiveHandlers,
            shallowCollectionHandlers
          )
        }
        /**
         * Creates a readonly copy of the original object. Note the returned copy is not
         * made reactive, but `readonly` can be called on an already reactive object.
         */
        function readonly(target) {
          return createReactiveObject(
            target,
            true,
            readonlyHandlers,
            readonlyCollectionHandlers
          )
        }
        /**
         * Returns a reactive-copy of the original object, where only the root level
         * properties are readonly, and does NOT unwrap refs nor recursively convert
         * returned properties.
         * This is used for creating the props proxy object for stateful components.
         */
        function shallowReadonly(target) {
          return createReactiveObject(
            target,
            true,
            shallowReadonlyHandlers,
            readonlyCollectionHandlers
          )
        }
        function createReactiveObject(
          target,
          isReadonly,
          baseHandlers,
          collectionHandlers
        ) {
          if (
            !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isObject'])(
              target
            )
          ) {
            if (true) {
              console.warn(`value cannot be made reactive: ${String(target)}`)
            }
            return target
          }
          // target is already a Proxy, return it.
          // exception: calling readonly() on a reactive object
          if (
            target['__v_raw' /* RAW */] &&
            !(isReadonly && target['__v_isReactive' /* IS_REACTIVE */])
          ) {
            return target
          }
          // target already has corresponding Proxy
          const proxyMap = isReadonly ? readonlyMap : reactiveMap
          const existingProxy = proxyMap.get(target)
          if (existingProxy) {
            return existingProxy
          }
          // only a whitelist of value types can be observed.
          const targetType = getTargetType(target)
          if (targetType === 0 /* INVALID */) {
            return target
          }
          const proxy = new Proxy(
            target,
            targetType === 2 /* COLLECTION */
              ? collectionHandlers
              : baseHandlers
          )
          proxyMap.set(target, proxy)
          return proxy
        }
        function isReactive(value) {
          if (isReadonly(value)) {
            return isReactive(value['__v_raw' /* RAW */])
          }
          return !!(value && value['__v_isReactive' /* IS_REACTIVE */])
        }
        function isReadonly(value) {
          return !!(value && value['__v_isReadonly' /* IS_READONLY */])
        }
        function isProxy(value) {
          return isReactive(value) || isReadonly(value)
        }
        function toRaw(observed) {
          return (observed && toRaw(observed['__v_raw' /* RAW */])) || observed
        }
        function markRaw(value) {
          Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['def'])(
            value,
            '__v_skip' /* SKIP */,
            true
          )
          return value
        }

        const convert = val =>
          Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isObject'])(val)
            ? reactive(val)
            : val
        function isRef(r) {
          return Boolean(r && r.__v_isRef === true)
        }
        function ref(value) {
          return createRef(value)
        }
        function shallowRef(value) {
          return createRef(value, true)
        }
        class RefImpl {
          constructor(_rawValue, _shallow = false) {
            this._rawValue = _rawValue
            this._shallow = _shallow
            this.__v_isRef = true
            this._value = _shallow ? _rawValue : convert(_rawValue)
          }
          get value() {
            track(toRaw(this), 'get' /* GET */, 'value')
            return this._value
          }
          set value(newVal) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['hasChanged'])(
                toRaw(newVal),
                this._rawValue
              )
            ) {
              this._rawValue = newVal
              this._value = this._shallow ? newVal : convert(newVal)
              trigger(toRaw(this), 'set' /* SET */, 'value', newVal)
            }
          }
        }
        function createRef(rawValue, shallow = false) {
          if (isRef(rawValue)) {
            return rawValue
          }
          return new RefImpl(rawValue, shallow)
        }
        function triggerRef(ref) {
          trigger(
            toRaw(ref),
            'set' /* SET */,
            'value',
            true ? ref.value : undefined
          )
        }
        function unref(ref) {
          return isRef(ref) ? ref.value : ref
        }
        const shallowUnwrapHandlers = {
          get: (target, key, receiver) =>
            unref(Reflect.get(target, key, receiver)),
          set: (target, key, value, receiver) => {
            const oldValue = target[key]
            if (isRef(oldValue) && !isRef(value)) {
              oldValue.value = value
              return true
            } else {
              return Reflect.set(target, key, value, receiver)
            }
          }
        }
        function proxyRefs(objectWithRefs) {
          return isReactive(objectWithRefs)
            ? objectWithRefs
            : new Proxy(objectWithRefs, shallowUnwrapHandlers)
        }
        class CustomRefImpl {
          constructor(factory) {
            this.__v_isRef = true
            const { get, set } = factory(
              () => track(this, 'get' /* GET */, 'value'),
              () => trigger(this, 'set' /* SET */, 'value')
            )
            this._get = get
            this._set = set
          }
          get value() {
            return this._get()
          }
          set value(newVal) {
            this._set(newVal)
          }
        }
        function customRef(factory) {
          return new CustomRefImpl(factory)
        }
        function toRefs(object) {
          if (true && !isProxy(object)) {
            console.warn(
              `toRefs() expects a reactive object but received a plain one.`
            )
          }
          const ret = Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_0__['isArray']
          )(object)
            ? new Array(object.length)
            : {}
          for (const key in object) {
            ret[key] = toRef(object, key)
          }
          return ret
        }
        class ObjectRefImpl {
          constructor(_object, _key) {
            this._object = _object
            this._key = _key
            this.__v_isRef = true
          }
          get value() {
            return this._object[this._key]
          }
          set value(newVal) {
            this._object[this._key] = newVal
          }
        }
        function toRef(object, key) {
          return isRef(object[key])
            ? object[key]
            : new ObjectRefImpl(object, key)
        }

        class ComputedRefImpl {
          constructor(getter, _setter, isReadonly) {
            this._setter = _setter
            this._dirty = true
            this.__v_isRef = true
            this.effect = effect(getter, {
              lazy: true,
              scheduler: () => {
                if (!this._dirty) {
                  this._dirty = true
                  trigger(toRaw(this), 'set' /* SET */, 'value')
                }
              }
            })
            this['__v_isReadonly' /* IS_READONLY */] = isReadonly
          }
          get value() {
            if (this._dirty) {
              this._value = this.effect()
              this._dirty = false
            }
            track(toRaw(this), 'get' /* GET */, 'value')
            return this._value
          }
          set value(newValue) {
            this._setter(newValue)
          }
        }
        function computed(getterOrOptions) {
          let getter
          let setter
          if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isFunction'])(
              getterOrOptions
            )
          ) {
            getter = getterOrOptions
            setter = true
              ? () => {
                  console.warn(
                    'Write operation failed: computed value is readonly'
                  )
                }
              : undefined
          } else {
            getter = getterOrOptions.get
            setter = getterOrOptions.set
          }
          return new ComputedRefImpl(
            getter,
            setter,
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__['isFunction'])(
              getterOrOptions
            ) || !getterOrOptions.set
          )
        }

        /***/
      },

    /***/ './node_modules/_@vue_runtime-core@3.0.6@@vue/runtime-core/dist/runtime-core.esm-bundler.js':
      /*!**************************************************************************************************!*\
  !*** ./node_modules/_@vue_runtime-core@3.0.6@@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \**************************************************************************************************/
      /*! exports provided: customRef, isProxy, isReactive, isReadonly, isRef, markRaw, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, camelize, capitalize, toDisplayString, toHandlerKey, BaseTransition, Comment, Fragment, KeepAlive, Static, Suspense, Teleport, Text, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, computed, createBlock, createCommentVNode, createHydrationRenderer, createRenderer, createSlots, createStaticVNode, createTextVNode, createVNode, defineAsyncComponent, defineComponent, defineEmit, defineProps, devtools, getCurrentInstance, getTransitionRawChildren, h, handleError, initCustomFormatter, inject, isVNode, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, openBlock, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useContext, useSSRContext, useTransitionState, version, warn, watch, watchEffect, withCtx, withDirectives, withScopeId */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        'use strict'
        __webpack_require__.r(__webpack_exports__)
        /* WEBPACK VAR INJECTION */ ;(function(global) {
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'BaseTransition',
            function() {
              return BaseTransition
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Comment',
            function() {
              return Comment
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Fragment',
            function() {
              return Fragment
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'KeepAlive',
            function() {
              return KeepAlive
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Static',
            function() {
              return Static
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Suspense',
            function() {
              return Suspense
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Teleport',
            function() {
              return Teleport
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'Text',
            function() {
              return Text
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'callWithAsyncErrorHandling',
            function() {
              return callWithAsyncErrorHandling
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'callWithErrorHandling',
            function() {
              return callWithErrorHandling
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'cloneVNode',
            function() {
              return cloneVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'computed',
            function() {
              return computed
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createBlock',
            function() {
              return createBlock
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createCommentVNode',
            function() {
              return createCommentVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createHydrationRenderer',
            function() {
              return createHydrationRenderer
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createRenderer',
            function() {
              return createRenderer
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createSlots',
            function() {
              return createSlots
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createStaticVNode',
            function() {
              return createStaticVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createTextVNode',
            function() {
              return createTextVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'createVNode',
            function() {
              return createVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defineAsyncComponent',
            function() {
              return defineAsyncComponent
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defineComponent',
            function() {
              return defineComponent
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defineEmit',
            function() {
              return defineEmit
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'defineProps',
            function() {
              return defineProps
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'devtools',
            function() {
              return devtools
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getCurrentInstance',
            function() {
              return getCurrentInstance
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getTransitionRawChildren',
            function() {
              return getTransitionRawChildren
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'h',
            function() {
              return h
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'handleError',
            function() {
              return handleError
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'initCustomFormatter',
            function() {
              return initCustomFormatter
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'inject',
            function() {
              return inject
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isVNode',
            function() {
              return isVNode
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'mergeProps',
            function() {
              return mergeProps
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'nextTick',
            function() {
              return nextTick
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onActivated',
            function() {
              return onActivated
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onBeforeMount',
            function() {
              return onBeforeMount
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onBeforeUnmount',
            function() {
              return onBeforeUnmount
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onBeforeUpdate',
            function() {
              return onBeforeUpdate
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onDeactivated',
            function() {
              return onDeactivated
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onErrorCaptured',
            function() {
              return onErrorCaptured
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onMounted',
            function() {
              return onMounted
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onRenderTracked',
            function() {
              return onRenderTracked
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onRenderTriggered',
            function() {
              return onRenderTriggered
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onUnmounted',
            function() {
              return onUnmounted
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'onUpdated',
            function() {
              return onUpdated
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'openBlock',
            function() {
              return openBlock
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'popScopeId',
            function() {
              return popScopeId
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'provide',
            function() {
              return provide
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'pushScopeId',
            function() {
              return pushScopeId
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'queuePostFlushCb',
            function() {
              return queuePostFlushCb
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'registerRuntimeCompiler',
            function() {
              return registerRuntimeCompiler
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'renderList',
            function() {
              return renderList
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'renderSlot',
            function() {
              return renderSlot
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resolveComponent',
            function() {
              return resolveComponent
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resolveDirective',
            function() {
              return resolveDirective
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resolveDynamicComponent',
            function() {
              return resolveDynamicComponent
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'resolveTransitionHooks',
            function() {
              return resolveTransitionHooks
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'setBlockTracking',
            function() {
              return setBlockTracking
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'setDevtoolsHook',
            function() {
              return setDevtoolsHook
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'setTransitionHooks',
            function() {
              return setTransitionHooks
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ssrContextKey',
            function() {
              return ssrContextKey
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'ssrUtils',
            function() {
              return ssrUtils
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toHandlers',
            function() {
              return toHandlers
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'transformVNodeArgs',
            function() {
              return transformVNodeArgs
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'useContext',
            function() {
              return useContext
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'useSSRContext',
            function() {
              return useSSRContext
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'useTransitionState',
            function() {
              return useTransitionState
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'version',
            function() {
              return version
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'warn',
            function() {
              return warn
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'watch',
            function() {
              return watch
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'watchEffect',
            function() {
              return watchEffect
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'withCtx',
            function() {
              return withCtx
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'withDirectives',
            function() {
              return withDirectives
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'withScopeId',
            function() {
              return withScopeId
            }
          )
          /* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
            /*! @vue/reactivity */ './node_modules/_@vue_reactivity@3.0.6@@vue/reactivity/dist/reactivity.esm-bundler.js'
          )
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'customRef',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['customRef']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isProxy',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isProxy']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isReactive',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isReactive']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isReadonly',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isReadonly']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'isRef',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'markRaw',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['markRaw']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'proxyRefs',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['proxyRefs']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'reactive',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['reactive']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'readonly',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['readonly']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'ref',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['ref']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'shallowReactive',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                'shallowReactive'
              ]
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'shallowReadonly',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                'shallowReadonly'
              ]
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'shallowRef',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['shallowRef']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'toRaw',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'toRef',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRef']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'toRefs',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRefs']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'triggerRef',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['triggerRef']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'unref',
            function() {
              return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['unref']
            }
          )

          /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
            /*! @vue/shared */ './node_modules/_@vue_shared@3.0.6@@vue/shared/dist/shared.esm-bundler.js'
          )
          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'camelize',
            function() {
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'capitalize',
            function() {
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__['capitalize']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'toDisplayString',
            function() {
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toDisplayString']
            }
          )

          /* harmony reexport (safe) */ __webpack_require__.d(
            __webpack_exports__,
            'toHandlerKey',
            function() {
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toHandlerKey']
            }
          )

          const stack = []
          function pushWarningContext(vnode) {
            stack.push(vnode)
          }
          function popWarningContext() {
            stack.pop()
          }
          function warn(msg, ...args) {
            // avoid props formatting or warn handler tracking deps that might be mutated
            // during patch, leading to infinite recursion.
            Object(
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['pauseTracking']
            )()
            const instance = stack.length
              ? stack[stack.length - 1].component
              : null
            const appWarnHandler =
              instance && instance.appContext.config.warnHandler
            const trace = getComponentTrace()
            if (appWarnHandler) {
              callWithErrorHandling(
                appWarnHandler,
                instance,
                11 /* APP_WARN_HANDLER */,
                [
                  msg + args.join(''),
                  instance && instance.proxy,
                  trace
                    .map(
                      ({ vnode }) =>
                        `at <${formatComponentName(instance, vnode.type)}>`
                    )
                    .join('\n'),
                  trace
                ]
              )
            } else {
              const warnArgs = [`[Vue warn]: ${msg}`, ...args]
              /* istanbul ignore if */
              if (
                trace.length &&
                // avoid spamming console during tests
                !false
              ) {
                warnArgs.push(`\n`, ...formatTrace(trace))
              }
              console.warn(...warnArgs)
            }
            Object(
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['resetTracking']
            )()
          }
          function getComponentTrace() {
            let currentVNode = stack[stack.length - 1]
            if (!currentVNode) {
              return []
            }
            // we can't just use the stack because it will be incomplete during updates
            // that did not start from the root. Re-construct the parent chain using
            // instance parent pointers.
            const normalizedStack = []
            while (currentVNode) {
              const last = normalizedStack[0]
              if (last && last.vnode === currentVNode) {
                last.recurseCount++
              } else {
                normalizedStack.push({
                  vnode: currentVNode,
                  recurseCount: 0
                })
              }
              const parentInstance =
                currentVNode.component && currentVNode.component.parent
              currentVNode = parentInstance && parentInstance.vnode
            }
            return normalizedStack
          }
          /* istanbul ignore next */
          function formatTrace(trace) {
            const logs = []
            trace.forEach((entry, i) => {
              logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry))
            })
            return logs
          }
          function formatTraceEntry({ vnode, recurseCount }) {
            const postfix =
              recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``
            const isRoot = vnode.component
              ? vnode.component.parent == null
              : false
            const open = ` at <${formatComponentName(
              vnode.component,
              vnode.type,
              isRoot
            )}`
            const close = `>` + postfix
            return vnode.props
              ? [open, ...formatProps(vnode.props), close]
              : [open + close]
          }
          /* istanbul ignore next */
          function formatProps(props) {
            const res = []
            const keys = Object.keys(props)
            keys.slice(0, 3).forEach(key => {
              res.push(...formatProp(key, props[key]))
            })
            if (keys.length > 3) {
              res.push(` ...`)
            }
            return res
          }
          /* istanbul ignore next */
          function formatProp(key, value, raw) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                value
              )
            ) {
              value = JSON.stringify(value)
              return raw ? value : [`${key}=${value}`]
            } else if (
              typeof value === 'number' ||
              typeof value === 'boolean' ||
              value == null
            ) {
              return raw ? value : [`${key}=${value}`]
            } else if (
              Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef'])(
                value
              )
            ) {
              value = formatProp(
                key,
                Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw'])(
                  value.value
                ),
                true
              )
              return raw ? value : [`${key}=Ref<`, value, `>`]
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                value
              )
            ) {
              return [`${key}=fn${value.name ? `<${value.name}>` : ``}`]
            } else {
              value = Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
              )(value)
              return raw ? value : [`${key}=`, value]
            }
          }

          const ErrorTypeStrings = {
            ['bc' /* BEFORE_CREATE */]: 'beforeCreate hook',
            ['c' /* CREATED */]: 'created hook',
            ['bm' /* BEFORE_MOUNT */]: 'beforeMount hook',
            ['m' /* MOUNTED */]: 'mounted hook',
            ['bu' /* BEFORE_UPDATE */]: 'beforeUpdate hook',
            ['u' /* UPDATED */]: 'updated',
            ['bum' /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
            ['um' /* UNMOUNTED */]: 'unmounted hook',
            ['a' /* ACTIVATED */]: 'activated hook',
            ['da' /* DEACTIVATED */]: 'deactivated hook',
            ['ec' /* ERROR_CAPTURED */]: 'errorCaptured hook',
            ['rtc' /* RENDER_TRACKED */]: 'renderTracked hook',
            ['rtg' /* RENDER_TRIGGERED */]: 'renderTriggered hook',
            [0 /* SETUP_FUNCTION */]: 'setup function',
            [1 /* RENDER_FUNCTION */]: 'render function',
            [2 /* WATCH_GETTER */]: 'watcher getter',
            [3 /* WATCH_CALLBACK */]: 'watcher callback',
            [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
            [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
            [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
            [7 /* VNODE_HOOK */]: 'vnode hook',
            [8 /* DIRECTIVE_HOOK */]: 'directive hook',
            [9 /* TRANSITION_HOOK */]: 'transition hook',
            [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
            [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
            [12 /* FUNCTION_REF */]: 'ref function',
            [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
            [14 /* SCHEDULER */]:
              'scheduler flush. This is likely a Vue internals bug. ' +
              'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
          }
          function callWithErrorHandling(fn, instance, type, args) {
            let res
            try {
              res = args ? fn(...args) : fn()
            } catch (err) {
              handleError(err, instance, type)
            }
            return res
          }
          function callWithAsyncErrorHandling(fn, instance, type, args) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(fn)
            ) {
              const res = callWithErrorHandling(fn, instance, type, args)
              if (
                res &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isPromise'])(
                  res
                )
              ) {
                res.catch(err => {
                  handleError(err, instance, type)
                })
              }
              return res
            }
            const values = []
            for (let i = 0; i < fn.length; i++) {
              values.push(
                callWithAsyncErrorHandling(fn[i], instance, type, args)
              )
            }
            return values
          }
          function handleError(err, instance, type, throwInDev = true) {
            const contextVNode = instance ? instance.vnode : null
            if (instance) {
              let cur = instance.parent
              // the exposed instance is the render proxy to keep it consistent with 2.x
              const exposedInstance = instance.proxy
              // in production the hook receives only the error code
              const errorInfo = true ? ErrorTypeStrings[type] : undefined
              while (cur) {
                const errorCapturedHooks = cur.ec
                if (errorCapturedHooks) {
                  for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (
                      errorCapturedHooks[i](err, exposedInstance, errorInfo) ===
                      false
                    ) {
                      return
                    }
                  }
                }
                cur = cur.parent
              }
              // app-level handling
              const appErrorHandler = instance.appContext.config.errorHandler
              if (appErrorHandler) {
                callWithErrorHandling(
                  appErrorHandler,
                  null,
                  10 /* APP_ERROR_HANDLER */,
                  [err, exposedInstance, errorInfo]
                )
                return
              }
            }
            logError(err, type, contextVNode, throwInDev)
          }
          function logError(err, type, contextVNode, throwInDev = true) {
            if (true) {
              const info = ErrorTypeStrings[type]
              if (contextVNode) {
                pushWarningContext(contextVNode)
              }
              warn(
                `Unhandled error${info ? ` during execution of ${info}` : ``}`
              )
              if (contextVNode) {
                popWarningContext()
              }
              // crash in dev by default so it's more noticeable
              if (throwInDev) {
                throw err
              } else {
                console.error(err)
              }
            } else {
            }
          }

          let isFlushing = false
          let isFlushPending = false
          const queue = []
          let flushIndex = 0
          const pendingPreFlushCbs = []
          let activePreFlushCbs = null
          let preFlushIndex = 0
          const pendingPostFlushCbs = []
          let activePostFlushCbs = null
          let postFlushIndex = 0
          const resolvedPromise = Promise.resolve()
          let currentFlushPromise = null
          let currentPreFlushParentJob = null
          const RECURSION_LIMIT = 100
          function nextTick(fn) {
            const p = currentFlushPromise || resolvedPromise
            return fn ? p.then(this ? fn.bind(this) : fn) : p
          }
          function queueJob(job) {
            // the dedupe search uses the startIndex argument of Array.includes()
            // by default the search index includes the current job that is being run
            // so it cannot recursively trigger itself again.
            // if the job is a watch() callback, the search will start with a +1 index to
            // allow it recursively trigger itself - it is the user's responsibility to
            // ensure it doesn't end up in an infinite loop.
            if (
              (!queue.length ||
                !queue.includes(
                  job,
                  isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
                )) &&
              job !== currentPreFlushParentJob
            ) {
              queue.push(job)
              queueFlush()
            }
          }
          function queueFlush() {
            if (!isFlushing && !isFlushPending) {
              isFlushPending = true
              currentFlushPromise = resolvedPromise.then(flushJobs)
            }
          }
          function invalidateJob(job) {
            const i = queue.indexOf(job)
            if (i > -1) {
              queue.splice(i, 1)
            }
          }
          function queueCb(cb, activeQueue, pendingQueue, index) {
            if (
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(cb)
            ) {
              if (
                !activeQueue ||
                !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)
              ) {
                pendingQueue.push(cb)
              }
            } else {
              // if cb is an array, it is a component lifecycle hook which can only be
              // triggered by a job, which is already deduped in the main queue, so
              // we can skip duplicate check here to improve perf
              pendingQueue.push(...cb)
            }
            queueFlush()
          }
          function queuePreFlushCb(cb) {
            queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)
          }
          function queuePostFlushCb(cb) {
            queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)
          }
          function flushPreFlushCbs(seen, parentJob = null) {
            if (pendingPreFlushCbs.length) {
              currentPreFlushParentJob = parentJob
              activePreFlushCbs = [...new Set(pendingPreFlushCbs)]
              pendingPreFlushCbs.length = 0
              if (true) {
                seen = seen || new Map()
              }
              for (
                preFlushIndex = 0;
                preFlushIndex < activePreFlushCbs.length;
                preFlushIndex++
              ) {
                if (true) {
                  checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])
                }
                activePreFlushCbs[preFlushIndex]()
              }
              activePreFlushCbs = null
              preFlushIndex = 0
              currentPreFlushParentJob = null
              // recursively flush until it drains
              flushPreFlushCbs(seen, parentJob)
            }
          }
          function flushPostFlushCbs(seen) {
            if (pendingPostFlushCbs.length) {
              const deduped = [...new Set(pendingPostFlushCbs)]
              pendingPostFlushCbs.length = 0
              // #1947 already has active queue, nested flushPostFlushCbs call
              if (activePostFlushCbs) {
                activePostFlushCbs.push(...deduped)
                return
              }
              activePostFlushCbs = deduped
              if (true) {
                seen = seen || new Map()
              }
              activePostFlushCbs.sort((a, b) => getId(a) - getId(b))
              for (
                postFlushIndex = 0;
                postFlushIndex < activePostFlushCbs.length;
                postFlushIndex++
              ) {
                if (true) {
                  checkRecursiveUpdates(
                    seen,
                    activePostFlushCbs[postFlushIndex]
                  )
                }
                activePostFlushCbs[postFlushIndex]()
              }
              activePostFlushCbs = null
              postFlushIndex = 0
            }
          }
          const getId = job => (job.id == null ? Infinity : job.id)
          function flushJobs(seen) {
            isFlushPending = false
            isFlushing = true
            if (true) {
              seen = seen || new Map()
            }
            flushPreFlushCbs(seen)
            // Sort queue before flush.
            // This ensures that:
            // 1. Components are updated from parent to child. (because parent is always
            //    created before the child so its render effect will have smaller
            //    priority number)
            // 2. If a component is unmounted during a parent component's update,
            //    its update can be skipped.
            queue.sort((a, b) => getId(a) - getId(b))
            try {
              for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
                const job = queue[flushIndex]
                if (job) {
                  if (true) {
                    checkRecursiveUpdates(seen, job)
                  }
                  callWithErrorHandling(job, null, 14 /* SCHEDULER */)
                }
              }
            } finally {
              flushIndex = 0
              queue.length = 0
              flushPostFlushCbs(seen)
              isFlushing = false
              currentFlushPromise = null
              // some postFlushCb queued jobs!
              // keep flushing until it drains.
              if (queue.length || pendingPostFlushCbs.length) {
                flushJobs(seen)
              }
            }
          }
          function checkRecursiveUpdates(seen, fn) {
            if (!seen.has(fn)) {
              seen.set(fn, 1)
            } else {
              const count = seen.get(fn)
              if (count > RECURSION_LIMIT) {
                throw new Error(
                  `Maximum recursive updates exceeded. ` +
                    `This means you have a reactive effect that is mutating its own ` +
                    `dependencies and thus recursively triggering itself. Possible sources ` +
                    `include component template, render function, updated hook or ` +
                    `watcher source function.`
                )
              } else {
                seen.set(fn, count + 1)
              }
            }
          }

          /* eslint-disable no-restricted-globals */
          let isHmrUpdating = false
          const hmrDirtyComponents = new Set()
          // Expose the HMR runtime on the global object
          // This makes it entirely tree-shakable without polluting the exports and makes
          // it easier to be used in toolings like vue-loader
          // Note: for a component to be eligible for HMR it also needs the __hmrId option
          // to be set so that its instances can be registered / removed.
          if (true) {
            const globalObject =
              typeof global !== 'undefined'
                ? global
                : typeof self !== 'undefined'
                  ? self
                  : typeof window !== 'undefined'
                    ? window
                    : {}
            globalObject.__VUE_HMR_RUNTIME__ = {
              createRecord: tryWrap(createRecord),
              rerender: tryWrap(rerender),
              reload: tryWrap(reload)
            }
          }
          const map = new Map()
          function registerHMR(instance) {
            const id = instance.type.__hmrId
            let record = map.get(id)
            if (!record) {
              createRecord(id, instance.type)
              record = map.get(id)
            }
            record.instances.add(instance)
          }
          function unregisterHMR(instance) {
            map.get(instance.type.__hmrId).instances.delete(instance)
          }
          function createRecord(id, component) {
            if (!component) {
              warn(
                `HMR API usage is out of date.\n` +
                  `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +
                  `dependency that handles Vue SFC compilation.`
              )
              component = {}
            }
            if (map.has(id)) {
              return false
            }
            map.set(id, {
              component: isClassComponent(component)
                ? component.__vccOpts
                : component,
              instances: new Set()
            })
            return true
          }
          function rerender(id, newRender) {
            const record = map.get(id)
            if (!record) return
            if (newRender) record.component.render = newRender
            // Array.from creates a snapshot which avoids the set being mutated during
            // updates
            Array.from(record.instances).forEach(instance => {
              if (newRender) {
                instance.render = newRender
              }
              instance.renderCache = []
              // this flag forces child components with slot content to update
              isHmrUpdating = true
              instance.update()
              isHmrUpdating = false
            })
          }
          function reload(id, newComp) {
            const record = map.get(id)
            if (!record) return
            // Array.from creates a snapshot which avoids the set being mutated during
            // updates
            const { component, instances } = record
            if (!hmrDirtyComponents.has(component)) {
              // 1. Update existing comp definition to match new one
              newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                component,
                newComp
              )
              for (const key in component) {
                if (!(key in newComp)) {
                  delete component[key]
                }
              }
              // 2. Mark component dirty. This forces the renderer to replace the component
              // on patch.
              hmrDirtyComponents.add(component)
              // 3. Make sure to unmark the component after the reload.
              queuePostFlushCb(() => {
                hmrDirtyComponents.delete(component)
              })
            }
            Array.from(instances).forEach(instance => {
              if (instance.parent) {
                // 4. Force the parent instance to re-render. This will cause all updated
                // components to be unmounted and re-mounted. Queue the update so that we
                // don't end up forcing the same parent to re-render multiple times.
                queueJob(instance.parent.update)
              } else if (instance.appContext.reload) {
                // root instance mounted via createApp() has a reload method
                instance.appContext.reload()
              } else if (typeof window !== 'undefined') {
                // root instance inside tree created via raw render(). Force reload.
                window.location.reload()
              } else {
                console.warn(
                  '[HMR] Root or manually mounted instance modified. Full reload required.'
                )
              }
            })
          }
          function tryWrap(fn) {
            return (id, arg) => {
              try {
                return fn(id, arg)
              } catch (e) {
                console.error(e)
                console.warn(
                  `[HMR] Something went wrong during Vue component hot-reload. ` +
                    `Full reload required.`
                )
              }
            }
          }

          let devtools
          function setDevtoolsHook(hook) {
            devtools = hook
          }
          function devtoolsInitApp(app, version) {
            // TODO queue if devtools is undefined
            if (!devtools) return
            devtools.emit('app:init' /* APP_INIT */, app, version, {
              Fragment,
              Text,
              Comment,
              Static
            })
          }
          function devtoolsUnmountApp(app) {
            if (!devtools) return
            devtools.emit('app:unmount' /* APP_UNMOUNT */, app)
          }
          const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(
            'component:added' /* COMPONENT_ADDED */
          )
          const devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook(
            'component:updated' /* COMPONENT_UPDATED */
          )
          const devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook(
            'component:removed' /* COMPONENT_REMOVED */
          )
          function createDevtoolsComponentHook(hook) {
            return component => {
              if (!devtools) return
              devtools.emit(
                hook,
                component.appContext.app,
                component.uid,
                component.parent ? component.parent.uid : undefined,
                component
              )
            }
          }
          function devtoolsComponentEmit(component, event, params) {
            if (!devtools) return
            devtools.emit(
              'component:emit' /* COMPONENT_EMIT */,
              component.appContext.app,
              component,
              event,
              params
            )
          }

          function emit(instance, event, ...rawArgs) {
            const props =
              instance.vnode.props ||
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
            if (true) {
              const {
                emitsOptions,
                propsOptions: [propsOptions]
              } = instance
              if (emitsOptions) {
                if (!(event in emitsOptions)) {
                  if (
                    !propsOptions ||
                    !(
                      Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toHandlerKey']
                      )(event) in propsOptions
                    )
                  ) {
                    warn(
                      `Component emitted event "${event}" but it is neither declared in ` +
                        `the emits option nor as an "${Object(
                          _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                            'toHandlerKey'
                          ]
                        )(event)}" prop.`
                    )
                  }
                } else {
                  const validator = emitsOptions[event]
                  if (
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                    )(validator)
                  ) {
                    const isValid = validator(...rawArgs)
                    if (!isValid) {
                      warn(
                        `Invalid event arguments: event validation failed for event "${event}".`
                      )
                    }
                  }
                }
              }
            }
            let args = rawArgs
            const isModelListener = event.startsWith('update:')
            // for v-model update:xxx events, apply modifiers on args
            const modelArg = isModelListener && event.slice(7)
            if (modelArg && modelArg in props) {
              const modifiersKey = `${
                modelArg === 'modelValue' ? 'model' : modelArg
              }Modifiers`
              const { number, trim } =
                props[modifiersKey] ||
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
              if (trim) {
                args = rawArgs.map(a => a.trim())
              } else if (number) {
                args = rawArgs.map(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toNumber']
                )
              }
            }
            if (true) {
              devtoolsComponentEmit(instance, event, args)
            }
            if (true) {
              const lowerCaseEvent = event.toLowerCase()
              if (
                lowerCaseEvent !== event &&
                props[
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toHandlerKey']
                  )(lowerCaseEvent)
                ]
              ) {
                warn(
                  `Event "${lowerCaseEvent}" is emitted in component ` +
                    `${formatComponentName(
                      instance,
                      instance.type
                    )} but the handler is registered for "${event}". ` +
                    `Note that HTML attributes are case-insensitive and you cannot use ` +
                    `v-on to listen to camelCase events when using in-DOM templates. ` +
                    `You should probably use "${Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hyphenate']
                    )(event)}" instead of "${event}".`
                )
              }
            }
            // convert handler name to camelCase. See issue #2249
            let handlerName = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toHandlerKey']
            )(
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize'])(
                event
              )
            )
            let handler = props[handlerName]
            // for v-model update:xxx events, also trigger kebab-case equivalent
            // for props passed via kebab-case
            if (!handler && isModelListener) {
              handlerName = Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toHandlerKey']
              )(
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hyphenate'])(
                  event
                )
              )
              handler = props[handlerName]
            }
            if (handler) {
              callWithAsyncErrorHandling(
                handler,
                instance,
                6 /* COMPONENT_EVENT_HANDLER */,
                args
              )
            }
            const onceHandler = props[handlerName + `Once`]
            if (onceHandler) {
              if (!instance.emitted) {
                ;(instance.emitted = {})[handlerName] = true
              } else if (instance.emitted[handlerName]) {
                return
              }
              callWithAsyncErrorHandling(
                onceHandler,
                instance,
                6 /* COMPONENT_EVENT_HANDLER */,
                args
              )
            }
          }
          function normalizeEmitsOptions(comp, appContext, asMixin = false) {
            if (!appContext.deopt && comp.__emits !== undefined) {
              return comp.__emits
            }
            const raw = comp.emits
            let normalized = {}
            // apply mixin/extends props
            let hasExtends = false
            if (
              __VUE_OPTIONS_API__ &&
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                comp
              )
            ) {
              const extendEmits = raw => {
                hasExtends = true
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                  normalized,
                  normalizeEmitsOptions(raw, appContext, true)
                )
              }
              if (!asMixin && appContext.mixins.length) {
                appContext.mixins.forEach(extendEmits)
              }
              if (comp.extends) {
                extendEmits(comp.extends)
              }
              if (comp.mixins) {
                comp.mixins.forEach(extendEmits)
              }
            }
            if (!raw && !hasExtends) {
              return (comp.__emits = null)
            }
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(raw)
            ) {
              raw.forEach(key => (normalized[key] = null))
            } else {
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                normalized,
                raw
              )
            }
            return (comp.__emits = normalized)
          }
          // Check if an incoming prop key is a declared emit event listener.
          // e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
          // both considered matched listeners.
          function isEmitListener(options, key) {
            if (
              !options ||
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isOn'])(key)
            ) {
              return false
            }
            key = key.slice(2).replace(/Once$/, '')
            return (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                options,
                key[0].toLowerCase() + key.slice(1)
              ) ||
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                options,
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hyphenate'])(
                  key
                )
              ) ||
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                options,
                key
              )
            )
          }

          /**
           * mark the current rendering instance for asset resolution (e.g.
           * resolveComponent, resolveDirective) during render
           */
          let currentRenderingInstance = null
          function setCurrentRenderingInstance(instance) {
            currentRenderingInstance = instance
          }
          /**
           * dev only flag to track whether $attrs was used during render.
           * If $attrs was used during render then the warning for failed attrs
           * fallthrough can be suppressed.
           */
          let accessedAttrs = false
          function markAttrsAccessed() {
            accessedAttrs = true
          }
          function renderComponentRoot(instance) {
            const {
              type: Component,
              vnode,
              proxy,
              withProxy,
              props,
              propsOptions: [propsOptions],
              slots,
              attrs,
              emit,
              render,
              renderCache,
              data,
              setupState,
              ctx
            } = instance
            let result
            currentRenderingInstance = instance
            if (true) {
              accessedAttrs = false
            }
            try {
              let fallthroughAttrs
              if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
                // withProxy is a proxy with a different `has` trap only for
                // runtime-compiled render functions using `with` block.
                const proxyToUse = withProxy || proxy
                result = normalizeVNode(
                  render.call(
                    proxyToUse,
                    proxyToUse,
                    renderCache,
                    props,
                    setupState,
                    data,
                    ctx
                  )
                )
                fallthroughAttrs = attrs
              } else {
                // functional
                const render = Component
                // in dev, mark attrs accessed if optional props (attrs === props)
                if (true && attrs === props) {
                  markAttrsAccessed()
                }
                result = normalizeVNode(
                  render.length > 1
                    ? render(
                        props,
                        true
                          ? {
                              get attrs() {
                                markAttrsAccessed()
                                return attrs
                              },
                              slots,
                              emit
                            }
                          : undefined
                      )
                    : render(props, null /* we know it doesn't need it */)
                )
                fallthroughAttrs = Component.props
                  ? attrs
                  : getFunctionalFallthrough(attrs)
              }
              // attr merging
              // in dev mode, comments are preserved, and it's possible for a template
              // to have comments along side the root element which makes it a fragment
              let root = result
              let setRoot = undefined
              if (
                true &&
                result.patchFlag > 0 &&
                result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */
              ) {
                ;[root, setRoot] = getChildRoot(result)
              }
              if (Component.inheritAttrs !== false && fallthroughAttrs) {
                const keys = Object.keys(fallthroughAttrs)
                const { shapeFlag } = root
                if (keys.length) {
                  if (
                    shapeFlag & 1 /* ELEMENT */ ||
                    shapeFlag & 6 /* COMPONENT */
                  ) {
                    if (
                      propsOptions &&
                      keys.some(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                          'isModelListener'
                        ]
                      )
                    ) {
                      // If a v-model listener (onUpdate:xxx) has a corresponding declared
                      // prop, it indicates this component expects to handle v-model and
                      // it should not fallthrough.
                      // related: #1543, #1643, #1989
                      fallthroughAttrs = filterModelListeners(
                        fallthroughAttrs,
                        propsOptions
                      )
                    }
                    root = cloneVNode(root, fallthroughAttrs)
                  } else if (true && !accessedAttrs && root.type !== Comment) {
                    const allAttrs = Object.keys(attrs)
                    const eventAttrs = []
                    const extraAttrs = []
                    for (let i = 0, l = allAttrs.length; i < l; i++) {
                      const key = allAttrs[i]
                      if (
                        Object(
                          _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isOn']
                        )(key)
                      ) {
                        // ignore v-model handlers when they fail to fallthrough
                        if (
                          !Object(
                            _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                              'isModelListener'
                            ]
                          )(key)
                        ) {
                          // remove `on`, lowercase first letter to reflect event casing
                          // accurately
                          eventAttrs.push(key[2].toLowerCase() + key.slice(3))
                        }
                      } else {
                        extraAttrs.push(key)
                      }
                    }
                    if (extraAttrs.length) {
                      warn(
                        `Extraneous non-props attributes (` +
                          `${extraAttrs.join(', ')}) ` +
                          `were passed to component but could not be automatically inherited ` +
                          `because component renders fragment or text root nodes.`
                      )
                    }
                    if (eventAttrs.length) {
                      warn(
                        `Extraneous non-emits event listeners (` +
                          `${eventAttrs.join(', ')}) ` +
                          `were passed to component but could not be automatically inherited ` +
                          `because component renders fragment or text root nodes. ` +
                          `If the listener is intended to be a component custom event listener only, ` +
                          `declare it using the "emits" option.`
                      )
                    }
                  }
                }
              }
              // inherit directives
              if (vnode.dirs) {
                if (true && !isElementRoot(root)) {
                  warn(
                    `Runtime directive used on component with non-element root node. ` +
                      `The directives will not function as intended.`
                  )
                }
                root.dirs = root.dirs
                  ? root.dirs.concat(vnode.dirs)
                  : vnode.dirs
              }
              // inherit transition data
              if (vnode.transition) {
                if (true && !isElementRoot(root)) {
                  warn(
                    `Component inside <Transition> renders non-element root node ` +
                      `that cannot be animated.`
                  )
                }
                root.transition = vnode.transition
              }
              if (true && setRoot) {
                setRoot(root)
              } else {
                result = root
              }
            } catch (err) {
              handleError(err, instance, 1 /* RENDER_FUNCTION */)
              result = createVNode(Comment)
            }
            currentRenderingInstance = null
            return result
          }
          /**
           * dev only
           * In dev mode, template root level comments are rendered, which turns the
           * template into a fragment root, but we need to locate the single element
           * root for attrs and scope id processing.
           */
          const getChildRoot = vnode => {
            const rawChildren = vnode.children
            const dynamicChildren = vnode.dynamicChildren
            const childRoot = filterSingleRoot(rawChildren)
            if (!childRoot) {
              return [vnode, undefined]
            }
            const index = rawChildren.indexOf(childRoot)
            const dynamicIndex = dynamicChildren
              ? dynamicChildren.indexOf(childRoot)
              : -1
            const setRoot = updatedRoot => {
              rawChildren[index] = updatedRoot
              if (dynamicChildren) {
                if (dynamicIndex > -1) {
                  dynamicChildren[dynamicIndex] = updatedRoot
                } else if (updatedRoot.patchFlag > 0) {
                  vnode.dynamicChildren = [...dynamicChildren, updatedRoot]
                }
              }
            }
            return [normalizeVNode(childRoot), setRoot]
          }
          function filterSingleRoot(children) {
            let singleRoot
            for (let i = 0; i < children.length; i++) {
              const child = children[i]
              if (isVNode(child)) {
                // ignore user comment
                if (child.type !== Comment || child.children === 'v-if') {
                  if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return
                  } else {
                    singleRoot = child
                  }
                }
              } else {
                return
              }
            }
            return singleRoot
          }
          const getFunctionalFallthrough = attrs => {
            let res
            for (const key in attrs) {
              if (
                key === 'class' ||
                key === 'style' ||
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isOn'])(key)
              ) {
                ;(res || (res = {}))[key] = attrs[key]
              }
            }
            return res
          }
          const filterModelListeners = (attrs, props) => {
            const res = {}
            for (const key in attrs) {
              if (
                !Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isModelListener']
                )(key) ||
                !(key.slice(9) in props)
              ) {
                res[key] = attrs[key]
              }
            }
            return res
          }
          const isElementRoot = vnode => {
            return (
              vnode.shapeFlag & 6 /* COMPONENT */ ||
              vnode.shapeFlag & 1 /* ELEMENT */ ||
              vnode.type === Comment // potential v-if branch switch
            )
          }
          function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
            const {
              props: prevProps,
              children: prevChildren,
              component
            } = prevVNode
            const {
              props: nextProps,
              children: nextChildren,
              patchFlag
            } = nextVNode
            const emits = component.emitsOptions
            // Parent component's render function was hot-updated. Since this may have
            // caused the child component's slots content to have changed, we need to
            // force the child to update as well.
            if (true && (prevChildren || nextChildren) && isHmrUpdating) {
              return true
            }
            // force child update for runtime directive or transition on component vnode.
            if (nextVNode.dirs || nextVNode.transition) {
              return true
            }
            if (optimized && patchFlag >= 0) {
              if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
                // slot content that references values that might have changed,
                // e.g. in a v-for
                return true
              }
              if (patchFlag & 16 /* FULL_PROPS */) {
                if (!prevProps) {
                  return !!nextProps
                }
                // presence of this flag indicates props are always non-null
                return hasPropsChanged(prevProps, nextProps, emits)
              } else if (patchFlag & 8 /* PROPS */) {
                const dynamicProps = nextVNode.dynamicProps
                for (let i = 0; i < dynamicProps.length; i++) {
                  const key = dynamicProps[i]
                  if (
                    nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)
                  ) {
                    return true
                  }
                }
              }
            } else {
              // this path is only taken by manually written render functions
              // so presence of any children leads to a forced update
              if (prevChildren || nextChildren) {
                if (!nextChildren || !nextChildren.$stable) {
                  return true
                }
              }
              if (prevProps === nextProps) {
                return false
              }
              if (!prevProps) {
                return !!nextProps
              }
              if (!nextProps) {
                return true
              }
              return hasPropsChanged(prevProps, nextProps, emits)
            }
            return false
          }
          function hasPropsChanged(prevProps, nextProps, emitsOptions) {
            const nextKeys = Object.keys(nextProps)
            if (nextKeys.length !== Object.keys(prevProps).length) {
              return true
            }
            for (let i = 0; i < nextKeys.length; i++) {
              const key = nextKeys[i]
              if (
                nextProps[key] !== prevProps[key] &&
                !isEmitListener(emitsOptions, key)
              ) {
                return true
              }
            }
            return false
          }
          function updateHOCHostEl(
            { vnode, parent },
            el // HostNode
          ) {
            while (parent && parent.subTree === vnode) {
              ;(vnode = parent.vnode).el = el
              parent = parent.parent
            }
          }

          const isSuspense = type => type.__isSuspense
          // Suspense exposes a component-like API, and is treated like a component
          // in the compiler, but internally it's a special built-in type that hooks
          // directly into the renderer.
          const SuspenseImpl = {
            // In order to make Suspense tree-shakable, we need to avoid importing it
            // directly in the renderer. The renderer checks for the __isSuspense flag
            // on a vnode's type and calls the `process` method, passing in renderer
            // internals.
            __isSuspense: true,
            process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized,
              // platform-specific impl passed from renderer
              rendererInternals
            ) {
              if (n1 == null) {
                mountSuspense(
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized,
                  rendererInternals
                )
              } else {
                patchSuspense(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  isSVG,
                  rendererInternals
                )
              }
            },
            hydrate: hydrateSuspense,
            create: createSuspenseBoundary
          }
          // Force-casted public typing for h and TSX props inference
          const Suspense = SuspenseImpl
          function mountSuspense(
            vnode,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            optimized,
            rendererInternals
          ) {
            const {
              p: patch,
              o: { createElement }
            } = rendererInternals
            const hiddenContainer = createElement('div')
            const suspense = (vnode.suspense = createSuspenseBoundary(
              vnode,
              parentSuspense,
              parentComponent,
              container,
              hiddenContainer,
              anchor,
              isSVG,
              optimized,
              rendererInternals
            ))
            // start mounting the content subtree in an off-dom container
            patch(
              null,
              (suspense.pendingBranch = vnode.ssContent),
              hiddenContainer,
              null,
              parentComponent,
              suspense,
              isSVG
            )
            // now check if we have encountered any async deps
            if (suspense.deps > 0) {
              // has async
              // mount the fallback tree
              patch(
                null,
                vnode.ssFallback,
                container,
                anchor,
                parentComponent,
                null, // fallback tree will not have suspense context
                isSVG
              )
              setActiveBranch(suspense, vnode.ssFallback)
            } else {
              // Suspense has no async deps. Just resolve.
              suspense.resolve()
            }
          }
          function patchSuspense(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            isSVG,
            { p: patch, um: unmount, o: { createElement } }
          ) {
            const suspense = (n2.suspense = n1.suspense)
            suspense.vnode = n2
            n2.el = n1.el
            const newBranch = n2.ssContent
            const newFallback = n2.ssFallback
            const {
              activeBranch,
              pendingBranch,
              isInFallback,
              isHydrating
            } = suspense
            if (pendingBranch) {
              suspense.pendingBranch = newBranch
              if (isSameVNodeType(newBranch, pendingBranch)) {
                // same root type but content may have changed.
                patch(
                  pendingBranch,
                  newBranch,
                  suspense.hiddenContainer,
                  null,
                  parentComponent,
                  suspense,
                  isSVG
                )
                if (suspense.deps <= 0) {
                  suspense.resolve()
                } else if (isInFallback) {
                  patch(
                    activeBranch,
                    newFallback,
                    container,
                    anchor,
                    parentComponent,
                    null, // fallback tree will not have suspense context
                    isSVG
                  )
                  setActiveBranch(suspense, newFallback)
                }
              } else {
                // toggled before pending tree is resolved
                suspense.pendingId++
                if (isHydrating) {
                  // if toggled before hydration is finished, the current DOM tree is
                  // no longer valid. set it as the active branch so it will be unmounted
                  // when resolved
                  suspense.isHydrating = false
                  suspense.activeBranch = pendingBranch
                } else {
                  unmount(pendingBranch, parentComponent, suspense)
                }
                // increment pending ID. this is used to invalidate async callbacks
                // reset suspense state
                suspense.deps = 0
                // discard effects from pending branch
                suspense.effects.length = 0
                // discard previous container
                suspense.hiddenContainer = createElement('div')
                if (isInFallback) {
                  // already in fallback state
                  patch(
                    null,
                    newBranch,
                    suspense.hiddenContainer,
                    null,
                    parentComponent,
                    suspense,
                    isSVG
                  )
                  if (suspense.deps <= 0) {
                    suspense.resolve()
                  } else {
                    patch(
                      activeBranch,
                      newFallback,
                      container,
                      anchor,
                      parentComponent,
                      null, // fallback tree will not have suspense context
                      isSVG
                    )
                    setActiveBranch(suspense, newFallback)
                  }
                } else if (
                  activeBranch &&
                  isSameVNodeType(newBranch, activeBranch)
                ) {
                  // toggled "back" to current active branch
                  patch(
                    activeBranch,
                    newBranch,
                    container,
                    anchor,
                    parentComponent,
                    suspense,
                    isSVG
                  )
                  // force resolve
                  suspense.resolve(true)
                } else {
                  // switched to a 3rd branch
                  patch(
                    null,
                    newBranch,
                    suspense.hiddenContainer,
                    null,
                    parentComponent,
                    suspense,
                    isSVG
                  )
                  if (suspense.deps <= 0) {
                    suspense.resolve()
                  }
                }
              }
            } else {
              if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // root did not change, just normal patch
                patch(
                  activeBranch,
                  newBranch,
                  container,
                  anchor,
                  parentComponent,
                  suspense,
                  isSVG
                )
                setActiveBranch(suspense, newBranch)
              } else {
                // root node toggled
                // invoke @pending event
                const onPending = n2.props && n2.props.onPending
                if (
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(onPending)
                ) {
                  onPending()
                }
                // mount pending branch in off-dom container
                suspense.pendingBranch = newBranch
                suspense.pendingId++
                patch(
                  null,
                  newBranch,
                  suspense.hiddenContainer,
                  null,
                  parentComponent,
                  suspense,
                  isSVG
                )
                if (suspense.deps <= 0) {
                  // incoming branch has no async deps, resolve now.
                  suspense.resolve()
                } else {
                  const { timeout, pendingId } = suspense
                  if (timeout > 0) {
                    setTimeout(() => {
                      if (suspense.pendingId === pendingId) {
                        suspense.fallback(newFallback)
                      }
                    }, timeout)
                  } else if (timeout === 0) {
                    suspense.fallback(newFallback)
                  }
                }
              }
            }
          }
          let hasWarned = false
          function createSuspenseBoundary(
            vnode,
            parent,
            parentComponent,
            container,
            hiddenContainer,
            anchor,
            isSVG,
            optimized,
            rendererInternals,
            isHydrating = false
          ) {
            /* istanbul ignore if */
            if (true && !hasWarned) {
              hasWarned = true
              // @ts-ignore `console.info` cannot be null error
              console[console.info ? 'info' : 'log'](
                `<Suspense> is an experimental feature and its API will likely change.`
              )
            }
            const {
              p: patch,
              m: move,
              um: unmount,
              n: next,
              o: { parentNode, remove }
            } = rendererInternals
            const timeout = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toNumber']
            )(vnode.props && vnode.props.timeout)
            const suspense = {
              vnode,
              parent,
              parentComponent,
              isSVG,
              container,
              hiddenContainer,
              anchor,
              deps: 0,
              pendingId: 0,
              timeout: typeof timeout === 'number' ? timeout : -1,
              activeBranch: null,
              pendingBranch: null,
              isInFallback: true,
              isHydrating,
              isUnmounted: false,
              effects: [],
              resolve(resume = false) {
                if (true) {
                  if (!resume && !suspense.pendingBranch) {
                    throw new Error(
                      `suspense.resolve() is called without a pending branch.`
                    )
                  }
                  if (suspense.isUnmounted) {
                    throw new Error(
                      `suspense.resolve() is called on an already unmounted suspense boundary.`
                    )
                  }
                }
                const {
                  vnode,
                  activeBranch,
                  pendingBranch,
                  pendingId,
                  effects,
                  parentComponent,
                  container
                } = suspense
                if (suspense.isHydrating) {
                  suspense.isHydrating = false
                } else if (!resume) {
                  const delayEnter =
                    activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in'
                  if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                      if (pendingId === suspense.pendingId) {
                        move(pendingBranch, container, anchor, 0 /* ENTER */)
                      }
                    }
                  }
                  // this is initial anchor on mount
                  let { anchor } = suspense
                  // unmount current active tree
                  if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch)
                    unmount(activeBranch, parentComponent, suspense, true)
                  }
                  if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* ENTER */)
                  }
                }
                setActiveBranch(suspense, pendingBranch)
                suspense.pendingBranch = null
                suspense.isInFallback = false
                // flush buffered effects
                // check if there is a pending parent suspense
                let parent = suspense.parent
                let hasUnresolvedAncestor = false
                while (parent) {
                  if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects)
                    hasUnresolvedAncestor = true
                    break
                  }
                  parent = parent.parent
                }
                // no pending parent suspense, flush all jobs
                if (!hasUnresolvedAncestor) {
                  queuePostFlushCb(effects)
                }
                suspense.effects = []
                // invoke @resolve event
                const onResolve = vnode.props && vnode.props.onResolve
                if (
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(onResolve)
                ) {
                  onResolve()
                }
              },
              fallback(fallbackVNode) {
                if (!suspense.pendingBranch) {
                  return
                }
                const {
                  vnode,
                  activeBranch,
                  parentComponent,
                  container,
                  isSVG
                } = suspense
                // invoke @fallback event
                const onFallback = vnode.props && vnode.props.onFallback
                if (
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(onFallback)
                ) {
                  onFallback()
                }
                const anchor = next(activeBranch)
                const mountFallback = () => {
                  if (!suspense.isInFallback) {
                    return
                  }
                  // mount the fallback tree
                  patch(
                    null,
                    fallbackVNode,
                    container,
                    anchor,
                    parentComponent,
                    null, // fallback tree will not have suspense context
                    isSVG
                  )
                  setActiveBranch(suspense, fallbackVNode)
                }
                const delayEnter =
                  fallbackVNode.transition &&
                  fallbackVNode.transition.mode === 'out-in'
                if (delayEnter) {
                  activeBranch.transition.afterLeave = mountFallback
                }
                // unmount current active branch
                unmount(
                  activeBranch,
                  parentComponent,
                  null, // no suspense so unmount hooks fire now
                  true // shouldRemove
                )
                suspense.isInFallback = true
                if (!delayEnter) {
                  mountFallback()
                }
              },
              move(container, anchor, type) {
                suspense.activeBranch &&
                  move(suspense.activeBranch, container, anchor, type)
                suspense.container = container
              },
              next() {
                return suspense.activeBranch && next(suspense.activeBranch)
              },
              registerDep(instance, setupRenderEffect) {
                const isInPendingSuspense = !!suspense.pendingBranch
                if (isInPendingSuspense) {
                  suspense.deps++
                }
                const hydratedEl = instance.vnode.el
                instance.asyncDep
                  .catch(err => {
                    handleError(err, instance, 0 /* SETUP_FUNCTION */)
                  })
                  .then(asyncSetupResult => {
                    // retry when the setup() promise resolves.
                    // component may have been unmounted before resolve.
                    if (
                      instance.isUnmounted ||
                      suspense.isUnmounted ||
                      suspense.pendingId !== instance.suspenseId
                    ) {
                      return
                    }
                    // retry from this component
                    instance.asyncResolved = true
                    const { vnode } = instance
                    if (true) {
                      pushWarningContext(vnode)
                    }
                    handleSetupResult(instance, asyncSetupResult)
                    if (hydratedEl) {
                      // vnode may have been replaced if an update happened before the
                      // async dep is resolved.
                      vnode.el = hydratedEl
                    }
                    const placeholder = !hydratedEl && instance.subTree.el
                    setupRenderEffect(
                      instance,
                      vnode,
                      // component may have been moved before resolve.
                      // if this is not a hydration, instance.subTree will be the comment
                      // placeholder.
                      parentNode(hydratedEl || instance.subTree.el),
                      // anchor will not be used if this is hydration, so only need to
                      // consider the comment placeholder case.
                      hydratedEl ? null : next(instance.subTree),
                      suspense,
                      isSVG,
                      optimized
                    )
                    if (placeholder) {
                      remove(placeholder)
                    }
                    updateHOCHostEl(instance, vnode.el)
                    if (true) {
                      popWarningContext()
                    }
                    // only decrease deps count if suspense is not already resolved
                    if (isInPendingSuspense && --suspense.deps === 0) {
                      suspense.resolve()
                    }
                  })
              },
              unmount(parentSuspense, doRemove) {
                suspense.isUnmounted = true
                if (suspense.activeBranch) {
                  unmount(
                    suspense.activeBranch,
                    parentComponent,
                    parentSuspense,
                    doRemove
                  )
                }
                if (suspense.pendingBranch) {
                  unmount(
                    suspense.pendingBranch,
                    parentComponent,
                    parentSuspense,
                    doRemove
                  )
                }
              }
            }
            return suspense
          }
          function hydrateSuspense(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            isSVG,
            optimized,
            rendererInternals,
            hydrateNode
          ) {
            /* eslint-disable no-restricted-globals */
            const suspense = (vnode.suspense = createSuspenseBoundary(
              vnode,
              parentSuspense,
              parentComponent,
              node.parentNode,
              document.createElement('div'),
              null,
              isSVG,
              optimized,
              rendererInternals,
              true /* hydrating */
            ))
            // there are two possible scenarios for server-rendered suspense:
            // - success: ssr content should be fully resolved
            // - failure: ssr content should be the fallback branch.
            // however, on the client we don't really know if it has failed or not
            // attempt to hydrate the DOM assuming it has succeeded, but we still
            // need to construct a suspense boundary first
            const result = hydrateNode(
              node,
              (suspense.pendingBranch = vnode.ssContent),
              parentComponent,
              suspense,
              optimized
            )
            if (suspense.deps === 0) {
              suspense.resolve()
            }
            return result
            /* eslint-enable no-restricted-globals */
          }
          function normalizeSuspenseChildren(vnode) {
            const { shapeFlag, children } = vnode
            let content
            let fallback
            if (shapeFlag & 32 /* SLOTS_CHILDREN */) {
              content = normalizeSuspenseSlot(children.default)
              fallback = normalizeSuspenseSlot(children.fallback)
            } else {
              content = normalizeSuspenseSlot(children)
              fallback = normalizeVNode(null)
            }
            return {
              content,
              fallback
            }
          }
          function normalizeSuspenseSlot(s) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(s)
            ) {
              s = s()
            }
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(s)
            ) {
              const singleChild = filterSingleRoot(s)
              if (true && !singleChild) {
                warn(`<Suspense> slots expect a single root node.`)
              }
              s = singleChild
            }
            return normalizeVNode(s)
          }
          function queueEffectWithSuspense(fn, suspense) {
            if (suspense && suspense.pendingBranch) {
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(fn)
              ) {
                suspense.effects.push(...fn)
              } else {
                suspense.effects.push(fn)
              }
            } else {
              queuePostFlushCb(fn)
            }
          }
          function setActiveBranch(suspense, branch) {
            suspense.activeBranch = branch
            const { vnode, parentComponent } = suspense
            const el = (vnode.el = branch.el)
            // in case suspense is the root node of a component,
            // recursively update the HOC el
            if (parentComponent && parentComponent.subTree === vnode) {
              parentComponent.vnode.el = el
              updateHOCHostEl(parentComponent, el)
            }
          }

          let isRenderingCompiledSlot = 0
          const setCompiledSlotRendering = n => (isRenderingCompiledSlot += n)
          /**
           * Compiler runtime helper for rendering `<slot/>`
           * @private
           */
          function renderSlot(
            slots,
            name,
            props = {},
            // this is not a user-facing function, so the fallback is always generated by
            // the compiler and guaranteed to be a function returning an array
            fallback
          ) {
            let slot = slots[name]
            if (true && slot && slot.length > 1) {
              warn(
                `SSR-optimized slot function detected in a non-SSR-optimized render ` +
                  `function. You need to mark this component with $dynamic-slots in the ` +
                  `parent template.`
              )
              slot = () => []
            }
            // a compiled slot disables block tracking by default to avoid manual
            // invocation interfering with template-based block tracking, but in
            // `renderSlot` we can be sure that it's template-based so we can force
            // enable it.
            isRenderingCompiledSlot++
            openBlock()
            const validSlotContent = slot && ensureValidVNode(slot(props))
            const rendered = createBlock(
              Fragment,
              { key: props.key || `_${name}` },
              validSlotContent || (fallback ? fallback() : []),
              validSlotContent && slots._ === 1 /* STABLE */
                ? 64 /* STABLE_FRAGMENT */
                : -2 /* BAIL */
            )
            isRenderingCompiledSlot--
            return rendered
          }
          function ensureValidVNode(vnodes) {
            return vnodes.some(child => {
              if (!isVNode(child)) return true
              if (child.type === Comment) return false
              if (child.type === Fragment && !ensureValidVNode(child.children))
                return false
              return true
            })
              ? vnodes
              : null
          }

          /**
           * Wrap a slot function to memoize current rendering instance
           * @private
           */
          function withCtx(fn, ctx = currentRenderingInstance) {
            if (!ctx) return fn
            const renderFnWithContext = (...args) => {
              // If a user calls a compiled slot inside a template expression (#1745), it
              // can mess up block tracking, so by default we need to push a null block to
              // avoid that. This isn't necessary if rendering a compiled `<slot>`.
              if (!isRenderingCompiledSlot) {
                openBlock(true /* null block that disables tracking */)
              }
              const owner = currentRenderingInstance
              setCurrentRenderingInstance(ctx)
              const res = fn(...args)
              setCurrentRenderingInstance(owner)
              if (!isRenderingCompiledSlot) {
                closeBlock()
              }
              return res
            }
            renderFnWithContext._c = true
            return renderFnWithContext
          }

          // SFC scoped style ID management.
          let currentScopeId = null
          const scopeIdStack = []
          /**
           * @private
           */
          function pushScopeId(id) {
            scopeIdStack.push((currentScopeId = id))
          }
          /**
           * @private
           */
          function popScopeId() {
            scopeIdStack.pop()
            currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null
          }
          /**
           * @private
           */
          function withScopeId(id) {
            return fn =>
              withCtx(function() {
                pushScopeId(id)
                const res = fn.apply(this, arguments)
                popScopeId()
                return res
              })
          }

          function initProps(
            instance,
            rawProps,
            isStateful, // result of bitwise flag comparison
            isSSR = false
          ) {
            const props = {}
            const attrs = {}
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['def'])(
              attrs,
              InternalObjectKey,
              1
            )
            setFullProps(instance, rawProps, props, attrs)
            // validation
            if (true) {
              validateProps(props, instance)
            }
            if (isStateful) {
              // stateful
              instance.props = isSSR
                ? props
                : Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                      'shallowReactive'
                    ]
                  )(props)
            } else {
              if (!instance.type.props) {
                // functional w/ optional props, props === attrs
                instance.props = attrs
              } else {
                // functional w/ declared props
                instance.props = props
              }
            }
            instance.attrs = attrs
          }
          function updateProps(instance, rawProps, rawPrevProps, optimized) {
            const {
              props,
              attrs,
              vnode: { patchFlag }
            } = instance
            const rawCurrentProps = Object(
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
            )(props)
            const [options] = instance.propsOptions
            if (
              // always force full diff in dev
              // - #1942 if hmr is enabled with sfc component
              // - vite#872 non-sfc component used by sfc component
              !(
                true &&
                (instance.type.__hmrId ||
                  (instance.parent && instance.parent.type.__hmrId))
              ) &&
              (optimized || patchFlag > 0) &&
              !(patchFlag & 16) /* FULL_PROPS */
            ) {
              if (patchFlag & 8 /* PROPS */) {
                // Compiler-generated props & no keys change, just set the updated
                // the props.
                const propsToUpdate = instance.vnode.dynamicProps
                for (let i = 0; i < propsToUpdate.length; i++) {
                  const key = propsToUpdate[i]
                  // PROPS flag guarantees rawProps to be non-null
                  const value = rawProps[key]
                  if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if (
                      Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn']
                      )(attrs, key)
                    ) {
                      attrs[key] = value
                    } else {
                      const camelizedKey = Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize']
                      )(key)
                      props[camelizedKey] = resolvePropValue(
                        options,
                        rawCurrentProps,
                        camelizedKey,
                        value,
                        instance
                      )
                    }
                  } else {
                    attrs[key] = value
                  }
                }
              }
            } else {
              // full props update.
              setFullProps(instance, rawProps, props, attrs)
              // in case of dynamic props, check if we need to delete keys from
              // the props object
              let kebabKey
              for (const key in rawCurrentProps) {
                if (
                  !rawProps ||
                  // for camelCase
                  (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    rawProps,
                    key
                  ) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hyphenate']
                    )(key)) === key ||
                      !Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn']
                      )(rawProps, kebabKey)))
                ) {
                  if (options) {
                    if (
                      rawPrevProps &&
                      // for camelCase
                      (rawPrevProps[key] !== undefined ||
                        // for kebab-case
                        rawPrevProps[kebabKey] !== undefined)
                    ) {
                      props[key] = resolvePropValue(
                        options,
                        rawProps ||
                          _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
                        key,
                        undefined,
                        instance
                      )
                    }
                  } else {
                    delete props[key]
                  }
                }
              }
              // in the case of functional component w/o props declaration, props and
              // attrs point to the same object so it should already have been updated.
              if (attrs !== rawCurrentProps) {
                for (const key in attrs) {
                  if (
                    !rawProps ||
                    !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                      rawProps,
                      key
                    )
                  ) {
                    delete attrs[key]
                  }
                }
              }
            }
            // trigger updates for $attrs in case it's used in component slots
            Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['trigger'])(
              instance,
              'set' /* SET */,
              '$attrs'
            )
            if (true && rawProps) {
              validateProps(props, instance)
            }
          }
          function setFullProps(instance, rawProps, props, attrs) {
            const [options, needCastKeys] = instance.propsOptions
            if (rawProps) {
              for (const key in rawProps) {
                const value = rawProps[key]
                // key, ref are reserved and never passed down
                if (
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isReservedProp']
                  )(key)
                ) {
                  continue
                }
                // prop option names are camelized during normalization, so to support
                // kebab -> camel conversion here we need to camelize the key.
                let camelKey
                if (
                  options &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    options,
                    (camelKey = Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize']
                    )(key))
                  )
                ) {
                  props[camelKey] = value
                } else if (!isEmitListener(instance.emitsOptions, key)) {
                  // Any non-declared (either as a prop or an emitted event) props are put
                  // into a separate `attrs` object for spreading. Make sure to preserve
                  // original key casing
                  attrs[key] = value
                }
              }
            }
            if (needCastKeys) {
              const rawCurrentProps = Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
              )(props)
              for (let i = 0; i < needCastKeys.length; i++) {
                const key = needCastKeys[i]
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  rawCurrentProps[key],
                  instance
                )
              }
            }
          }
          function resolvePropValue(options, props, key, value, instance) {
            const opt = options[key]
            if (opt != null) {
              const hasDefault = Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn']
              )(opt, 'default')
              // default values
              if (hasDefault && value === undefined) {
                const defaultValue = opt.default
                if (
                  opt.type !== Function &&
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(defaultValue)
                ) {
                  setCurrentInstance(instance)
                  value = defaultValue(props)
                  setCurrentInstance(null)
                } else {
                  value = defaultValue
                }
              }
              // boolean casting
              if (opt[0 /* shouldCast */]) {
                if (
                  !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    props,
                    key
                  ) &&
                  !hasDefault
                ) {
                  value = false
                } else if (
                  opt[1 /* shouldCastTrue */] &&
                  (value === '' ||
                    value ===
                      Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hyphenate']
                      )(key))
                ) {
                  value = true
                }
              }
            }
            return value
          }
          function normalizePropsOptions(comp, appContext, asMixin = false) {
            if (!appContext.deopt && comp.__props) {
              return comp.__props
            }
            const raw = comp.props
            const normalized = {}
            const needCastKeys = []
            // apply mixin/extends props
            let hasExtends = false
            if (
              __VUE_OPTIONS_API__ &&
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                comp
              )
            ) {
              const extendProps = raw => {
                hasExtends = true
                const [props, keys] = normalizePropsOptions(
                  raw,
                  appContext,
                  true
                )
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                  normalized,
                  props
                )
                if (keys) needCastKeys.push(...keys)
              }
              if (!asMixin && appContext.mixins.length) {
                appContext.mixins.forEach(extendProps)
              }
              if (comp.extends) {
                extendProps(comp.extends)
              }
              if (comp.mixins) {
                comp.mixins.forEach(extendProps)
              }
            }
            if (!raw && !hasExtends) {
              return (comp.__props =
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_ARR'])
            }
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(raw)
            ) {
              for (let i = 0; i < raw.length; i++) {
                if (
                  true &&
                  !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                    raw[i]
                  )
                ) {
                  warn(`props must be strings when using array syntax.`, raw[i])
                }
                const normalizedKey = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize']
                )(raw[i])
                if (validatePropName(normalizedKey)) {
                  normalized[normalizedKey] =
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
                }
              }
            } else if (raw) {
              if (
                true &&
                !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                  raw
                )
              ) {
                warn(`invalid props options`, raw)
              }
              for (const key in raw) {
                const normalizedKey = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize']
                )(key)
                if (validatePropName(normalizedKey)) {
                  const opt = raw[key]
                  const prop = (normalized[normalizedKey] =
                    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                      opt
                    ) ||
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                    )(opt)
                      ? { type: opt }
                      : opt)
                  if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type)
                    const stringIndex = getTypeIndex(String, prop.type)
                    prop[0 /* shouldCast */] = booleanIndex > -1
                    prop[1 /* shouldCastTrue */] =
                      stringIndex < 0 || booleanIndex < stringIndex
                    // if the prop needs boolean casting or default value
                    if (
                      booleanIndex > -1 ||
                      Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn']
                      )(prop, 'default')
                    ) {
                      needCastKeys.push(normalizedKey)
                    }
                  }
                }
              }
            }
            return (comp.__props = [normalized, needCastKeys])
          }
          function validatePropName(key) {
            if (key[0] !== '$') {
              return true
            } else if (true) {
              warn(`Invalid prop name: "${key}" is a reserved property.`)
            }
            return false
          }
          // use function string name to check type constructors
          // so that it works across vms / iframes.
          function getType(ctor) {
            const match = ctor && ctor.toString().match(/^\s*function (\w+)/)
            return match ? match[1] : ''
          }
          function isSameType(a, b) {
            return getType(a) === getType(b)
          }
          function getTypeIndex(type, expectedTypes) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                expectedTypes
              )
            ) {
              for (let i = 0, len = expectedTypes.length; i < len; i++) {
                if (isSameType(expectedTypes[i], type)) {
                  return i
                }
              }
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                expectedTypes
              )
            ) {
              return isSameType(expectedTypes, type) ? 0 : -1
            }
            return -1
          }
          /**
           * dev only
           */
          function validateProps(props, instance) {
            const rawValues = Object(
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
            )(props)
            const options = instance.propsOptions[0]
            for (const key in options) {
              let opt = options[key]
              if (opt == null) continue
              validateProp(
                key,
                rawValues[key],
                opt,
                !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  rawValues,
                  key
                )
              )
            }
          }
          /**
           * dev only
           */
          function validateProp(name, value, prop, isAbsent) {
            const { type, required, validator } = prop
            // required!
            if (required && isAbsent) {
              warn('Missing required prop: "' + name + '"')
              return
            }
            // missing but optional
            if (value == null && !prop.required) {
              return
            }
            // type check
            if (type != null && type !== true) {
              let isValid = false
              const types = Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray']
              )(type)
                ? type
                : [type]
              const expectedTypes = []
              // value is valid as long as one of the specified types match
              for (let i = 0; i < types.length && !isValid; i++) {
                const { valid, expectedType } = assertType(value, types[i])
                expectedTypes.push(expectedType || '')
                isValid = valid
              }
              if (!isValid) {
                warn(getInvalidTypeMessage(name, value, expectedTypes))
                return
              }
            }
            // custom validator
            if (validator && !validator(value)) {
              warn(
                'Invalid prop: custom validator check failed for prop "' +
                  name +
                  '".'
              )
            }
          }
          const isSimpleType = /*#__PURE__*/ Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__['makeMap']
          )('String,Number,Boolean,Function,Symbol,BigInt')
          /**
           * dev only
           */
          function assertType(value, type) {
            let valid
            const expectedType = getType(type)
            if (isSimpleType(expectedType)) {
              const t = typeof value
              valid = t === expectedType.toLowerCase()
              // for primitive wrapper objects
              if (!valid && t === 'object') {
                valid = value instanceof type
              }
            } else if (expectedType === 'Object') {
              valid = Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject']
              )(value)
            } else if (expectedType === 'Array') {
              valid = Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray']
              )(value)
            } else {
              valid = value instanceof type
            }
            return {
              valid,
              expectedType
            }
          }
          /**
           * dev only
           */
          function getInvalidTypeMessage(name, value, expectedTypes) {
            let message =
              `Invalid prop: type check failed for prop "${name}".` +
              ` Expected ${expectedTypes
                .map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['capitalize'])
                .join(', ')}`
            const expectedType = expectedTypes[0]
            const receivedType = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toRawType']
            )(value)
            const expectedValue = styleValue(value, expectedType)
            const receivedValue = styleValue(value, receivedType)
            // check if we need to specify expected value
            if (
              expectedTypes.length === 1 &&
              isExplicable(expectedType) &&
              !isBoolean(expectedType, receivedType)
            ) {
              message += ` with value ${expectedValue}`
            }
            message += `, got ${receivedType} `
            // check if we need to specify received value
            if (isExplicable(receivedType)) {
              message += `with value ${receivedValue}.`
            }
            return message
          }
          /**
           * dev only
           */
          function styleValue(value, type) {
            if (type === 'String') {
              return `"${value}"`
            } else if (type === 'Number') {
              return `${Number(value)}`
            } else {
              return `${value}`
            }
          }
          /**
           * dev only
           */
          function isExplicable(type) {
            const explicitTypes = ['string', 'number', 'boolean']
            return explicitTypes.some(elem => type.toLowerCase() === elem)
          }
          /**
           * dev only
           */
          function isBoolean(...args) {
            return args.some(elem => elem.toLowerCase() === 'boolean')
          }

          function injectHook(
            type,
            hook,
            target = currentInstance,
            prepend = false
          ) {
            if (target) {
              const hooks = target[type] || (target[type] = [])
              // cache the error handling wrapper for injected hooks so the same hook
              // can be properly deduped by the scheduler. "__weh" stands for "with error
              // handling".
              const wrappedHook =
                hook.__weh ||
                (hook.__weh = (...args) => {
                  if (target.isUnmounted) {
                    return
                  }
                  // disable tracking inside all lifecycle hooks
                  // since they can potentially be called inside effects.
                  Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                      'pauseTracking'
                    ]
                  )()
                  // Set currentInstance during hook invocation.
                  // This assumes the hook does not synchronously trigger other hooks, which
                  // can only be false when the user does something really funky.
                  setCurrentInstance(target)
                  const res = callWithAsyncErrorHandling(
                    hook,
                    target,
                    type,
                    args
                  )
                  setCurrentInstance(null)
                  Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                      'resetTracking'
                    ]
                  )()
                  return res
                })
              if (prepend) {
                hooks.unshift(wrappedHook)
              } else {
                hooks.push(wrappedHook)
              }
              return wrappedHook
            } else if (true) {
              const apiName = Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toHandlerKey']
              )(ErrorTypeStrings[type].replace(/ hook$/, ''))
              warn(
                `${apiName} is called when there is no active component instance to be ` +
                  `associated with. ` +
                  `Lifecycle injection APIs can only be used during execution of setup().` +
                  (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`)
              )
            }
          }
          const createHook = lifecycle => (hook, target = currentInstance) =>
            // post-create lifecycle registrations are noops during SSR
            !isInSSRComponentSetup && injectHook(lifecycle, hook, target)
          const onBeforeMount = createHook('bm' /* BEFORE_MOUNT */)
          const onMounted = createHook('m' /* MOUNTED */)
          const onBeforeUpdate = createHook('bu' /* BEFORE_UPDATE */)
          const onUpdated = createHook('u' /* UPDATED */)
          const onBeforeUnmount = createHook('bum' /* BEFORE_UNMOUNT */)
          const onUnmounted = createHook('um' /* UNMOUNTED */)
          const onRenderTriggered = createHook('rtg' /* RENDER_TRIGGERED */)
          const onRenderTracked = createHook('rtc' /* RENDER_TRACKED */)
          const onErrorCaptured = (hook, target = currentInstance) => {
            injectHook('ec' /* ERROR_CAPTURED */, hook, target)
          }

          // Simple effect.
          function watchEffect(effect, options) {
            return doWatch(effect, null, options)
          }
          // initial value for watchers to trigger on undefined initial values
          const INITIAL_WATCHER_VALUE = {}
          // implementation
          function watch(source, cb, options) {
            if (
              true &&
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                cb
              )
            ) {
              warn(
                `\`watch(fn, options?)\` signature has been moved to a separate API. ` +
                  `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
                  `supports \`watch(source, cb, options?) signature.`
              )
            }
            return doWatch(source, cb, options)
          }
          function doWatch(
            source,
            cb,
            {
              immediate,
              deep,
              flush,
              onTrack,
              onTrigger
            } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
            instance = currentInstance
          ) {
            if (true && !cb) {
              if (immediate !== undefined) {
                warn(
                  `watch() "immediate" option is only respected when using the ` +
                    `watch(source, callback, options?) signature.`
                )
              }
              if (deep !== undefined) {
                warn(
                  `watch() "deep" option is only respected when using the ` +
                    `watch(source, callback, options?) signature.`
                )
              }
            }
            const warnInvalidSource = s => {
              warn(
                `Invalid watch source: `,
                s,
                `A watch source can only be a getter/effect function, a ref, ` +
                  `a reactive object, or an array of these types.`
              )
            }
            let getter
            let forceTrigger = false
            if (
              Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef'])(
                source
              )
            ) {
              getter = () => source.value
              forceTrigger = !!source._shallow
            } else if (
              Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isReactive']
              )(source)
            ) {
              getter = () => source
              deep = true
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                source
              )
            ) {
              getter = () =>
                source.map(s => {
                  if (
                    Object(
                      _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef']
                    )(s)
                  ) {
                    return s.value
                  } else if (
                    Object(
                      _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isReactive']
                    )(s)
                  ) {
                    return traverse(s)
                  } else if (
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                    )(s)
                  ) {
                    return callWithErrorHandling(
                      s,
                      instance,
                      2 /* WATCH_GETTER */,
                      [instance && instance.proxy]
                    )
                  } else {
                    true && warnInvalidSource(s)
                  }
                })
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                source
              )
            ) {
              if (cb) {
                // getter with cb
                getter = () =>
                  callWithErrorHandling(
                    source,
                    instance,
                    2 /* WATCH_GETTER */,
                    [instance && instance.proxy]
                  )
              } else {
                // no cb -> simple effect
                getter = () => {
                  if (instance && instance.isUnmounted) {
                    return
                  }
                  if (cleanup) {
                    cleanup()
                  }
                  return callWithErrorHandling(
                    source,
                    instance,
                    3 /* WATCH_CALLBACK */,
                    [onInvalidate]
                  )
                }
              }
            } else {
              getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
              true && warnInvalidSource(source)
            }
            if (cb && deep) {
              const baseGetter = getter
              getter = () => traverse(baseGetter())
            }
            let cleanup
            const onInvalidate = fn => {
              cleanup = runner.options.onStop = () => {
                callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */)
              }
            }
            let oldValue = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray']
            )(source)
              ? []
              : INITIAL_WATCHER_VALUE
            const job = () => {
              if (!runner.active) {
                return
              }
              if (cb) {
                // watch(source, cb)
                const newValue = runner()
                if (
                  deep ||
                  forceTrigger ||
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasChanged']
                  )(newValue, oldValue)
                ) {
                  // cleanup before running cb again
                  if (cleanup) {
                    cleanup()
                  }
                  callWithAsyncErrorHandling(
                    cb,
                    instance,
                    3 /* WATCH_CALLBACK */,
                    [
                      newValue,
                      // pass undefined as the old value when it's changed for the first time
                      oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                      onInvalidate
                    ]
                  )
                  oldValue = newValue
                }
              } else {
                // watchEffect
                runner()
              }
            }
            // important: mark the job as a watcher callback so that scheduler knows
            // it is allowed to self-trigger (#1727)
            job.allowRecurse = !!cb
            let scheduler
            if (flush === 'sync') {
              scheduler = job
            } else if (flush === 'post') {
              scheduler = () =>
                queuePostRenderEffect(job, instance && instance.suspense)
            } else {
              // default: 'pre'
              scheduler = () => {
                if (!instance || instance.isMounted) {
                  queuePreFlushCb(job)
                } else {
                  // with 'pre' option, the first call must happen before
                  // the component is mounted so it is called synchronously.
                  job()
                }
              }
            }
            const runner = Object(
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['effect']
            )(getter, {
              lazy: true,
              onTrack,
              onTrigger,
              scheduler
            })
            recordInstanceBoundEffect(runner, instance)
            // initial run
            if (cb) {
              if (immediate) {
                job()
              } else {
                oldValue = runner()
              }
            } else if (flush === 'post') {
              queuePostRenderEffect(runner, instance && instance.suspense)
            } else {
              runner()
            }
            return () => {
              Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['stop'])(
                runner
              )
              if (instance) {
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['remove'])(
                  instance.effects,
                  runner
                )
              }
            }
          }
          // this.$watch
          function instanceWatch(source, cb, options) {
            const publicThis = this.proxy
            const getter = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString']
            )(source)
              ? () => publicThis[source]
              : source.bind(publicThis)
            return doWatch(getter, cb.bind(publicThis), options, this)
          }
          function traverse(value, seen = new Set()) {
            if (
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                value
              ) ||
              seen.has(value)
            ) {
              return value
            }
            seen.add(value)
            if (
              Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef'])(
                value
              )
            ) {
              traverse(value.value, seen)
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(value)
            ) {
              for (let i = 0; i < value.length; i++) {
                traverse(value[i], seen)
              }
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isSet'])(
                value
              ) ||
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isMap'])(value)
            ) {
              value.forEach(v => {
                traverse(v, seen)
              })
            } else {
              for (const key in value) {
                traverse(value[key], seen)
              }
            }
            return value
          }

          function useTransitionState() {
            const state = {
              isMounted: false,
              isLeaving: false,
              isUnmounting: false,
              leavingVNodes: new Map()
            }
            onMounted(() => {
              state.isMounted = true
            })
            onBeforeUnmount(() => {
              state.isUnmounting = true
            })
            return state
          }
          const TransitionHookValidator = [Function, Array]
          const BaseTransitionImpl = {
            name: `BaseTransition`,
            props: {
              mode: String,
              appear: Boolean,
              persisted: Boolean,
              // enter
              onBeforeEnter: TransitionHookValidator,
              onEnter: TransitionHookValidator,
              onAfterEnter: TransitionHookValidator,
              onEnterCancelled: TransitionHookValidator,
              // leave
              onBeforeLeave: TransitionHookValidator,
              onLeave: TransitionHookValidator,
              onAfterLeave: TransitionHookValidator,
              onLeaveCancelled: TransitionHookValidator,
              // appear
              onBeforeAppear: TransitionHookValidator,
              onAppear: TransitionHookValidator,
              onAfterAppear: TransitionHookValidator,
              onAppearCancelled: TransitionHookValidator
            },
            setup(props, { slots }) {
              const instance = getCurrentInstance()
              const state = useTransitionState()
              let prevTransitionKey
              return () => {
                const children =
                  slots.default &&
                  getTransitionRawChildren(slots.default(), true)
                if (!children || !children.length) {
                  return
                }
                // warn multiple elements
                if (true && children.length > 1) {
                  warn(
                    '<transition> can only be used on a single element or component. Use ' +
                      '<transition-group> for lists.'
                  )
                }
                // there's no need to track reactivity for these props so use the raw
                // props for a bit better perf
                const rawProps = Object(
                  _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
                )(props)
                const { mode } = rawProps
                // check mode
                if (
                  true &&
                  mode &&
                  !['in-out', 'out-in', 'default'].includes(mode)
                ) {
                  warn(`invalid <transition> mode: ${mode}`)
                }
                // at this point children has a guaranteed length of 1.
                const child = children[0]
                if (state.isLeaving) {
                  return emptyPlaceholder(child)
                }
                // in the case of <transition><keep-alive/></transition>, we need to
                // compare the type of the kept-alive children.
                const innerChild = getKeepAliveChild(child)
                if (!innerChild) {
                  return emptyPlaceholder(child)
                }
                const enterHooks = resolveTransitionHooks(
                  innerChild,
                  rawProps,
                  state,
                  instance
                )
                setTransitionHooks(innerChild, enterHooks)
                const oldChild = instance.subTree
                const oldInnerChild = oldChild && getKeepAliveChild(oldChild)
                let transitionKeyChanged = false
                const { getTransitionKey } = innerChild.type
                if (getTransitionKey) {
                  const key = getTransitionKey()
                  if (prevTransitionKey === undefined) {
                    prevTransitionKey = key
                  } else if (key !== prevTransitionKey) {
                    prevTransitionKey = key
                    transitionKeyChanged = true
                  }
                }
                // handle mode
                if (
                  oldInnerChild &&
                  oldInnerChild.type !== Comment &&
                  (!isSameVNodeType(innerChild, oldInnerChild) ||
                    transitionKeyChanged)
                ) {
                  const leavingHooks = resolveTransitionHooks(
                    oldInnerChild,
                    rawProps,
                    state,
                    instance
                  )
                  // update old tree's hooks in case of dynamic transition
                  setTransitionHooks(oldInnerChild, leavingHooks)
                  // switching between different views
                  if (mode === 'out-in') {
                    state.isLeaving = true
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                      state.isLeaving = false
                      instance.update()
                    }
                    return emptyPlaceholder(child)
                  } else if (mode === 'in-out') {
                    leavingHooks.delayLeave = (
                      el,
                      earlyRemove,
                      delayedLeave
                    ) => {
                      const leavingVNodesCache = getLeavingNodesForType(
                        state,
                        oldInnerChild
                      )
                      leavingVNodesCache[
                        String(oldInnerChild.key)
                      ] = oldInnerChild
                      // early removal callback
                      el._leaveCb = () => {
                        earlyRemove()
                        el._leaveCb = undefined
                        delete enterHooks.delayedLeave
                      }
                      enterHooks.delayedLeave = delayedLeave
                    }
                  }
                }
                return child
              }
            }
          }
          // export the public type for h/tsx inference
          // also to avoid inline import() in generated d.ts files
          const BaseTransition = BaseTransitionImpl
          function getLeavingNodesForType(state, vnode) {
            const { leavingVNodes } = state
            let leavingVNodesCache = leavingVNodes.get(vnode.type)
            if (!leavingVNodesCache) {
              leavingVNodesCache = Object.create(null)
              leavingVNodes.set(vnode.type, leavingVNodesCache)
            }
            return leavingVNodesCache
          }
          // The transition hooks are attached to the vnode as vnode.transition
          // and will be called at appropriate timing in the renderer.
          function resolveTransitionHooks(vnode, props, state, instance) {
            const {
              appear,
              mode,
              persisted = false,
              onBeforeEnter,
              onEnter,
              onAfterEnter,
              onEnterCancelled,
              onBeforeLeave,
              onLeave,
              onAfterLeave,
              onLeaveCancelled,
              onBeforeAppear,
              onAppear,
              onAfterAppear,
              onAppearCancelled
            } = props
            const key = String(vnode.key)
            const leavingVNodesCache = getLeavingNodesForType(state, vnode)
            const callHook = (hook, args) => {
              hook &&
                callWithAsyncErrorHandling(
                  hook,
                  instance,
                  9 /* TRANSITION_HOOK */,
                  args
                )
            }
            const hooks = {
              mode,
              persisted,
              beforeEnter(el) {
                let hook = onBeforeEnter
                if (!state.isMounted) {
                  if (appear) {
                    hook = onBeforeAppear || onBeforeEnter
                  } else {
                    return
                  }
                }
                // for same element (v-show)
                if (el._leaveCb) {
                  el._leaveCb(true /* cancelled */)
                }
                // for toggled element with same key (v-if)
                const leavingVNode = leavingVNodesCache[key]
                if (
                  leavingVNode &&
                  isSameVNodeType(vnode, leavingVNode) &&
                  leavingVNode.el._leaveCb
                ) {
                  // force early removal (not cancelled)
                  leavingVNode.el._leaveCb()
                }
                callHook(hook, [el])
              },
              enter(el) {
                let hook = onEnter
                let afterHook = onAfterEnter
                let cancelHook = onEnterCancelled
                if (!state.isMounted) {
                  if (appear) {
                    hook = onAppear || onEnter
                    afterHook = onAfterAppear || onAfterEnter
                    cancelHook = onAppearCancelled || onEnterCancelled
                  } else {
                    return
                  }
                }
                let called = false
                const done = (el._enterCb = cancelled => {
                  if (called) return
                  called = true
                  if (cancelled) {
                    callHook(cancelHook, [el])
                  } else {
                    callHook(afterHook, [el])
                  }
                  if (hooks.delayedLeave) {
                    hooks.delayedLeave()
                  }
                  el._enterCb = undefined
                })
                if (hook) {
                  hook(el, done)
                  if (hook.length <= 1) {
                    done()
                  }
                } else {
                  done()
                }
              },
              leave(el, remove) {
                const key = String(vnode.key)
                if (el._enterCb) {
                  el._enterCb(true /* cancelled */)
                }
                if (state.isUnmounting) {
                  return remove()
                }
                callHook(onBeforeLeave, [el])
                let called = false
                const done = (el._leaveCb = cancelled => {
                  if (called) return
                  called = true
                  remove()
                  if (cancelled) {
                    callHook(onLeaveCancelled, [el])
                  } else {
                    callHook(onAfterLeave, [el])
                  }
                  el._leaveCb = undefined
                  if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key]
                  }
                })
                leavingVNodesCache[key] = vnode
                if (onLeave) {
                  onLeave(el, done)
                  if (onLeave.length <= 1) {
                    done()
                  }
                } else {
                  done()
                }
              },
              clone(vnode) {
                return resolveTransitionHooks(vnode, props, state, instance)
              }
            }
            return hooks
          }
          // the placeholder really only handles one special case: KeepAlive
          // in the case of a KeepAlive in a leave phase we need to return a KeepAlive
          // placeholder with empty content to avoid the KeepAlive instance from being
          // unmounted.
          function emptyPlaceholder(vnode) {
            if (isKeepAlive(vnode)) {
              vnode = cloneVNode(vnode)
              vnode.children = null
              return vnode
            }
          }
          function getKeepAliveChild(vnode) {
            return isKeepAlive(vnode)
              ? vnode.children
                ? vnode.children[0]
                : undefined
              : vnode
          }
          function setTransitionHooks(vnode, hooks) {
            if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
              setTransitionHooks(vnode.component.subTree, hooks)
            } else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
              vnode.ssContent.transition = hooks.clone(vnode.ssContent)
              vnode.ssFallback.transition = hooks.clone(vnode.ssFallback)
            } else {
              vnode.transition = hooks
            }
          }
          function getTransitionRawChildren(children, keepComment = false) {
            let ret = []
            let keyedFragmentCount = 0
            for (let i = 0; i < children.length; i++) {
              const child = children[i]
              // handle fragment children case, e.g. v-for
              if (child.type === Fragment) {
                if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                  keyedFragmentCount++
                ret = ret.concat(
                  getTransitionRawChildren(child.children, keepComment)
                )
              }
              // comment placeholders should be skipped, e.g. v-if
              else if (keepComment || child.type !== Comment) {
                ret.push(child)
              }
            }
            // #1126 if a transition children list contains multiple sub fragments, these
            // fragments will be merged into a flat children array. Since each v-for
            // fragment may contain different static bindings inside, we need to de-op
            // these children to force full diffs to ensure correct behavior.
            if (keyedFragmentCount > 1) {
              for (let i = 0; i < ret.length; i++) {
                ret[i].patchFlag = -2 /* BAIL */
              }
            }
            return ret
          }

          const isKeepAlive = vnode => vnode.type.__isKeepAlive
          const KeepAliveImpl = {
            name: `KeepAlive`,
            // Marker for special handling inside the renderer. We are not using a ===
            // check directly on KeepAlive in the renderer, because importing it directly
            // would prevent it from being tree-shaken.
            __isKeepAlive: true,
            props: {
              include: [String, RegExp, Array],
              exclude: [String, RegExp, Array],
              max: [String, Number]
            },
            setup(props, { slots }) {
              const cache = new Map()
              const keys = new Set()
              let current = null
              const instance = getCurrentInstance()
              const parentSuspense = instance.suspense
              // KeepAlive communicates with the instantiated renderer via the
              // ctx where the renderer passes in its internals,
              // and the KeepAlive instance exposes activate/deactivate implementations.
              // The whole point of this is to avoid importing KeepAlive directly in the
              // renderer to facilitate tree-shaking.
              const sharedContext = instance.ctx
              const {
                renderer: {
                  p: patch,
                  m: move,
                  um: _unmount,
                  o: { createElement }
                }
              } = sharedContext
              const storageContainer = createElement('div')
              sharedContext.activate = (
                vnode,
                container,
                anchor,
                isSVG,
                optimized
              ) => {
                const instance = vnode.component
                move(vnode, container, anchor, 0 /* ENTER */, parentSuspense)
                // in case props have changed
                patch(
                  instance.vnode,
                  vnode,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  isSVG,
                  optimized
                )
                queuePostRenderEffect(() => {
                  instance.isDeactivated = false
                  if (instance.a) {
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['invokeArrayFns']
                    )(instance.a)
                  }
                  const vnodeHook = vnode.props && vnode.props.onVnodeMounted
                  if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode)
                  }
                }, parentSuspense)
              }
              sharedContext.deactivate = vnode => {
                const instance = vnode.component
                move(
                  vnode,
                  storageContainer,
                  null,
                  1 /* LEAVE */,
                  parentSuspense
                )
                queuePostRenderEffect(() => {
                  if (instance.da) {
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['invokeArrayFns']
                    )(instance.da)
                  }
                  const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted
                  if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode)
                  }
                  instance.isDeactivated = true
                }, parentSuspense)
              }
              function unmount(vnode) {
                // reset the shapeFlag so it can be properly unmounted
                resetShapeFlag(vnode)
                _unmount(vnode, instance, parentSuspense)
              }
              function pruneCache(filter) {
                cache.forEach((vnode, key) => {
                  const name = getComponentName(vnode.type)
                  if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key)
                  }
                })
              }
              function pruneCacheEntry(key) {
                const cached = cache.get(key)
                if (!current || cached.type !== current.type) {
                  unmount(cached)
                } else if (current) {
                  // current active instance should no longer be kept-alive.
                  // we can't unmount it now but it might be later, so reset its flag now.
                  resetShapeFlag(current)
                }
                cache.delete(key)
                keys.delete(key)
              }
              // prune cache on include/exclude prop change
              watch(
                () => [props.include, props.exclude],
                ([include, exclude]) => {
                  include && pruneCache(name => matches(include, name))
                  exclude && pruneCache(name => !matches(exclude, name))
                },
                // prune post-render after `current` has been updated
                { flush: 'post', deep: true }
              )
              // cache sub tree after render
              let pendingCacheKey = null
              const cacheSubtree = () => {
                // fix #1621, the pendingCacheKey could be 0
                if (pendingCacheKey != null) {
                  cache.set(pendingCacheKey, getInnerChild(instance.subTree))
                }
              }
              onMounted(cacheSubtree)
              onUpdated(cacheSubtree)
              onBeforeUnmount(() => {
                cache.forEach(cached => {
                  const { subTree, suspense } = instance
                  const vnode = getInnerChild(subTree)
                  if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode)
                    // but invoke its deactivated hook here
                    const da = vnode.component.da
                    da && queuePostRenderEffect(da, suspense)
                    return
                  }
                  unmount(cached)
                })
              })
              return () => {
                pendingCacheKey = null
                if (!slots.default) {
                  return null
                }
                const children = slots.default()
                const rawVNode = children[0]
                if (children.length > 1) {
                  if (true) {
                    warn(
                      `KeepAlive should contain exactly one component child.`
                    )
                  }
                  current = null
                  return children
                } else if (
                  !isVNode(rawVNode) ||
                  (!(rawVNode.shapeFlag & 4) /* STATEFUL_COMPONENT */ &&
                    !(rawVNode.shapeFlag & 128) /* SUSPENSE */)
                ) {
                  current = null
                  return rawVNode
                }
                let vnode = getInnerChild(rawVNode)
                const comp = vnode.type
                const name = getComponentName(comp)
                const { include, exclude, max } = props
                if (
                  (include && (!name || !matches(include, name))) ||
                  (exclude && name && matches(exclude, name))
                ) {
                  current = vnode
                  return rawVNode
                }
                const key = vnode.key == null ? comp : vnode.key
                const cachedVNode = cache.get(key)
                // clone vnode if it's reused because we are going to mutate it
                if (vnode.el) {
                  vnode = cloneVNode(vnode)
                  if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                    rawVNode.ssContent = vnode
                  }
                }
                // #1513 it's possible for the returned vnode to be cloned due to attr
                // fallthrough or scopeId, so the vnode here may not be the final vnode
                // that is mounted. Instead of caching it directly, we store the pending
                // key and cache `instance.subTree` (the normalized vnode) in
                // beforeMount/beforeUpdate hooks.
                pendingCacheKey = key
                if (cachedVNode) {
                  // copy over mounted state
                  vnode.el = cachedVNode.el
                  vnode.component = cachedVNode.component
                  if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition)
                  }
                  // avoid vnode being mounted as fresh
                  vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */
                  // make this key the freshest
                  keys.delete(key)
                  keys.add(key)
                } else {
                  keys.add(key)
                  // prune oldest entry
                  if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value)
                  }
                }
                // avoid vnode being unmounted
                vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */
                current = vnode
                return rawVNode
              }
            }
          }
          // export the public type for h/tsx inference
          // also to avoid inline import() in generated d.ts files
          const KeepAlive = KeepAliveImpl
          function matches(pattern, name) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                pattern
              )
            ) {
              return pattern.some(p => matches(p, name))
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                pattern
              )
            ) {
              return pattern.split(',').indexOf(name) > -1
            } else if (pattern.test) {
              return pattern.test(name)
            }
            /* istanbul ignore next */
            return false
          }
          function onActivated(hook, target) {
            registerKeepAliveHook(hook, 'a' /* ACTIVATED */, target)
          }
          function onDeactivated(hook, target) {
            registerKeepAliveHook(hook, 'da' /* DEACTIVATED */, target)
          }
          function registerKeepAliveHook(hook, type, target = currentInstance) {
            // cache the deactivate branch check wrapper for injected hooks so the same
            // hook can be properly deduped by the scheduler. "__wdc" stands for "with
            // deactivation check".
            const wrappedHook =
              hook.__wdc ||
              (hook.__wdc = () => {
                // only fire the hook if the target instance is NOT in a deactivated branch.
                let current = target
                while (current) {
                  if (current.isDeactivated) {
                    return
                  }
                  current = current.parent
                }
                hook()
              })
            injectHook(type, wrappedHook, target)
            // In addition to registering it on the target instance, we walk up the parent
            // chain and register it on all ancestor instances that are keep-alive roots.
            // This avoids the need to walk the entire component tree when invoking these
            // hooks, and more importantly, avoids the need to track child components in
            // arrays.
            if (target) {
              let current = target.parent
              while (current && current.parent) {
                if (isKeepAlive(current.parent.vnode)) {
                  injectToKeepAliveRoot(wrappedHook, type, target, current)
                }
                current = current.parent
              }
            }
          }
          function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
            // injectHook wraps the original for error handling, so make sure to remove
            // the wrapped version.
            const injected = injectHook(
              type,
              hook,
              keepAliveRoot,
              true /* prepend */
            )
            onUnmounted(() => {
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['remove'])(
                keepAliveRoot[type],
                injected
              )
            }, target)
          }
          function resetShapeFlag(vnode) {
            let shapeFlag = vnode.shapeFlag
            if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
              shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */
            }
            if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
              shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */
            }
            vnode.shapeFlag = shapeFlag
          }
          function getInnerChild(vnode) {
            return vnode.shapeFlag & 128 /* SUSPENSE */
              ? vnode.ssContent
              : vnode
          }

          const isInternalKey = key => key[0] === '_' || key === '$stable'
          const normalizeSlotValue = value =>
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(value)
              ? value.map(normalizeVNode)
              : [normalizeVNode(value)]
          const normalizeSlot = (key, rawSlot, ctx) =>
            withCtx(props => {
              if (true && currentInstance) {
                warn(
                  `Slot "${key}" invoked outside of the render function: ` +
                    `this will not track dependencies used in the slot. ` +
                    `Invoke the slot function inside the render function instead.`
                )
              }
              return normalizeSlotValue(rawSlot(props))
            }, ctx)
          const normalizeObjectSlots = (rawSlots, slots) => {
            const ctx = rawSlots._ctx
            for (const key in rawSlots) {
              if (isInternalKey(key)) continue
              const value = rawSlots[key]
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                  value
                )
              ) {
                slots[key] = normalizeSlot(key, value, ctx)
              } else if (value != null) {
                if (true) {
                  warn(
                    `Non-function value encountered for slot "${key}". ` +
                      `Prefer function slots for better performance.`
                  )
                }
                const normalized = normalizeSlotValue(value)
                slots[key] = () => normalized
              }
            }
          }
          const normalizeVNodeSlots = (instance, children) => {
            if (true && !isKeepAlive(instance.vnode)) {
              warn(
                `Non-function value encountered for default slot. ` +
                  `Prefer function slots for better performance.`
              )
            }
            const normalized = normalizeSlotValue(children)
            instance.slots.default = () => normalized
          }
          const initSlots = (instance, children) => {
            if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
              const type = children._
              if (type) {
                instance.slots = children
                // make compiler marker non-enumerable
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['def'])(
                  children,
                  '_',
                  type
                )
              } else {
                normalizeObjectSlots(children, (instance.slots = {}))
              }
            } else {
              instance.slots = {}
              if (children) {
                normalizeVNodeSlots(instance, children)
              }
            }
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['def'])(
              instance.slots,
              InternalObjectKey,
              1
            )
          }
          const updateSlots = (instance, children) => {
            const { vnode, slots } = instance
            let needDeletionCheck = true
            let deletionComparisonTarget =
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
            if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
              const type = children._
              if (type) {
                // compiled slots.
                if (true && isHmrUpdating) {
                  // Parent was HMR updated so slot content may have changed.
                  // force update slots and mark instance for hmr as well
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                    slots,
                    children
                  )
                } else if (type === 1 /* STABLE */) {
                  // compiled AND stable.
                  // no need to update, and skip stale slots removal.
                  needDeletionCheck = false
                } else {
                  // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                  // normalization.
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                    slots,
                    children
                  )
                }
              } else {
                needDeletionCheck = !children.$stable
                normalizeObjectSlots(children, slots)
              }
              deletionComparisonTarget = children
            } else if (children) {
              // non slot object children (direct value) passed to a component
              normalizeVNodeSlots(instance, children)
              deletionComparisonTarget = { default: 1 }
            }
            // delete stale slots
            if (needDeletionCheck) {
              for (const key in slots) {
                if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                  delete slots[key]
                }
              }
            }
          }

          /**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
          const isBuiltInDirective = /*#__PURE__*/ Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__['makeMap']
          )(
            'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text'
          )
          function validateDirectiveName(name) {
            if (isBuiltInDirective(name)) {
              warn(
                'Do not use built-in directive ids as custom directive id: ' +
                  name
              )
            }
          }
          /**
           * Adds directives to a VNode.
           */
          function withDirectives(vnode, directives) {
            const internalInstance = currentRenderingInstance
            if (internalInstance === null) {
              true &&
                warn(`withDirectives can only be used inside render functions.`)
              return vnode
            }
            const instance = internalInstance.proxy
            const bindings = vnode.dirs || (vnode.dirs = [])
            for (let i = 0; i < directives.length; i++) {
              let [
                dir,
                value,
                arg,
                modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                  'EMPTY_OBJ'
                ]
              ] = directives[i]
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                  dir
                )
              ) {
                dir = {
                  mounted: dir,
                  updated: dir
                }
              }
              bindings.push({
                dir,
                instance,
                value,
                oldValue: void 0,
                arg,
                modifiers
              })
            }
            return vnode
          }
          function invokeDirectiveHook(vnode, prevVNode, instance, name) {
            const bindings = vnode.dirs
            const oldBindings = prevVNode && prevVNode.dirs
            for (let i = 0; i < bindings.length; i++) {
              const binding = bindings[i]
              if (oldBindings) {
                binding.oldValue = oldBindings[i].value
              }
              const hook = binding.dir[name]
              if (hook) {
                callWithAsyncErrorHandling(
                  hook,
                  instance,
                  8 /* DIRECTIVE_HOOK */,
                  [vnode.el, binding, vnode, prevVNode]
                )
              }
            }
          }

          function createAppContext() {
            return {
              app: null,
              config: {
                isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NO'],
                performance: false,
                globalProperties: {},
                optionMergeStrategies: {},
                isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NO'],
                errorHandler: undefined,
                warnHandler: undefined
              },
              mixins: [],
              components: {},
              directives: {},
              provides: Object.create(null)
            }
          }
          let uid = 0
          function createAppAPI(render, hydrate) {
            return function createApp(rootComponent, rootProps = null) {
              if (
                rootProps != null &&
                !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                  rootProps
                )
              ) {
                true &&
                  warn(`root props passed to app.mount() must be an object.`)
                rootProps = null
              }
              const context = createAppContext()
              const installedPlugins = new Set()
              let isMounted = false
              const app = (context.app = {
                _uid: uid++,
                _component: rootComponent,
                _props: rootProps,
                _container: null,
                _context: context,
                version,
                get config() {
                  return context.config
                },
                set config(v) {
                  if (true) {
                    warn(
                      `app.config cannot be replaced. Modify individual options instead.`
                    )
                  }
                },
                use(plugin, ...options) {
                  if (installedPlugins.has(plugin)) {
                    true &&
                      warn(`Plugin has already been applied to target app.`)
                  } else if (
                    plugin &&
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                    )(plugin.install)
                  ) {
                    installedPlugins.add(plugin)
                    plugin.install(app, ...options)
                  } else if (
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                    )(plugin)
                  ) {
                    installedPlugins.add(plugin)
                    plugin(app, ...options)
                  } else if (true) {
                    warn(
                      `A plugin must either be a function or an object with an "install" ` +
                        `function.`
                    )
                  }
                  return app
                },
                mixin(mixin) {
                  if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) {
                      context.mixins.push(mixin)
                      // global mixin with props/emits de-optimizes props/emits
                      // normalization caching.
                      if (mixin.props || mixin.emits) {
                        context.deopt = true
                      }
                    } else if (true) {
                      warn(
                        'Mixin has already been applied to target app' +
                          (mixin.name ? `: ${mixin.name}` : '')
                      )
                    }
                  } else if (true) {
                    warn(
                      'Mixins are only available in builds supporting Options API'
                    )
                  }
                  return app
                },
                component(name, component) {
                  if (true) {
                    validateComponentName(name, context.config)
                  }
                  if (!component) {
                    return context.components[name]
                  }
                  if (true && context.components[name]) {
                    warn(
                      `Component "${name}" has already been registered in target app.`
                    )
                  }
                  context.components[name] = component
                  return app
                },
                directive(name, directive) {
                  if (true) {
                    validateDirectiveName(name)
                  }
                  if (!directive) {
                    return context.directives[name]
                  }
                  if (true && context.directives[name]) {
                    warn(
                      `Directive "${name}" has already been registered in target app.`
                    )
                  }
                  context.directives[name] = directive
                  return app
                },
                mount(rootContainer, isHydrate) {
                  if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps)
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context
                    // HMR root reload
                    if (true) {
                      context.reload = () => {
                        render(cloneVNode(vnode), rootContainer)
                      }
                    }
                    if (isHydrate && hydrate) {
                      hydrate(vnode, rootContainer)
                    } else {
                      render(vnode, rootContainer)
                    }
                    isMounted = true
                    app._container = rootContainer
                    rootContainer.__vue_app__ = app
                    if (true) {
                      devtoolsInitApp(app, version)
                    }
                    return vnode.component.proxy
                  } else if (true) {
                    warn(
                      `App has already been mounted.\n` +
                        `If you want to remount the same app, move your app creation logic ` +
                        `into a factory function and create fresh app instances for each ` +
                        `mount - e.g. \`const createMyApp = () => createApp(App)\``
                    )
                  }
                },
                unmount() {
                  if (isMounted) {
                    render(null, app._container)
                    if (true) {
                      devtoolsUnmountApp(app)
                    }
                    delete app._container.__vue_app__
                  } else if (true) {
                    warn(`Cannot unmount an app that is not mounted.`)
                  }
                },
                provide(key, value) {
                  if (true && key in context.provides) {
                    warn(
                      `App already provides property with key "${String(
                        key
                      )}". ` + `It will be overwritten with the new value.`
                    )
                  }
                  // TypeScript doesn't allow symbols as index type
                  // https://github.com/Microsoft/TypeScript/issues/24587
                  context.provides[key] = value
                  return app
                }
              })
              return app
            }
          }

          let hasMismatch = false
          const isSVGContainer = container =>
            /svg/.test(container.namespaceURI) &&
            container.tagName !== 'foreignObject'
          const isComment = node => node.nodeType === 8 /* COMMENT */
          // Note: hydration is DOM-specific
          // But we have to place it in core due to tight coupling with core - splitting
          // it out creates a ton of unnecessary complexity.
          // Hydration also depends on some renderer internal logic which needs to be
          // passed in via arguments.
          function createHydrationFunctions(rendererInternals) {
            const {
              mt: mountComponent,
              p: patch,
              o: {
                patchProp,
                nextSibling,
                parentNode,
                remove,
                insert,
                createComment
              }
            } = rendererInternals
            const hydrate = (vnode, container) => {
              if (true && !container.hasChildNodes()) {
                warn(
                  `Attempting to hydrate existing markup but container is empty. ` +
                    `Performing full mount instead.`
                )
                patch(null, vnode, container)
                return
              }
              hasMismatch = false
              hydrateNode(container.firstChild, vnode, null, null)
              flushPostFlushCbs()
              if (hasMismatch && !false) {
                // this error should show up in production
                console.error(`Hydration completed but contains mismatches.`)
              }
            }
            const hydrateNode = (
              node,
              vnode,
              parentComponent,
              parentSuspense,
              optimized = false
            ) => {
              const isFragmentStart = isComment(node) && node.data === '['
              const onMismatch = () =>
                handleMismatch(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  isFragmentStart
                )
              const { type, ref, shapeFlag } = vnode
              const domType = node.nodeType
              vnode.el = node
              let nextNode = null
              switch (type) {
                case Text:
                  if (domType !== 3 /* TEXT */) {
                    nextNode = onMismatch()
                  } else {
                    if (node.data !== vnode.children) {
                      hasMismatch = true
                      true &&
                        warn(
                          `Hydration text mismatch:` +
                            `\n- Client: ${JSON.stringify(node.data)}` +
                            `\n- Server: ${JSON.stringify(vnode.children)}`
                        )
                      node.data = vnode.children
                    }
                    nextNode = nextSibling(node)
                  }
                  break
                case Comment:
                  if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch()
                  } else {
                    nextNode = nextSibling(node)
                  }
                  break
                case Static:
                  if (domType !== 1 /* ELEMENT */) {
                    nextNode = onMismatch()
                  } else {
                    // determine anchor, adopt content
                    nextNode = node
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length
                    for (let i = 0; i < vnode.staticCount; i++) {
                      if (needToAdoptContent)
                        vnode.children += nextNode.outerHTML
                      if (i === vnode.staticCount - 1) {
                        vnode.anchor = nextNode
                      }
                      nextNode = nextSibling(nextNode)
                    }
                    return nextNode
                  }
                  break
                case Fragment:
                  if (!isFragmentStart) {
                    nextNode = onMismatch()
                  } else {
                    nextNode = hydrateFragment(
                      node,
                      vnode,
                      parentComponent,
                      parentSuspense,
                      optimized
                    )
                  }
                  break
                default:
                  if (shapeFlag & 1 /* ELEMENT */) {
                    if (
                      domType !== 1 /* ELEMENT */ ||
                      vnode.type !== node.tagName.toLowerCase()
                    ) {
                      nextNode = onMismatch()
                    } else {
                      nextNode = hydrateElement(
                        node,
                        vnode,
                        parentComponent,
                        parentSuspense,
                        optimized
                      )
                    }
                  } else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    const container = parentNode(node)
                    const hydrateComponent = () => {
                      mountComponent(
                        vnode,
                        container,
                        null,
                        parentComponent,
                        parentSuspense,
                        isSVGContainer(container),
                        optimized
                      )
                    }
                    // async component
                    const loadAsync = vnode.type.__asyncLoader
                    if (loadAsync) {
                      loadAsync().then(hydrateComponent)
                    } else {
                      hydrateComponent()
                    }
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                      ? locateClosingAsyncAnchor(node)
                      : nextSibling(node)
                  } else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                      nextNode = onMismatch()
                    } else {
                      nextNode = vnode.type.hydrate(
                        node,
                        vnode,
                        parentComponent,
                        parentSuspense,
                        optimized,
                        rendererInternals,
                        hydrateChildren
                      )
                    }
                  } else if (shapeFlag & 128 /* SUSPENSE */) {
                    nextNode = vnode.type.hydrate(
                      node,
                      vnode,
                      parentComponent,
                      parentSuspense,
                      isSVGContainer(parentNode(node)),
                      optimized,
                      rendererInternals,
                      hydrateNode
                    )
                  } else if (true) {
                    warn('Invalid HostVNode type:', type, `(${typeof type})`)
                  }
              }
              if (ref != null) {
                setRef(ref, null, parentSuspense, vnode)
              }
              return nextNode
            }
            const hydrateElement = (
              el,
              vnode,
              parentComponent,
              parentSuspense,
              optimized
            ) => {
              optimized = optimized || !!vnode.dynamicChildren
              const { props, patchFlag, shapeFlag, dirs } = vnode
              // skip props & children if this is hoisted static nodes
              if (patchFlag !== -1 /* HOISTED */) {
                if (dirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'created')
                }
                // props
                if (props) {
                  if (
                    !optimized ||
                    (patchFlag & 16 /* FULL_PROPS */ ||
                      patchFlag & 32) /* HYDRATE_EVENTS */
                  ) {
                    for (const key in props) {
                      if (
                        !Object(
                          _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                            'isReservedProp'
                          ]
                        )(key) &&
                        Object(
                          _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isOn']
                        )(key)
                      ) {
                        patchProp(el, key, null, props[key])
                      }
                    }
                  } else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick)
                  }
                }
                // vnode / directive hooks
                let vnodeHooks
                if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                  invokeVNodeHook(vnodeHooks, parentComponent, vnode)
                }
                if (dirs) {
                  invokeDirectiveHook(
                    vnode,
                    null,
                    parentComponent,
                    'beforeMount'
                  )
                }
                if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                  queueEffectWithSuspense(() => {
                    vnodeHooks &&
                      invokeVNodeHook(vnodeHooks, parentComponent, vnode)
                    dirs &&
                      invokeDirectiveHook(
                        vnode,
                        null,
                        parentComponent,
                        'mounted'
                      )
                  }, parentSuspense)
                }
                // children
                if (
                  shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                  // skip if element has innerHTML / textContent
                  !(props && (props.innerHTML || props.textContent))
                ) {
                  let next = hydrateChildren(
                    el.firstChild,
                    vnode,
                    el,
                    parentComponent,
                    parentSuspense,
                    optimized
                  )
                  let hasWarned = false
                  while (next) {
                    hasMismatch = true
                    if (true && !hasWarned) {
                      warn(
                        `Hydration children mismatch in <${vnode.type}>: ` +
                          `server rendered element contains more child nodes than client vdom.`
                      )
                      hasWarned = true
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next
                    next = next.nextSibling
                    remove(cur)
                  }
                } else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                  if (el.textContent !== vnode.children) {
                    hasMismatch = true
                    true &&
                      warn(
                        `Hydration text content mismatch in <${
                          vnode.type
                        }>:\n` +
                          `- Client: ${el.textContent}\n` +
                          `- Server: ${vnode.children}`
                      )
                    el.textContent = vnode.children
                  }
                }
              }
              return el.nextSibling
            }
            const hydrateChildren = (
              node,
              parentVNode,
              container,
              parentComponent,
              parentSuspense,
              optimized
            ) => {
              optimized = optimized || !!parentVNode.dynamicChildren
              const children = parentVNode.children
              const l = children.length
              let hasWarned = false
              for (let i = 0; i < l; i++) {
                const vnode = optimized
                  ? children[i]
                  : (children[i] = normalizeVNode(children[i]))
                if (node) {
                  node = hydrateNode(
                    node,
                    vnode,
                    parentComponent,
                    parentSuspense,
                    optimized
                  )
                } else {
                  hasMismatch = true
                  if (true && !hasWarned) {
                    warn(
                      `Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                        `server rendered element contains fewer child nodes than client vdom.`
                    )
                    hasWarned = true
                  }
                  // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                  patch(
                    null,
                    vnode,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVGContainer(container)
                  )
                }
              }
              return node
            }
            const hydrateFragment = (
              node,
              vnode,
              parentComponent,
              parentSuspense,
              optimized
            ) => {
              const container = parentNode(node)
              const next = hydrateChildren(
                nextSibling(node),
                vnode,
                container,
                parentComponent,
                parentSuspense,
                optimized
              )
              if (next && isComment(next) && next.data === ']') {
                return nextSibling((vnode.anchor = next))
              } else {
                // fragment didn't hydrate successfully, since we didn't get a end anchor
                // back. This should have led to node/children mismatch warnings.
                hasMismatch = true
                // since the anchor is missing, we need to create one and insert it
                insert((vnode.anchor = createComment(`]`)), container, next)
                return next
              }
            }
            const handleMismatch = (
              node,
              vnode,
              parentComponent,
              parentSuspense,
              isFragment
            ) => {
              hasMismatch = true
              true &&
                warn(
                  `Hydration node mismatch:\n- Client vnode:`,
                  vnode.type,
                  `\n- Server rendered DOM:`,
                  node,
                  node.nodeType === 3 /* TEXT */
                    ? `(text)`
                    : isComment(node) && node.data === '['
                      ? `(start of fragment)`
                      : ``
                )
              vnode.el = null
              if (isFragment) {
                // remove excessive fragment nodes
                const end = locateClosingAsyncAnchor(node)
                while (true) {
                  const next = nextSibling(node)
                  if (next && next !== end) {
                    remove(next)
                  } else {
                    break
                  }
                }
              }
              const next = nextSibling(node)
              const container = parentNode(node)
              remove(node)
              patch(
                null,
                vnode,
                container,
                next,
                parentComponent,
                parentSuspense,
                isSVGContainer(container)
              )
              return next
            }
            const locateClosingAsyncAnchor = node => {
              let match = 0
              while (node) {
                node = nextSibling(node)
                if (node && isComment(node)) {
                  if (node.data === '[') match++
                  if (node.data === ']') {
                    if (match === 0) {
                      return nextSibling(node)
                    } else {
                      match--
                    }
                  }
                }
              }
              return node
            }
            return [hydrate, hydrateNode]
          }

          let supported
          let perf
          function startMeasure(instance, type) {
            if (instance.appContext.config.performance && isSupported()) {
              perf.mark(`vue-${type}-${instance.uid}`)
            }
          }
          function endMeasure(instance, type) {
            if (instance.appContext.config.performance && isSupported()) {
              const startTag = `vue-${type}-${instance.uid}`
              const endTag = startTag + `:end`
              perf.mark(endTag)
              perf.measure(
                `<${formatComponentName(instance, instance.type)}> ${type}`,
                startTag,
                endTag
              )
              perf.clearMarks(startTag)
              perf.clearMarks(endTag)
            }
          }
          function isSupported() {
            if (supported !== undefined) {
              return supported
            }
            /* eslint-disable no-restricted-globals */
            if (typeof window !== 'undefined' && window.performance) {
              supported = true
              perf = window.performance
            } else {
              supported = false
            }
            /* eslint-enable no-restricted-globals */
            return supported
          }

          /**
           * This is only called in esm-bundler builds.
           * It is called when a renderer is created, in `baseCreateRenderer` so that
           * importing runtime-core is side-effects free.
           *
           * istanbul-ignore-next
           */
          function initFeatureFlags() {
            let needWarn = false
            if (typeof __VUE_OPTIONS_API__ !== 'boolean') {
              needWarn = true
              Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['getGlobalThis']
              )().__VUE_OPTIONS_API__ = true
            }
            if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {
              needWarn = true
              Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['getGlobalThis']
              )().__VUE_PROD_DEVTOOLS__ = false
            }
            if (true && needWarn) {
              console.warn(
                `You are running the esm-bundler build of Vue. It is recommended to ` +
                  `configure your bundler to explicitly replace feature flag globals ` +
                  `with boolean literals to get proper tree-shaking in the final bundle. ` +
                  `See http://link.vuejs.org/feature-flags for more details.`
              )
            }
          }

          // implementation, close to no-op
          function defineComponent(options) {
            return Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
            )(options)
              ? { setup: options, name: options.name }
              : options
          }

          const isAsyncWrapper = i => !!i.type.__asyncLoader
          function defineAsyncComponent(source) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                source
              )
            ) {
              source = { loader: source }
            }
            const {
              loader,
              loadingComponent,
              errorComponent,
              delay = 200,
              timeout, // undefined = never times out
              suspensible = true,
              onError: userOnError
            } = source
            let pendingRequest = null
            let resolvedComp
            let retries = 0
            const retry = () => {
              retries++
              pendingRequest = null
              return load()
            }
            const load = () => {
              let thisRequest
              return (
                pendingRequest ||
                (thisRequest = pendingRequest = loader()
                  .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err))
                    if (userOnError) {
                      return new Promise((resolve, reject) => {
                        const userRetry = () => resolve(retry())
                        const userFail = () => reject(err)
                        userOnError(err, userRetry, userFail, retries + 1)
                      })
                    } else {
                      throw err
                    }
                  })
                  .then(comp => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                      return pendingRequest
                    }
                    if (true && !comp) {
                      warn(
                        `Async component loader resolved to undefined. ` +
                          `If you are using retry(), make sure to return its return value.`
                      )
                    }
                    // interop module default
                    if (
                      comp &&
                      (comp.__esModule || comp[Symbol.toStringTag] === 'Module')
                    ) {
                      comp = comp.default
                    }
                    if (
                      true &&
                      comp &&
                      !Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject']
                      )(comp) &&
                      !Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                      )(comp)
                    ) {
                      throw new Error(
                        `Invalid async component load result: ${comp}`
                      )
                    }
                    resolvedComp = comp
                    return comp
                  }))
              )
            }
            return defineComponent({
              __asyncLoader: load,
              name: 'AsyncComponentWrapper',
              setup() {
                const instance = currentInstance
                // already resolved
                if (resolvedComp) {
                  return () => createInnerComp(resolvedComp, instance)
                }
                const onError = err => {
                  pendingRequest = null
                  handleError(
                    err,
                    instance,
                    13 /* ASYNC_COMPONENT_LOADER */,
                    !errorComponent /* do not throw in dev if user provided error component */
                  )
                }
                // suspense-controlled or SSR.
                if ((suspensible && instance.suspense) || false) {
                  return load()
                    .then(comp => {
                      return () => createInnerComp(comp, instance)
                    })
                    .catch(err => {
                      onError(err)
                      return () =>
                        errorComponent
                          ? createVNode(errorComponent, {
                              error: err
                            })
                          : null
                    })
                }
                const loaded = Object(
                  _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['ref']
                )(false)
                const error = Object(
                  _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['ref']
                )()
                const delayed = Object(
                  _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['ref']
                )(!!delay)
                if (delay) {
                  setTimeout(() => {
                    delayed.value = false
                  }, delay)
                }
                if (timeout != null) {
                  setTimeout(() => {
                    if (!loaded.value && !error.value) {
                      const err = new Error(
                        `Async component timed out after ${timeout}ms.`
                      )
                      onError(err)
                      error.value = err
                    }
                  }, timeout)
                }
                load()
                  .then(() => {
                    loaded.value = true
                  })
                  .catch(err => {
                    onError(err)
                    error.value = err
                  })
                return () => {
                  if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance)
                  } else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                      error: error.value
                    })
                  } else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent)
                  }
                }
              }
            })
          }
          function createInnerComp(comp, { vnode: { ref, props, children } }) {
            const vnode = createVNode(comp, props, children)
            // ensure inner component inherits the async wrapper's ref owner
            vnode.ref = ref
            return vnode
          }

          const prodEffectOptions = {
            scheduler: queueJob,
            // #1801, #2043 component render effects should allow recursive updates
            allowRecurse: true
          }
          function createDevEffectOptions(instance) {
            return {
              scheduler: queueJob,
              allowRecurse: true,
              onTrack: instance.rtc
                ? e =>
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['invokeArrayFns']
                    )(instance.rtc, e)
                : void 0,
              onTrigger: instance.rtg
                ? e =>
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['invokeArrayFns']
                    )(instance.rtg, e)
                : void 0
            }
          }
          const queuePostRenderEffect = queueEffectWithSuspense
          const setRef = (rawRef, oldRawRef, parentSuspense, vnode) => {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                rawRef
              )
            ) {
              rawRef.forEach((r, i) =>
                setRef(
                  r,
                  oldRawRef &&
                    (Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray']
                    )(oldRawRef)
                      ? oldRawRef[i]
                      : oldRawRef),
                  parentSuspense,
                  vnode
                )
              )
              return
            }
            let value
            if (!vnode || isAsyncWrapper(vnode)) {
              value = null
            } else {
              if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
                value = vnode.component.exposed || vnode.component.proxy
              } else {
                value = vnode.el
              }
            }
            const { i: owner, r: ref } = rawRef
            if (true && !owner) {
              warn(
                `Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
                  `A vnode with ref must be created inside the render function.`
              )
              return
            }
            const oldRef = oldRawRef && oldRawRef.r
            const refs =
              owner.refs ===
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
                ? (owner.refs = {})
                : owner.refs
            const setupState = owner.setupState
            // unset old ref
            if (oldRef != null && oldRef !== ref) {
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                  oldRef
                )
              ) {
                refs[oldRef] = null
                if (
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    setupState,
                    oldRef
                  )
                ) {
                  setupState[oldRef] = null
                }
              } else if (
                Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef'])(
                  oldRef
                )
              ) {
                oldRef.value = null
              }
            }
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(ref)
            ) {
              const doSet = () => {
                refs[ref] = value
                if (
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    setupState,
                    ref
                  )
                ) {
                  setupState[ref] = value
                }
              }
              // #1789: for non-null values, set them after render
              // null values means this is unmount and it should not overwrite another
              // ref with the same key
              if (value) {
                doSet.id = -1
                queuePostRenderEffect(doSet, parentSuspense)
              } else {
                doSet()
              }
            } else if (
              Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef'])(ref)
            ) {
              const doSet = () => {
                ref.value = value
              }
              if (value) {
                doSet.id = -1
                queuePostRenderEffect(doSet, parentSuspense)
              } else {
                doSet()
              }
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                ref
              )
            ) {
              callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [
                value,
                refs
              ])
            } else if (true) {
              warn('Invalid template ref type:', value, `(${typeof value})`)
            }
          }
          /**
           * The createRenderer function accepts two generic arguments:
           * HostNode and HostElement, corresponding to Node and Element types in the
           * host environment. For example, for runtime-dom, HostNode would be the DOM
           * `Node` interface and HostElement would be the DOM `Element` interface.
           *
           * Custom renderers can pass in the platform specific types like this:
           *
           * ``` js
           * const { render, createApp } = createRenderer<Node, Element>({
           *   patchProp,
           *   ...nodeOps
           * })
           * ```
           */
          function createRenderer(options) {
            return baseCreateRenderer(options)
          }
          // Separate API for creating hydration-enabled renderer.
          // Hydration logic is only used when calling this function, making it
          // tree-shakable.
          function createHydrationRenderer(options) {
            return baseCreateRenderer(options, createHydrationFunctions)
          }
          // implementation
          function baseCreateRenderer(options, createHydrationFns) {
            // compile-time feature flags check
            {
              initFeatureFlags()
            }
            const {
              insert: hostInsert,
              remove: hostRemove,
              patchProp: hostPatchProp,
              forcePatchProp: hostForcePatchProp,
              createElement: hostCreateElement,
              createText: hostCreateText,
              createComment: hostCreateComment,
              setText: hostSetText,
              setElementText: hostSetElementText,
              parentNode: hostParentNode,
              nextSibling: hostNextSibling,
              setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                'NOOP'
              ],
              cloneNode: hostCloneNode,
              insertStaticContent: hostInsertStaticContent
            } = options
            // Note: functions inside this closure should use `const xxx = () => {}`
            // style in order to prevent being inlined by minifiers.
            const patch = (
              n1,
              n2,
              container,
              anchor = null,
              parentComponent = null,
              parentSuspense = null,
              isSVG = false,
              optimized = false
            ) => {
              // patching & not same type, unmount old tree
              if (n1 && !isSameVNodeType(n1, n2)) {
                anchor = getNextHostNode(n1)
                unmount(n1, parentComponent, parentSuspense, true)
                n1 = null
              }
              if (n2.patchFlag === -2 /* BAIL */) {
                optimized = false
                n2.dynamicChildren = null
              }
              const { type, ref, shapeFlag } = n2
              switch (type) {
                case Text:
                  processText(n1, n2, container, anchor)
                  break
                case Comment:
                  processCommentNode(n1, n2, container, anchor)
                  break
                case Static:
                  if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG)
                  } else if (true) {
                    patchStaticNode(n1, n2, container, isSVG)
                  }
                  break
                case Fragment:
                  processFragment(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                  break
                default:
                  if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  } else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  } else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized,
                      internals
                    )
                  } else if (shapeFlag & 128 /* SUSPENSE */) {
                    type.process(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized,
                      internals
                    )
                  } else if (true) {
                    warn('Invalid VNode type:', type, `(${typeof type})`)
                  }
              }
              // set ref
              if (ref != null && parentComponent) {
                setRef(ref, n1 && n1.ref, parentSuspense, n2)
              }
            }
            const processText = (n1, n2, container, anchor) => {
              if (n1 == null) {
                hostInsert(
                  (n2.el = hostCreateText(n2.children)),
                  container,
                  anchor
                )
              } else {
                const el = (n2.el = n1.el)
                if (n2.children !== n1.children) {
                  hostSetText(el, n2.children)
                }
              }
            }
            const processCommentNode = (n1, n2, container, anchor) => {
              if (n1 == null) {
                hostInsert(
                  (n2.el = hostCreateComment(n2.children || '')),
                  container,
                  anchor
                )
              } else {
                // there's no support for dynamic comments
                n2.el = n1.el
              }
            }
            const mountStaticNode = (n2, container, anchor, isSVG) => {
              ;[n2.el, n2.anchor] = hostInsertStaticContent(
                n2.children,
                container,
                anchor,
                isSVG
              )
            }
            /**
             * Dev / HMR only
             */
            const patchStaticNode = (n1, n2, container, isSVG) => {
              // static nodes are only patched during dev for HMR
              if (n2.children !== n1.children) {
                const anchor = hostNextSibling(n1.anchor)
                // remove existing
                removeStaticNode(n1)
                ;[n2.el, n2.anchor] = hostInsertStaticContent(
                  n2.children,
                  container,
                  anchor,
                  isSVG
                )
              } else {
                n2.el = n1.el
                n2.anchor = n1.anchor
              }
            }
            const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
              let next
              while (el && el !== anchor) {
                next = hostNextSibling(el)
                hostInsert(el, container, nextSibling)
                el = next
              }
              hostInsert(anchor, container, nextSibling)
            }
            const removeStaticNode = ({ el, anchor }) => {
              let next
              while (el && el !== anchor) {
                next = hostNextSibling(el)
                hostRemove(el)
                el = next
              }
              hostRemove(anchor)
            }
            const processElement = (
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              isSVG = isSVG || n2.type === 'svg'
              if (n1 == null) {
                mountElement(
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              } else {
                patchElement(
                  n1,
                  n2,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              }
            }
            const mountElement = (
              vnode,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              let el
              let vnodeHook
              const {
                type,
                props,
                shapeFlag,
                transition,
                scopeId,
                patchFlag,
                dirs
              } = vnode
              if (false /* HOISTED */) {
              } else {
                el = vnode.el = hostCreateElement(
                  vnode.type,
                  isSVG,
                  props && props.is
                )
                // mount children first, since some props may rely on child content
                // being already rendered, e.g. `<select value>`
                if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                  hostSetElementText(el, vnode.children)
                } else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                  mountChildren(
                    vnode.children,
                    el,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVG && type !== 'foreignObject',
                    optimized || !!vnode.dynamicChildren
                  )
                }
                if (dirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'created')
                }
                // props
                if (props) {
                  for (const key in props) {
                    if (
                      !Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                          'isReservedProp'
                        ]
                      )(key)
                    ) {
                      hostPatchProp(
                        el,
                        key,
                        null,
                        props[key],
                        isSVG,
                        vnode.children,
                        parentComponent,
                        parentSuspense,
                        unmountChildren
                      )
                    }
                  }
                  if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode)
                  }
                }
                // scopeId
                setScopeId(el, scopeId, vnode, parentComponent)
              }
              if (true) {
                Object.defineProperty(el, '__vnode', {
                  value: vnode,
                  enumerable: false
                })
                Object.defineProperty(el, '__vueParentComponent', {
                  value: parentComponent,
                  enumerable: false
                })
              }
              if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount')
              }
              // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
              // #1689 For inside suspense + suspense resolved case, just call it
              const needCallTransitionHooks =
                (!parentSuspense ||
                  (parentSuspense && !parentSuspense.pendingBranch)) &&
                transition &&
                !transition.persisted
              if (needCallTransitionHooks) {
                transition.beforeEnter(el)
              }
              hostInsert(el, container, anchor)
              if (
                (vnodeHook = props && props.onVnodeMounted) ||
                needCallTransitionHooks ||
                dirs
              ) {
                queuePostRenderEffect(() => {
                  vnodeHook &&
                    invokeVNodeHook(vnodeHook, parentComponent, vnode)
                  needCallTransitionHooks && transition.enter(el)
                  dirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'mounted')
                }, parentSuspense)
              }
            }
            const setScopeId = (el, scopeId, vnode, parentComponent) => {
              if (scopeId) {
                hostSetScopeId(el, scopeId)
              }
              if (parentComponent) {
                const treeOwnerId = parentComponent.type.__scopeId
                // vnode's own scopeId and the current patched component's scopeId is
                // different - this is a slot content node.
                if (treeOwnerId && treeOwnerId !== scopeId) {
                  hostSetScopeId(el, treeOwnerId + '-s')
                }
                let subTree = parentComponent.subTree
                if (true && subTree.type === Fragment) {
                  subTree = filterSingleRoot(subTree.children) || subTree
                }
                if (vnode === subTree) {
                  setScopeId(
                    el,
                    parentComponent.vnode.scopeId,
                    parentComponent.vnode,
                    parentComponent.parent
                  )
                }
              }
            }
            const mountChildren = (
              children,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized,
              start = 0
            ) => {
              for (let i = start; i < children.length; i++) {
                const child = (children[i] = optimized
                  ? cloneIfMounted(children[i])
                  : normalizeVNode(children[i]))
                patch(
                  null,
                  child,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              }
            }
            const patchElement = (
              n1,
              n2,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              const el = (n2.el = n1.el)
              let { patchFlag, dynamicChildren, dirs } = n2
              // #1426 take the old vnode's patch flag into account since user may clone a
              // compiler-generated vnode, which de-opts to FULL_PROPS
              patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */
              const oldProps =
                n1.props ||
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
              const newProps =
                n2.props ||
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
              let vnodeHook
              if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
                invokeVNodeHook(vnodeHook, parentComponent, n2, n1)
              }
              if (dirs) {
                invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate')
              }
              if (true && isHmrUpdating) {
                // HMR updated, force full diff
                patchFlag = 0
                optimized = false
                dynamicChildren = null
              }
              if (patchFlag > 0) {
                // the presence of a patchFlag means this element's render code was
                // generated by the compiler and can take the fast path.
                // in this path old node and new node are guaranteed to have the same shape
                // (i.e. at the exact same position in the source template)
                if (patchFlag & 16 /* FULL_PROPS */) {
                  // element props contain dynamic keys, full diff needed
                  patchProps(
                    el,
                    n2,
                    oldProps,
                    newProps,
                    parentComponent,
                    parentSuspense,
                    isSVG
                  )
                } else {
                  // class
                  // this flag is matched when the element has dynamic class bindings.
                  if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                      hostPatchProp(el, 'class', null, newProps.class, isSVG)
                    }
                  }
                  // style
                  // this flag is matched when the element has dynamic style bindings
                  if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(
                      el,
                      'style',
                      oldProps.style,
                      newProps.style,
                      isSVG
                    )
                  }
                  // props
                  // This flag is matched when the element has dynamic prop/attr bindings
                  // other than class and style. The keys of dynamic prop/attrs are saved for
                  // faster iteration.
                  // Note dynamic keys like :[foo]="bar" will cause this optimization to
                  // bail out and go through a full diff because we need to unset the old key
                  if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps
                    for (let i = 0; i < propsToUpdate.length; i++) {
                      const key = propsToUpdate[i]
                      const prev = oldProps[key]
                      const next = newProps[key]
                      if (
                        next !== prev ||
                        (hostForcePatchProp && hostForcePatchProp(el, key))
                      ) {
                        hostPatchProp(
                          el,
                          key,
                          prev,
                          next,
                          isSVG,
                          n1.children,
                          parentComponent,
                          parentSuspense,
                          unmountChildren
                        )
                      }
                    }
                  }
                }
                // text
                // This flag is matched when the element has only dynamic text children.
                if (patchFlag & 1 /* TEXT */) {
                  if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children)
                  }
                }
              } else if (!optimized && dynamicChildren == null) {
                // unoptimized, full diff
                patchProps(
                  el,
                  n2,
                  oldProps,
                  newProps,
                  parentComponent,
                  parentSuspense,
                  isSVG
                )
              }
              const areChildrenSVG = isSVG && n2.type !== 'foreignObject'
              if (dynamicChildren) {
                patchBlockChildren(
                  n1.dynamicChildren,
                  dynamicChildren,
                  el,
                  parentComponent,
                  parentSuspense,
                  areChildrenSVG
                )
                if (true && parentComponent && parentComponent.type.__hmrId) {
                  traverseStaticChildren(n1, n2)
                }
              } else if (!optimized) {
                // full diff
                patchChildren(
                  n1,
                  n2,
                  el,
                  null,
                  parentComponent,
                  parentSuspense,
                  areChildrenSVG
                )
              }
              if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
                queuePostRenderEffect(() => {
                  vnodeHook &&
                    invokeVNodeHook(vnodeHook, parentComponent, n2, n1)
                  dirs &&
                    invokeDirectiveHook(n2, n1, parentComponent, 'updated')
                }, parentSuspense)
              }
            }
            // The fast path for blocks.
            const patchBlockChildren = (
              oldChildren,
              newChildren,
              fallbackContainer,
              parentComponent,
              parentSuspense,
              isSVG
            ) => {
              for (let i = 0; i < newChildren.length; i++) {
                const oldVNode = oldChildren[i]
                const newVNode = newChildren[i]
                // Determine the container (parent element) for the patch.
                const container =
                  // - In the case of a Fragment, we need to provide the actual parent
                  // of the Fragment itself so it can move its children.
                  oldVNode.type === Fragment ||
                  // - In the case of different nodes, there is going to be a replacement
                  // which also requires the correct parent container
                  !isSameVNodeType(oldVNode, newVNode) ||
                  // - In the case of a component, it could contain anything.
                  oldVNode.shapeFlag & 6 /* COMPONENT */ ||
                  oldVNode.shapeFlag & 64 /* TELEPORT */
                    ? hostParentNode(oldVNode.el)
                    : // In other cases, the parent container is not actually used so we
                      // just pass the block element here to avoid a DOM parentNode call.
                      fallbackContainer
                patch(
                  oldVNode,
                  newVNode,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  true
                )
              }
            }
            const patchProps = (
              el,
              vnode,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG
            ) => {
              if (oldProps !== newProps) {
                for (const key in newProps) {
                  // empty string is not valid prop
                  if (
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isReservedProp']
                    )(key)
                  )
                    continue
                  const next = newProps[key]
                  const prev = oldProps[key]
                  if (
                    next !== prev ||
                    (hostForcePatchProp && hostForcePatchProp(el, key))
                  ) {
                    hostPatchProp(
                      el,
                      key,
                      prev,
                      next,
                      isSVG,
                      vnode.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    )
                  }
                }
                if (
                  oldProps !==
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
                ) {
                  for (const key in oldProps) {
                    if (
                      !Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                          'isReservedProp'
                        ]
                      )(key) &&
                      !(key in newProps)
                    ) {
                      hostPatchProp(
                        el,
                        key,
                        oldProps[key],
                        null,
                        isSVG,
                        vnode.children,
                        parentComponent,
                        parentSuspense,
                        unmountChildren
                      )
                    }
                  }
                }
              }
            }
            const processFragment = (
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              const fragmentStartAnchor = (n2.el = n1
                ? n1.el
                : hostCreateText(''))
              const fragmentEndAnchor = (n2.anchor = n1
                ? n1.anchor
                : hostCreateText(''))
              let { patchFlag, dynamicChildren } = n2
              if (patchFlag > 0) {
                optimized = true
              }
              if (true && isHmrUpdating) {
                // HMR updated, force full diff
                patchFlag = 0
                optimized = false
                dynamicChildren = null
              }
              if (n1 == null) {
                hostInsert(fragmentStartAnchor, container, anchor)
                hostInsert(fragmentEndAnchor, container, anchor)
                // a fragment can only have array children
                // since they are either generated by the compiler, or implicitly created
                // from arrays.
                mountChildren(
                  n2.children,
                  container,
                  fragmentEndAnchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              } else {
                if (
                  patchFlag > 0 &&
                  patchFlag & 64 /* STABLE_FRAGMENT */ &&
                  dynamicChildren &&
                  // #2715 the previous fragment could've been a BAILed one as a result
                  // of renderSlot() with no valid children
                  n1.dynamicChildren
                ) {
                  // a stable fragment (template root or <template v-for>) doesn't need to
                  // patch children order, but it may contain dynamicChildren.
                  patchBlockChildren(
                    n1.dynamicChildren,
                    dynamicChildren,
                    container,
                    parentComponent,
                    parentSuspense,
                    isSVG
                  )
                  if (true && parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2)
                  } else if (
                    // #2080 if the stable fragment has a key, it's a <template v-for> that may
                    //  get moved around. Make sure all root level vnodes inherit el.
                    // #2134 or if it's a component root, it may also get moved around
                    // as the component is being moved.
                    n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)
                  ) {
                    traverseStaticChildren(n1, n2, true /* shallow */)
                  }
                } else {
                  // keyed / unkeyed, or manual fragments.
                  // for keyed & unkeyed, since they are compiler generated from v-for,
                  // each child is guaranteed to be a block so the fragment will never
                  // have dynamicChildren.
                  patchChildren(
                    n1,
                    n2,
                    container,
                    fragmentEndAnchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                }
              }
            }
            const processComponent = (
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              if (n1 == null) {
                if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                  parentComponent.ctx.activate(
                    n2,
                    container,
                    anchor,
                    isSVG,
                    optimized
                  )
                } else {
                  mountComponent(
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                }
              } else {
                updateComponent(n1, n2, optimized)
              }
            }
            const mountComponent = (
              initialVNode,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              const instance = (initialVNode.component = createComponentInstance(
                initialVNode,
                parentComponent,
                parentSuspense
              ))
              if (true && instance.type.__hmrId) {
                registerHMR(instance)
              }
              if (true) {
                pushWarningContext(initialVNode)
                startMeasure(instance, `mount`)
              }
              // inject renderer internals for keepAlive
              if (isKeepAlive(initialVNode)) {
                instance.ctx.renderer = internals
              }
              // resolve props and slots for setup context
              if (true) {
                startMeasure(instance, `init`)
              }
              setupComponent(instance)
              if (true) {
                endMeasure(instance, `init`)
              }
              // setup() is async. This component relies on async logic to be resolved
              // before proceeding
              if (instance.asyncDep) {
                parentSuspense &&
                  parentSuspense.registerDep(instance, setupRenderEffect)
                // Give it a placeholder if this is not hydration
                // TODO handle self-defined fallback
                if (!initialVNode.el) {
                  const placeholder = (instance.subTree = createVNode(Comment))
                  processCommentNode(null, placeholder, container, anchor)
                }
                return
              }
              setupRenderEffect(
                instance,
                initialVNode,
                container,
                anchor,
                parentSuspense,
                isSVG,
                optimized
              )
              if (true) {
                popWarningContext()
                endMeasure(instance, `mount`)
              }
            }
            const updateComponent = (n1, n2, optimized) => {
              const instance = (n2.component = n1.component)
              if (shouldUpdateComponent(n1, n2, optimized)) {
                if (instance.asyncDep && !instance.asyncResolved) {
                  // async & still pending - just update props and slots
                  // since the component's reactive effect for render isn't set-up yet
                  if (true) {
                    pushWarningContext(n2)
                  }
                  updateComponentPreRender(instance, n2, optimized)
                  if (true) {
                    popWarningContext()
                  }
                  return
                } else {
                  // normal update
                  instance.next = n2
                  // in case the child component is also queued, remove it to avoid
                  // double updating the same child component in the same flush.
                  invalidateJob(instance.update)
                  // instance.update is the reactive effect runner.
                  instance.update()
                }
              } else {
                // no update needed. just copy over properties
                n2.component = n1.component
                n2.el = n1.el
                instance.vnode = n2
              }
            }
            const setupRenderEffect = (
              instance,
              initialVNode,
              container,
              anchor,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              // create reactive effect for rendering
              instance.update = Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['effect']
              )(function componentEffect() {
                if (!instance.isMounted) {
                  let vnodeHook
                  const { el, props } = initialVNode
                  const { bm, m, parent } = instance
                  // beforeMount hook
                  if (bm) {
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['invokeArrayFns']
                    )(bm)
                  }
                  // onVnodeBeforeMount
                  if ((vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode)
                  }
                  // render
                  if (true) {
                    startMeasure(instance, `render`)
                  }
                  const subTree = (instance.subTree = renderComponentRoot(
                    instance
                  ))
                  if (true) {
                    endMeasure(instance, `render`)
                  }
                  if (el && hydrateNode) {
                    if (true) {
                      startMeasure(instance, `hydrate`)
                    }
                    // vnode has adopted host node - perform hydration instead of mount.
                    hydrateNode(
                      initialVNode.el,
                      subTree,
                      instance,
                      parentSuspense
                    )
                    if (true) {
                      endMeasure(instance, `hydrate`)
                    }
                  } else {
                    if (true) {
                      startMeasure(instance, `patch`)
                    }
                    patch(
                      null,
                      subTree,
                      container,
                      anchor,
                      instance,
                      parentSuspense,
                      isSVG
                    )
                    if (true) {
                      endMeasure(instance, `patch`)
                    }
                    initialVNode.el = subTree.el
                  }
                  // mounted hook
                  if (m) {
                    queuePostRenderEffect(m, parentSuspense)
                  }
                  // onVnodeMounted
                  if ((vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode
                    queuePostRenderEffect(() => {
                      invokeVNodeHook(vnodeHook, parent, scopedInitialVNode)
                    }, parentSuspense)
                  }
                  // activated hook for keep-alive roots.
                  // #1742 activated hook must be accessed after first render
                  // since the hook may be injected by a child keep-alive
                  const { a } = instance
                  if (
                    a &&
                    initialVNode.shapeFlag &
                      256 /* COMPONENT_SHOULD_KEEP_ALIVE */
                  ) {
                    queuePostRenderEffect(a, parentSuspense)
                  }
                  instance.isMounted = true
                  if (true) {
                    devtoolsComponentAdded(instance)
                  }
                  // #2458: deference mount-only object parameters to prevent memleaks
                  initialVNode = container = anchor = null
                } else {
                  // updateComponent
                  // This is triggered by mutation of component's own state (next: null)
                  // OR parent calling processComponent (next: VNode)
                  let { next, bu, u, parent, vnode } = instance
                  let originNext = next
                  let vnodeHook
                  if (true) {
                    pushWarningContext(next || instance.vnode)
                  }
                  if (next) {
                    next.el = vnode.el
                    updateComponentPreRender(instance, next, optimized)
                  } else {
                    next = vnode
                  }
                  // beforeUpdate hook
                  if (bu) {
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['invokeArrayFns']
                    )(bu)
                  }
                  // onVnodeBeforeUpdate
                  if (
                    (vnodeHook = next.props && next.props.onVnodeBeforeUpdate)
                  ) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode)
                  }
                  // render
                  if (true) {
                    startMeasure(instance, `render`)
                  }
                  const nextTree = renderComponentRoot(instance)
                  if (true) {
                    endMeasure(instance, `render`)
                  }
                  const prevTree = instance.subTree
                  instance.subTree = nextTree
                  if (true) {
                    startMeasure(instance, `patch`)
                  }
                  patch(
                    prevTree,
                    nextTree,
                    // parent may have changed if it's in a teleport
                    hostParentNode(prevTree.el),
                    // anchor may have changed if it's in a fragment
                    getNextHostNode(prevTree),
                    instance,
                    parentSuspense,
                    isSVG
                  )
                  if (true) {
                    endMeasure(instance, `patch`)
                  }
                  next.el = nextTree.el
                  if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el)
                  }
                  // updated hook
                  if (u) {
                    queuePostRenderEffect(u, parentSuspense)
                  }
                  // onVnodeUpdated
                  if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => {
                      invokeVNodeHook(vnodeHook, parent, next, vnode)
                    }, parentSuspense)
                  }
                  if (true) {
                    devtoolsComponentUpdated(instance)
                  }
                  if (true) {
                    popWarningContext()
                  }
                }
              }, true ? createDevEffectOptions(instance) : undefined)
            }
            const updateComponentPreRender = (
              instance,
              nextVNode,
              optimized
            ) => {
              nextVNode.component = instance
              const prevProps = instance.vnode.props
              instance.vnode = nextVNode
              instance.next = null
              updateProps(instance, nextVNode.props, prevProps, optimized)
              updateSlots(instance, nextVNode.children)
              // props update may have triggered pre-flush watchers.
              // flush them before the render update.
              flushPreFlushCbs(undefined, instance.update)
            }
            const patchChildren = (
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized = false
            ) => {
              const c1 = n1 && n1.children
              const prevShapeFlag = n1 ? n1.shapeFlag : 0
              const c2 = n2.children
              const { patchFlag, shapeFlag } = n2
              // fast path
              if (patchFlag > 0) {
                if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                  // this could be either fully-keyed or mixed (some keyed some not)
                  // presence of patchFlag means children are guaranteed to be arrays
                  patchKeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                  return
                } else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                  // unkeyed
                  patchUnkeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                  return
                }
              }
              // children has 3 possibilities: text, array or no children.
              if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                // text children fast path
                if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                  unmountChildren(c1, parentComponent, parentSuspense)
                }
                if (c2 !== c1) {
                  hostSetElementText(container, c2)
                }
              } else {
                if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                  // prev children was array
                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(
                      c1,
                      c2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  } else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true)
                  }
                } else {
                  // prev children was text OR null
                  // new children is array OR null
                  if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '')
                  }
                  // mount new if array
                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(
                      c2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  }
                }
              }
            }
            const patchUnkeyedChildren = (
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_ARR']
              c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_ARR']
              const oldLength = c1.length
              const newLength = c2.length
              const commonLength = Math.min(oldLength, newLength)
              let i
              for (i = 0; i < commonLength; i++) {
                const nextChild = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]))
                patch(
                  c1[i],
                  nextChild,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized
                )
              }
              if (oldLength > newLength) {
                // remove old
                unmountChildren(
                  c1,
                  parentComponent,
                  parentSuspense,
                  true,
                  false,
                  commonLength
                )
              } else {
                // mount new
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  isSVG,
                  optimized,
                  commonLength
                )
              }
            }
            // can be all-keyed or mixed
            const patchKeyedChildren = (
              c1,
              c2,
              container,
              parentAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            ) => {
              let i = 0
              const l2 = c2.length
              let e1 = c1.length - 1 // prev ending index
              let e2 = l2 - 1 // next ending index
              // 1. sync from start
              // (a b) c
              // (a b) d e
              while (i <= e1 && i <= e2) {
                const n1 = c1[i]
                const n2 = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]))
                if (isSameVNodeType(n1, n2)) {
                  patch(
                    n1,
                    n2,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                } else {
                  break
                }
                i++
              }
              // 2. sync from end
              // a (b c)
              // d e (b c)
              while (i <= e1 && i <= e2) {
                const n1 = c1[e1]
                const n2 = (c2[e2] = optimized
                  ? cloneIfMounted(c2[e2])
                  : normalizeVNode(c2[e2]))
                if (isSameVNodeType(n1, n2)) {
                  patch(
                    n1,
                    n2,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    optimized
                  )
                } else {
                  break
                }
                e1--
                e2--
              }
              // 3. common sequence + mount
              // (a b)
              // (a b) c
              // i = 2, e1 = 1, e2 = 2
              // (a b)
              // c (a b)
              // i = 0, e1 = -1, e2 = 0
              if (i > e1) {
                if (i <= e2) {
                  const nextPos = e2 + 1
                  const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor
                  while (i <= e2) {
                    patch(
                      null,
                      (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])),
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG
                    )
                    i++
                  }
                }
              }
              // 4. common sequence + unmount
              // (a b) c
              // (a b)
              // i = 2, e1 = 2, e2 = 1
              // a (b c)
              // (b c)
              // i = 0, e1 = 0, e2 = -1
              else if (i > e2) {
                while (i <= e1) {
                  unmount(c1[i], parentComponent, parentSuspense, true)
                  i++
                }
              }
              // 5. unknown sequence
              // [i ... e1 + 1]: a b [c d e] f g
              // [i ... e2 + 1]: a b [e d c h] f g
              // i = 2, e1 = 4, e2 = 5
              else {
                const s1 = i // prev starting index
                const s2 = i // next starting index
                // 5.1 build key:index map for newChildren
                const keyToNewIndexMap = new Map()
                for (i = s2; i <= e2; i++) {
                  const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]))
                  if (nextChild.key != null) {
                    if (true && keyToNewIndexMap.has(nextChild.key)) {
                      warn(
                        `Duplicate keys found during update:`,
                        JSON.stringify(nextChild.key),
                        `Make sure keys are unique.`
                      )
                    }
                    keyToNewIndexMap.set(nextChild.key, i)
                  }
                }
                // 5.2 loop through old children left to be patched and try to patch
                // matching nodes & remove nodes that are no longer present
                let j
                let patched = 0
                const toBePatched = e2 - s2 + 1
                let moved = false
                // used to track whether any node has moved
                let maxNewIndexSoFar = 0
                // works as Map<newIndex, oldIndex>
                // Note that oldIndex is offset by +1
                // and oldIndex = 0 is a special value indicating the new node has
                // no corresponding old node.
                // used for determining longest stable subsequence
                const newIndexToOldIndexMap = new Array(toBePatched)
                for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0
                for (i = s1; i <= e1; i++) {
                  const prevChild = c1[i]
                  if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true)
                    continue
                  }
                  let newIndex
                  if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key)
                  } else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                      if (
                        newIndexToOldIndexMap[j - s2] === 0 &&
                        isSameVNodeType(prevChild, c2[j])
                      ) {
                        newIndex = j
                        break
                      }
                    }
                  }
                  if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true)
                  } else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1
                    if (newIndex >= maxNewIndexSoFar) {
                      maxNewIndexSoFar = newIndex
                    } else {
                      moved = true
                    }
                    patch(
                      prevChild,
                      c2[newIndex],
                      container,
                      null,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                    patched++
                  }
                }
                // 5.3 move and mount
                // generate longest stable subsequence only when nodes have moved
                const increasingNewIndexSequence = moved
                  ? getSequence(newIndexToOldIndexMap)
                  : _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_ARR']
                j = increasingNewIndexSequence.length - 1
                // looping backwards so that we can use last patched node as anchor
                for (i = toBePatched - 1; i >= 0; i--) {
                  const nextIndex = s2 + i
                  const nextChild = c2[nextIndex]
                  const anchor =
                    nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor
                  if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(
                      null,
                      nextChild,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG
                    )
                  } else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                      move(nextChild, container, anchor, 2 /* REORDER */)
                    } else {
                      j--
                    }
                  }
                }
              }
            }
            const move = (
              vnode,
              container,
              anchor,
              moveType,
              parentSuspense = null
            ) => {
              const { el, type, transition, children, shapeFlag } = vnode
              if (shapeFlag & 6 /* COMPONENT */) {
                move(vnode.component.subTree, container, anchor, moveType)
                return
              }
              if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.move(container, anchor, moveType)
                return
              }
              if (shapeFlag & 64 /* TELEPORT */) {
                type.move(vnode, container, anchor, internals)
                return
              }
              if (type === Fragment) {
                hostInsert(el, container, anchor)
                for (let i = 0; i < children.length; i++) {
                  move(children[i], container, anchor, moveType)
                }
                hostInsert(vnode.anchor, container, anchor)
                return
              }
              if (type === Static) {
                moveStaticNode(vnode, container, anchor)
                return
              }
              // single nodes
              const needTransition =
                moveType !== 2 /* REORDER */ &&
                shapeFlag & 1 /* ELEMENT */ &&
                transition
              if (needTransition) {
                if (moveType === 0 /* ENTER */) {
                  transition.beforeEnter(el)
                  hostInsert(el, container, anchor)
                  queuePostRenderEffect(
                    () => transition.enter(el),
                    parentSuspense
                  )
                } else {
                  const { leave, delayLeave, afterLeave } = transition
                  const remove = () => hostInsert(el, container, anchor)
                  const performLeave = () => {
                    leave(el, () => {
                      remove()
                      afterLeave && afterLeave()
                    })
                  }
                  if (delayLeave) {
                    delayLeave(el, remove, performLeave)
                  } else {
                    performLeave()
                  }
                }
              } else {
                hostInsert(el, container, anchor)
              }
            }
            const unmount = (
              vnode,
              parentComponent,
              parentSuspense,
              doRemove = false,
              optimized = false
            ) => {
              const {
                type,
                props,
                ref,
                children,
                dynamicChildren,
                shapeFlag,
                patchFlag,
                dirs
              } = vnode
              // unset ref
              if (ref != null) {
                setRef(ref, null, parentSuspense, null)
              }
              if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                parentComponent.ctx.deactivate(vnode)
                return
              }
              const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs
              let vnodeHook
              if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {
                invokeVNodeHook(vnodeHook, parentComponent, vnode)
              }
              if (shapeFlag & 6 /* COMPONENT */) {
                unmountComponent(vnode.component, parentSuspense, doRemove)
              } else {
                if (shapeFlag & 128 /* SUSPENSE */) {
                  vnode.suspense.unmount(parentSuspense, doRemove)
                  return
                }
                if (shouldInvokeDirs) {
                  invokeDirectiveHook(
                    vnode,
                    null,
                    parentComponent,
                    'beforeUnmount'
                  )
                }
                if (
                  dynamicChildren &&
                  // #1153: fast path should not be taken for non-stable (v-for) fragments
                  (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64) /* STABLE_FRAGMENT */)
                ) {
                  // fast path for block nodes: only need to unmount dynamic children.
                  unmountChildren(
                    dynamicChildren,
                    parentComponent,
                    parentSuspense,
                    false,
                    true
                  )
                } else if (
                  (type === Fragment &&
                    (patchFlag & 128 /* KEYED_FRAGMENT */ ||
                      patchFlag & 256) /* UNKEYED_FRAGMENT */) ||
                  (!optimized && shapeFlag & 16) /* ARRAY_CHILDREN */
                ) {
                  unmountChildren(children, parentComponent, parentSuspense)
                }
                // an unmounted teleport should always remove its children if not disabled
                if (
                  shapeFlag & 64 /* TELEPORT */ &&
                  (doRemove || !isTeleportDisabled(vnode.props))
                ) {
                  vnode.type.remove(vnode, internals)
                }
                if (doRemove) {
                  remove(vnode)
                }
              }
              if (
                (vnodeHook = props && props.onVnodeUnmounted) ||
                shouldInvokeDirs
              ) {
                queuePostRenderEffect(() => {
                  vnodeHook &&
                    invokeVNodeHook(vnodeHook, parentComponent, vnode)
                  shouldInvokeDirs &&
                    invokeDirectiveHook(
                      vnode,
                      null,
                      parentComponent,
                      'unmounted'
                    )
                }, parentSuspense)
              }
            }
            const remove = vnode => {
              const { type, el, anchor, transition } = vnode
              if (type === Fragment) {
                removeFragment(el, anchor)
                return
              }
              if (type === Static) {
                removeStaticNode(vnode)
                return
              }
              const performRemove = () => {
                hostRemove(el)
                if (
                  transition &&
                  !transition.persisted &&
                  transition.afterLeave
                ) {
                  transition.afterLeave()
                }
              }
              if (
                vnode.shapeFlag & 1 /* ELEMENT */ &&
                transition &&
                !transition.persisted
              ) {
                const { leave, delayLeave } = transition
                const performLeave = () => leave(el, performRemove)
                if (delayLeave) {
                  delayLeave(vnode.el, performRemove, performLeave)
                } else {
                  performLeave()
                }
              } else {
                performRemove()
              }
            }
            const removeFragment = (cur, end) => {
              // For fragments, directly remove all contained DOM nodes.
              // (fragment child nodes cannot have transition)
              let next
              while (cur !== end) {
                next = hostNextSibling(cur)
                hostRemove(cur)
                cur = next
              }
              hostRemove(end)
            }
            const unmountComponent = (instance, parentSuspense, doRemove) => {
              if (true && instance.type.__hmrId) {
                unregisterHMR(instance)
              }
              const { bum, effects, update, subTree, um } = instance
              // beforeUnmount hook
              if (bum) {
                Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['invokeArrayFns']
                )(bum)
              }
              if (effects) {
                for (let i = 0; i < effects.length; i++) {
                  Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['stop'])(
                    effects[i]
                  )
                }
              }
              // update may be null if a component is unmounted before its async
              // setup has resolved.
              if (update) {
                Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['stop'])(
                  update
                )
                unmount(subTree, instance, parentSuspense, doRemove)
              }
              // unmounted hook
              if (um) {
                queuePostRenderEffect(um, parentSuspense)
              }
              queuePostRenderEffect(() => {
                instance.isUnmounted = true
              }, parentSuspense)
              // A component with async dep inside a pending suspense is unmounted before
              // its async dep resolves. This should remove the dep from the suspense, and
              // cause the suspense to resolve immediately if that was the last dep.
              if (
                parentSuspense &&
                parentSuspense.pendingBranch &&
                !parentSuspense.isUnmounted &&
                instance.asyncDep &&
                !instance.asyncResolved &&
                instance.suspenseId === parentSuspense.pendingId
              ) {
                parentSuspense.deps--
                if (parentSuspense.deps === 0) {
                  parentSuspense.resolve()
                }
              }
              if (true) {
                devtoolsComponentRemoved(instance)
              }
            }
            const unmountChildren = (
              children,
              parentComponent,
              parentSuspense,
              doRemove = false,
              optimized = false,
              start = 0
            ) => {
              for (let i = start; i < children.length; i++) {
                unmount(
                  children[i],
                  parentComponent,
                  parentSuspense,
                  doRemove,
                  optimized
                )
              }
            }
            const getNextHostNode = vnode => {
              if (vnode.shapeFlag & 6 /* COMPONENT */) {
                return getNextHostNode(vnode.component.subTree)
              }
              if (vnode.shapeFlag & 128 /* SUSPENSE */) {
                return vnode.suspense.next()
              }
              return hostNextSibling(vnode.anchor || vnode.el)
            }
            const render = (vnode, container) => {
              if (vnode == null) {
                if (container._vnode) {
                  unmount(container._vnode, null, null, true)
                }
              } else {
                patch(container._vnode || null, vnode, container)
              }
              flushPostFlushCbs()
              container._vnode = vnode
            }
            const internals = {
              p: patch,
              um: unmount,
              m: move,
              r: remove,
              mt: mountComponent,
              mc: mountChildren,
              pc: patchChildren,
              pbc: patchBlockChildren,
              n: getNextHostNode,
              o: options
            }
            let hydrate
            let hydrateNode
            if (createHydrationFns) {
              ;[hydrate, hydrateNode] = createHydrationFns(internals)
            }
            return {
              render,
              hydrate,
              createApp: createAppAPI(render, hydrate)
            }
          }
          function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
            callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
              vnode,
              prevVNode
            ])
          }
          /**
           * #1156
           * When a component is HMR-enabled, we need to make sure that all static nodes
           * inside a block also inherit the DOM element from the previous tree so that
           * HMR updates (which are full updates) can retrieve the element for patching.
           *
           * #2080
           * Inside keyed `template` fragment static children, if a fragment is moved,
           * the children will always moved so that need inherit el form previous nodes
           * to ensure correct moved position.
           */
          function traverseStaticChildren(n1, n2, shallow = false) {
            const ch1 = n1.children
            const ch2 = n2.children
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                ch1
              ) &&
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(ch2)
            ) {
              for (let i = 0; i < ch1.length; i++) {
                // this is only called in the optimized path so array children are
                // guaranteed to be vnodes
                const c1 = ch1[i]
                let c2 = ch2[i]
                if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                  if (
                    c2.patchFlag <= 0 ||
                    c2.patchFlag === 32 /* HYDRATE_EVENTS */
                  ) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i])
                    c2.el = c1.el
                  }
                  if (!shallow) traverseStaticChildren(c1, c2)
                }
                // also inherit for comment nodes, but not placeholders (e.g. v-if which
                // would have received .el during block patch)
                if (true && c2.type === Comment && !c2.el) {
                  c2.el = c1.el
                }
              }
            }
          }
          // https://en.wikipedia.org/wiki/Longest_increasing_subsequence
          function getSequence(arr) {
            const p = arr.slice()
            const result = [0]
            let i, j, u, v, c
            const len = arr.length
            for (i = 0; i < len; i++) {
              const arrI = arr[i]
              if (arrI !== 0) {
                j = result[result.length - 1]
                if (arr[j] < arrI) {
                  p[i] = j
                  result.push(i)
                  continue
                }
                u = 0
                v = result.length - 1
                while (u < v) {
                  c = ((u + v) / 2) | 0
                  if (arr[result[c]] < arrI) {
                    u = c + 1
                  } else {
                    v = c
                  }
                }
                if (arrI < arr[result[u]]) {
                  if (u > 0) {
                    p[i] = result[u - 1]
                  }
                  result[u] = i
                }
              }
            }
            u = result.length
            v = result[u - 1]
            while (u-- > 0) {
              result[u] = v
              v = p[v]
            }
            return result
          }

          const isTeleport = type => type.__isTeleport
          const isTeleportDisabled = props =>
            props && (props.disabled || props.disabled === '')
          const isTargetSVG = target =>
            typeof SVGElement !== 'undefined' && target instanceof SVGElement
          const resolveTarget = (props, select) => {
            const targetSelector = props && props.to
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                targetSelector
              )
            ) {
              if (!select) {
                true &&
                  warn(
                    `Current renderer does not support string target for Teleports. ` +
                      `(missing querySelector renderer option)`
                  )
                return null
              } else {
                const target = select(targetSelector)
                if (!target) {
                  true &&
                    warn(
                      `Failed to locate Teleport target with selector "${targetSelector}". ` +
                        `Note the target element must exist before the component is mounted - ` +
                        `i.e. the target cannot be rendered by the component itself, and ` +
                        `ideally should be outside of the entire Vue component tree.`
                    )
                }
                return target
              }
            } else {
              if (true && !targetSelector && !isTeleportDisabled(props)) {
                warn(`Invalid Teleport target: ${targetSelector}`)
              }
              return targetSelector
            }
          }
          const TeleportImpl = {
            __isTeleport: true,
            process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized,
              internals
            ) {
              const {
                mc: mountChildren,
                pc: patchChildren,
                pbc: patchBlockChildren,
                o: { insert, querySelector, createText, createComment }
              } = internals
              const disabled = isTeleportDisabled(n2.props)
              const { shapeFlag, children } = n2
              if (n1 == null) {
                // insert anchors in the main view
                const placeholder = (n2.el = true
                  ? createComment('teleport start')
                  : undefined)
                const mainAnchor = (n2.anchor = true
                  ? createComment('teleport end')
                  : undefined)
                insert(placeholder, container, anchor)
                insert(mainAnchor, container, anchor)
                const target = (n2.target = resolveTarget(
                  n2.props,
                  querySelector
                ))
                const targetAnchor = (n2.targetAnchor = createText(''))
                if (target) {
                  insert(targetAnchor, target)
                  // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                  isSVG = isSVG || isTargetSVG(target)
                } else if (true && !disabled) {
                  warn(
                    'Invalid Teleport target on mount:',
                    target,
                    `(${typeof target})`
                  )
                }
                const mount = (container, anchor) => {
                  // Teleport *always* has Array children. This is enforced in both the
                  // compiler and vnode children normalization.
                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(
                      children,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      isSVG,
                      optimized
                    )
                  }
                }
                if (disabled) {
                  mount(container, mainAnchor)
                } else if (target) {
                  mount(target, targetAnchor)
                }
              } else {
                // update content
                n2.el = n1.el
                const mainAnchor = (n2.anchor = n1.anchor)
                const target = (n2.target = n1.target)
                const targetAnchor = (n2.targetAnchor = n1.targetAnchor)
                const wasDisabled = isTeleportDisabled(n1.props)
                const currentContainer = wasDisabled ? container : target
                const currentAnchor = wasDisabled ? mainAnchor : targetAnchor
                isSVG = isSVG || isTargetSVG(target)
                if (n2.dynamicChildren) {
                  // fast path when the teleport happens to be a block root
                  patchBlockChildren(
                    n1.dynamicChildren,
                    n2.dynamicChildren,
                    currentContainer,
                    parentComponent,
                    parentSuspense,
                    isSVG
                  )
                  // even in block tree mode we need to make sure all root-level nodes
                  // in the teleport inherit previous DOM references so that they can
                  // be moved in future patches.
                  traverseStaticChildren(n1, n2, true)
                } else if (!optimized) {
                  patchChildren(
                    n1,
                    n2,
                    currentContainer,
                    currentAnchor,
                    parentComponent,
                    parentSuspense,
                    isSVG
                  )
                }
                if (disabled) {
                  if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(
                      n2,
                      container,
                      mainAnchor,
                      internals,
                      1 /* TOGGLE */
                    )
                  }
                } else {
                  // target changed
                  if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(
                      n2.props,
                      querySelector
                    ))
                    if (nextTarget) {
                      moveTeleport(
                        n2,
                        nextTarget,
                        null,
                        internals,
                        0 /* TARGET_CHANGE */
                      )
                    } else if (true) {
                      warn(
                        'Invalid Teleport target on update:',
                        target,
                        `(${typeof target})`
                      )
                    }
                  } else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(
                      n2,
                      target,
                      targetAnchor,
                      internals,
                      1 /* TOGGLE */
                    )
                  }
                }
              }
            },
            remove(
              vnode,
              {
                r: remove,
                o: { remove: hostRemove }
              }
            ) {
              const { shapeFlag, children, anchor } = vnode
              hostRemove(anchor)
              if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                  remove(children[i])
                }
              }
            },
            move: moveTeleport,
            hydrate: hydrateTeleport
          }
          function moveTeleport(
            vnode,
            container,
            parentAnchor,
            { o: { insert }, m: move },
            moveType = 2 /* REORDER */
          ) {
            // move target anchor if this is a target change.
            if (moveType === 0 /* TARGET_CHANGE */) {
              insert(vnode.targetAnchor, container, parentAnchor)
            }
            const { el, anchor, shapeFlag, children, props } = vnode
            const isReorder = moveType === 2 /* REORDER */
            // move main view anchor if this is a re-order.
            if (isReorder) {
              insert(el, container, parentAnchor)
            }
            // if this is a re-order and teleport is enabled (content is in target)
            // do not move children. So the opposite is: only move children if this
            // is not a reorder, or the teleport is disabled
            if (!isReorder || isTeleportDisabled(props)) {
              // Teleport has either Array children or no children.
              if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                  move(children[i], container, parentAnchor, 2 /* REORDER */)
                }
              }
            }
            // move main view anchor if this is a re-order.
            if (isReorder) {
              insert(anchor, container, parentAnchor)
            }
          }
          function hydrateTeleport(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            optimized,
            { o: { nextSibling, parentNode, querySelector } },
            hydrateChildren
          ) {
            const target = (vnode.target = resolveTarget(
              vnode.props,
              querySelector
            ))
            if (target) {
              // if multiple teleports rendered to the same target element, we need to
              // pick up from where the last teleport finished instead of the first node
              const targetNode = target._lpa || target.firstChild
              if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
                if (isTeleportDisabled(vnode.props)) {
                  vnode.anchor = hydrateChildren(
                    nextSibling(node),
                    vnode,
                    parentNode(node),
                    parentComponent,
                    parentSuspense,
                    optimized
                  )
                  vnode.targetAnchor = targetNode
                } else {
                  vnode.anchor = nextSibling(node)
                  vnode.targetAnchor = hydrateChildren(
                    targetNode,
                    vnode,
                    target,
                    parentComponent,
                    parentSuspense,
                    optimized
                  )
                }
                target._lpa =
                  vnode.targetAnchor && nextSibling(vnode.targetAnchor)
              }
            }
            return vnode.anchor && nextSibling(vnode.anchor)
          }
          // Force-casted public typing for h and TSX props inference
          const Teleport = TeleportImpl

          const COMPONENTS = 'components'
          const DIRECTIVES = 'directives'
          /**
           * @private
           */
          function resolveComponent(name) {
            return resolveAsset(COMPONENTS, name) || name
          }
          const NULL_DYNAMIC_COMPONENT = Symbol()
          /**
           * @private
           */
          function resolveDynamicComponent(component) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                component
              )
            ) {
              return resolveAsset(COMPONENTS, component, false) || component
            } else {
              // invalid types will fallthrough to createVNode and raise warning
              return component || NULL_DYNAMIC_COMPONENT
            }
          }
          /**
           * @private
           */
          function resolveDirective(name) {
            return resolveAsset(DIRECTIVES, name)
          }
          // implementation
          function resolveAsset(type, name, warnMissing = true) {
            const instance = currentRenderingInstance || currentInstance
            if (instance) {
              const Component = instance.type
              // self name has highest priority
              if (type === COMPONENTS) {
                // special self referencing call generated by compiler
                // inferred from SFC filename
                if (name === `_self`) {
                  return Component
                }
                const selfName = getComponentName(Component)
                if (
                  selfName &&
                  (selfName === name ||
                    selfName ===
                      Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize']
                      )(name) ||
                    selfName ===
                      Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['capitalize']
                      )(
                        Object(
                          _vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize']
                        )(name)
                      ))
                ) {
                  return Component
                }
              }
              const res =
                // local registration
                // check instance[type] first for components with mixin or extends.
                resolve(instance[type] || Component[type], name) ||
                // global registration
                resolve(instance.appContext[type], name)
              if (true && warnMissing && !res) {
                warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`)
              }
              return res
            } else if (true) {
              warn(
                `resolve${Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['capitalize']
                )(type.slice(0, -1))} ` +
                  `can only be used in render() or setup().`
              )
            }
          }
          function resolve(registry, name) {
            return (
              registry &&
              (registry[name] ||
                registry[
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize'])(
                    name
                  )
                ] ||
                registry[
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['capitalize']
                  )(
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['camelize']
                    )(name)
                  )
                ])
            )
          }

          const Fragment = Symbol(true ? 'Fragment' : undefined)
          const Text = Symbol(true ? 'Text' : undefined)
          const Comment = Symbol(true ? 'Comment' : undefined)
          const Static = Symbol(true ? 'Static' : undefined)
          // Since v-if and v-for are the two possible ways node structure can dynamically
          // change, once we consider v-if branches and each v-for fragment a block, we
          // can divide a template into nested blocks, and within each block the node
          // structure would be stable. This allows us to skip most children diffing
          // and only worry about the dynamic nodes (indicated by patch flags).
          const blockStack = []
          let currentBlock = null
          /**
           * Open a block.
           * This must be called before `createBlock`. It cannot be part of `createBlock`
           * because the children of the block are evaluated before `createBlock` itself
           * is called. The generated code typically looks like this:
           *
           * ```js
           * function render() {
           *   return (openBlock(),createBlock('div', null, [...]))
           * }
           * ```
           * disableTracking is true when creating a v-for fragment block, since a v-for
           * fragment always diffs its children.
           *
           * @private
           */
          function openBlock(disableTracking = false) {
            blockStack.push((currentBlock = disableTracking ? null : []))
          }
          function closeBlock() {
            blockStack.pop()
            currentBlock = blockStack[blockStack.length - 1] || null
          }
          // Whether we should be tracking dynamic child nodes inside a block.
          // Only tracks when this value is > 0
          // We are not using a simple boolean because this value may need to be
          // incremented/decremented by nested usage of v-once (see below)
          let shouldTrack = 1
          /**
           * Block tracking sometimes needs to be disabled, for example during the
           * creation of a tree that needs to be cached by v-once. The compiler generates
           * code like this:
           *
           * ``` js
           * _cache[1] || (
           *   setBlockTracking(-1),
           *   _cache[1] = createVNode(...),
           *   setBlockTracking(1),
           *   _cache[1]
           * )
           * ```
           *
           * @private
           */
          function setBlockTracking(value) {
            shouldTrack += value
          }
          /**
           * Create a block root vnode. Takes the same exact arguments as `createVNode`.
           * A block root keeps track of dynamic nodes within the block in the
           * `dynamicChildren` array.
           *
           * @private
           */
          function createBlock(type, props, children, patchFlag, dynamicProps) {
            const vnode = createVNode(
              type,
              props,
              children,
              patchFlag,
              dynamicProps,
              true /* isBlock: prevent a block from tracking itself */
            )
            // save current block children on the block vnode
            vnode.dynamicChildren =
              currentBlock ||
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_ARR']
            // close block
            closeBlock()
            // a block is always going to be patched, so track it as a child of its
            // parent block
            if (shouldTrack > 0 && currentBlock) {
              currentBlock.push(vnode)
            }
            return vnode
          }
          function isVNode(value) {
            return value ? value.__v_isVNode === true : false
          }
          function isSameVNodeType(n1, n2) {
            if (
              true &&
              n2.shapeFlag & 6 /* COMPONENT */ &&
              hmrDirtyComponents.has(n2.type)
            ) {
              // HMR only: if the component has been hot-updated, force a reload.
              return false
            }
            return n1.type === n2.type && n1.key === n2.key
          }
          let vnodeArgsTransformer
          /**
           * Internal API for registering an arguments transform for createVNode
           * used for creating stubs in the test-utils
           * It is *internal* but needs to be exposed for test-utils to pick up proper
           * typings
           */
          function transformVNodeArgs(transformer) {
            vnodeArgsTransformer = transformer
          }
          const createVNodeWithArgsTransform = (...args) => {
            return _createVNode(
              ...(vnodeArgsTransformer
                ? vnodeArgsTransformer(args, currentRenderingInstance)
                : args)
            )
          }
          const InternalObjectKey = `__vInternal`
          const normalizeKey = ({ key }) => (key != null ? key : null)
          const normalizeRef = ({ ref }) => {
            return ref != null
              ? Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                  ref
                ) ||
                Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef'])(
                  ref
                ) ||
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                  ref
                )
                ? { i: currentRenderingInstance, r: ref }
                : ref
              : null
          }
          const createVNode = true ? createVNodeWithArgsTransform : undefined
          function _createVNode(
            type,
            props = null,
            children = null,
            patchFlag = 0,
            dynamicProps = null,
            isBlockNode = false
          ) {
            if (!type || type === NULL_DYNAMIC_COMPONENT) {
              if (true && !type) {
                warn(`Invalid vnode type when creating vnode: ${type}.`)
              }
              type = Comment
            }
            if (isVNode(type)) {
              // createVNode receiving an existing vnode. This happens in cases like
              // <component :is="vnode"/>
              // #2078 make sure to merge refs during the clone instead of overwriting it
              const cloned = cloneVNode(type, props, true /* mergeRef: true */)
              if (children) {
                normalizeChildren(cloned, children)
              }
              return cloned
            }
            // class component normalization.
            if (isClassComponent(type)) {
              type = type.__vccOpts
            }
            // class & style normalization.
            if (props) {
              // for reactive or proxy objects, we need to clone it to enable mutation.
              if (
                Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isProxy'])(
                  props
                ) ||
                InternalObjectKey in props
              ) {
                props = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
                )({}, props)
              }
              let { class: klass, style } = props
              if (
                klass &&
                !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                  klass
                )
              ) {
                props.class = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['normalizeClass']
                )(klass)
              }
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                  style
                )
              ) {
                // reactive state objects need to be cloned since they are likely to be
                // mutated
                if (
                  Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isProxy']
                  )(style) &&
                  !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                    style
                  )
                ) {
                  style = Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
                  )({}, style)
                }
                props.style = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['normalizeStyle']
                )(style)
              }
            }
            // encode the vnode type information into a bitmap
            const shapeFlag = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString']
            )(type)
              ? 1 /* ELEMENT */
              : isSuspense(type)
                ? 128 /* SUSPENSE */
                : isTeleport(type)
                  ? 64 /* TELEPORT */
                  : Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject']
                    )(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                      )(type)
                      ? 2 /* FUNCTIONAL_COMPONENT */
                      : 0
            if (
              true &&
              shapeFlag & 4 /* STATEFUL_COMPONENT */ &&
              Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isProxy'])(
                type
              )
            ) {
              type = Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
              )(type)
              warn(
                `Vue received a Component which was made a reactive object. This can ` +
                  `lead to unnecessary performance overhead, and should be avoided by ` +
                  `marking the component with \`markRaw\` or using \`shallowRef\` ` +
                  `instead of \`ref\`.`,
                `\nComponent that was made reactive: `,
                type
              )
            }
            const vnode = {
              __v_isVNode: true,
              ['__v_skip' /* SKIP */]: true,
              type,
              props,
              key: props && normalizeKey(props),
              ref: props && normalizeRef(props),
              scopeId: currentScopeId,
              children: null,
              component: null,
              suspense: null,
              ssContent: null,
              ssFallback: null,
              dirs: null,
              transition: null,
              el: null,
              anchor: null,
              target: null,
              targetAnchor: null,
              staticCount: 0,
              shapeFlag,
              patchFlag,
              dynamicProps,
              dynamicChildren: null,
              appContext: null
            }
            // validate key
            if (true && vnode.key !== vnode.key) {
              warn(
                `VNode created with invalid key (NaN). VNode type:`,
                vnode.type
              )
            }
            normalizeChildren(vnode, children)
            // normalize suspense children
            if (shapeFlag & 128 /* SUSPENSE */) {
              const { content, fallback } = normalizeSuspenseChildren(vnode)
              vnode.ssContent = content
              vnode.ssFallback = fallback
            }
            if (
              shouldTrack > 0 &&
              // avoid a block node from tracking itself
              !isBlockNode &&
              // has current parent block
              currentBlock &&
              // presence of a patch flag indicates this node needs patching on updates.
              // component nodes also should always be patched, because even if the
              // component doesn't need to update, it needs to persist the instance on to
              // the next vnode so that it can be properly unmounted later.
              (patchFlag > 0 || shapeFlag & 6) /* COMPONENT */ &&
              // the EVENTS flag is only for hydration and if it is the only flag, the
              // vnode should not be considered dynamic due to handler caching.
              patchFlag !== 32 /* HYDRATE_EVENTS */
            ) {
              currentBlock.push(vnode)
            }
            return vnode
          }
          function cloneVNode(vnode, extraProps, mergeRef = false) {
            // This is intentionally NOT using spread or extend to avoid the runtime
            // key enumeration cost.
            const { props, ref, patchFlag, children } = vnode
            const mergedProps = extraProps
              ? mergeProps(props || {}, extraProps)
              : props
            return {
              __v_isVNode: true,
              ['__v_skip' /* SKIP */]: true,
              type: vnode.type,
              props: mergedProps,
              key: mergedProps && normalizeKey(mergedProps),
              ref:
                extraProps && extraProps.ref
                  ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                    // if the vnode itself already has a ref, cloneVNode will need to merge
                    // the refs so the single vnode can be set on multiple refs
                    mergeRef && ref
                    ? Object(
                        _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray']
                      )(ref)
                      ? ref.concat(normalizeRef(extraProps))
                      : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
                  : ref,
              scopeId: vnode.scopeId,
              children:
                true &&
                patchFlag === -1 /* HOISTED */ &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                  children
                )
                  ? children.map(deepCloneVNode)
                  : children,
              target: vnode.target,
              targetAnchor: vnode.targetAnchor,
              staticCount: vnode.staticCount,
              shapeFlag: vnode.shapeFlag,
              // if the vnode is cloned with extra props, we can no longer assume its
              // existing patch flag to be reliable and need to add the FULL_PROPS flag.
              // note: perserve flag for fragments since they use the flag for children
              // fast paths only.
              patchFlag:
                extraProps && vnode.type !== Fragment
                  ? patchFlag === -1 // hoisted node
                    ? 16 /* FULL_PROPS */
                    : patchFlag | 16 /* FULL_PROPS */
                  : patchFlag,
              dynamicProps: vnode.dynamicProps,
              dynamicChildren: vnode.dynamicChildren,
              appContext: vnode.appContext,
              dirs: vnode.dirs,
              transition: vnode.transition,
              // These should technically only be non-null on mounted VNodes. However,
              // they *should* be copied for kept-alive vnodes. So we just always copy
              // them since them being non-null during a mount doesn't affect the logic as
              // they will simply be overwritten.
              component: vnode.component,
              suspense: vnode.suspense,
              ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
              ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
              el: vnode.el,
              anchor: vnode.anchor
            }
          }
          /**
           * Dev only, for HMR of hoisted vnodes reused in v-for
           * https://github.com/vitejs/vite/issues/2022
           */
          function deepCloneVNode(vnode) {
            const cloned = cloneVNode(vnode)
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                vnode.children
              )
            ) {
              cloned.children = vnode.children.map(deepCloneVNode)
            }
            return cloned
          }
          /**
           * @private
           */
          function createTextVNode(text = ' ', flag = 0) {
            return createVNode(Text, null, text, flag)
          }
          /**
           * @private
           */
          function createStaticVNode(content, numberOfNodes) {
            // A static vnode can contain multiple stringified elements, and the number
            // of elements is necessary for hydration.
            const vnode = createVNode(Static, null, content)
            vnode.staticCount = numberOfNodes
            return vnode
          }
          /**
           * @private
           */
          function createCommentVNode(
            text = '',
            // when used as the v-else branch, the comment node must be created as a
            // block to ensure correct updates.
            asBlock = false
          ) {
            return asBlock
              ? (openBlock(), createBlock(Comment, null, text))
              : createVNode(Comment, null, text)
          }
          function normalizeVNode(child) {
            if (child == null || typeof child === 'boolean') {
              // empty placeholder
              return createVNode(Comment)
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(child)
            ) {
              // fragment
              return createVNode(Fragment, null, child)
            } else if (typeof child === 'object') {
              // already vnode, this should be the most common since compiled templates
              // always produce all-vnode children arrays
              return child.el === null ? child : cloneVNode(child)
            } else {
              // strings and numbers
              return createVNode(Text, null, String(child))
            }
          }
          // optimized normalization for template-compiled render fns
          function cloneIfMounted(child) {
            return child.el === null ? child : cloneVNode(child)
          }
          function normalizeChildren(vnode, children) {
            let type = 0
            const { shapeFlag } = vnode
            if (children == null) {
              children = null
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                children
              )
            ) {
              type = 16 /* ARRAY_CHILDREN */
            } else if (typeof children === 'object') {
              if (
                shapeFlag & 1 /* ELEMENT */ ||
                shapeFlag & 64 /* TELEPORT */
              ) {
                // Normalize slot to plain children for plain element and Teleport
                const slot = children.default
                if (slot) {
                  // _c marker is added by withCtx() indicating this is a compiled slot
                  slot._c && setCompiledSlotRendering(1)
                  normalizeChildren(vnode, slot())
                  slot._c && setCompiledSlotRendering(-1)
                }
                return
              } else {
                type = 32 /* SLOTS_CHILDREN */
                const slotFlag = children._
                if (!slotFlag && !(InternalObjectKey in children)) {
                  children._ctx = currentRenderingInstance
                } else if (
                  slotFlag === 3 /* FORWARDED */ &&
                  currentRenderingInstance
                ) {
                  // a child component receives forwarded slots from the parent.
                  // its slot type is determined by its parent's slot type.
                  if (
                    currentRenderingInstance.vnode.patchFlag &
                    1024 /* DYNAMIC_SLOTS */
                  ) {
                    children._ = 2 /* DYNAMIC */
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */
                  } else {
                    children._ = 1 /* STABLE */
                  }
                }
              }
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                children
              )
            ) {
              children = { default: children, _ctx: currentRenderingInstance }
              type = 32 /* SLOTS_CHILDREN */
            } else {
              children = String(children)
              // force teleport children to array so it can be moved around
              if (shapeFlag & 64 /* TELEPORT */) {
                type = 16 /* ARRAY_CHILDREN */
                children = [createTextVNode(children)]
              } else {
                type = 8 /* TEXT_CHILDREN */
              }
            }
            vnode.children = children
            vnode.shapeFlag |= type
          }
          function mergeProps(...args) {
            const ret = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
            )({}, args[0])
            for (let i = 1; i < args.length; i++) {
              const toMerge = args[i]
              for (const key in toMerge) {
                if (key === 'class') {
                  if (ret.class !== toMerge.class) {
                    ret.class = Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['normalizeClass']
                    )([ret.class, toMerge.class])
                  }
                } else if (key === 'style') {
                  ret.style = Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['normalizeStyle']
                  )([ret.style, toMerge.style])
                } else if (
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isOn'])(key)
                ) {
                  const existing = ret[key]
                  const incoming = toMerge[key]
                  if (existing !== incoming) {
                    ret[key] = existing
                      ? [].concat(existing, toMerge[key])
                      : incoming
                  }
                } else if (key !== '') {
                  ret[key] = toMerge[key]
                }
              }
            }
            return ret
          }

          function provide(key, value) {
            if (!currentInstance) {
              if (true) {
                warn(`provide() can only be used inside setup().`)
              }
            } else {
              let provides = currentInstance.provides
              // by default an instance inherits its parent's provides object
              // but when it needs to provide values of its own, it creates its
              // own provides object using parent provides object as prototype.
              // this way in `inject` we can simply look up injections from direct
              // parent and let the prototype chain do the work.
              const parentProvides =
                currentInstance.parent && currentInstance.parent.provides
              if (parentProvides === provides) {
                provides = currentInstance.provides = Object.create(
                  parentProvides
                )
              }
              // TS doesn't allow symbol as index type
              provides[key] = value
            }
          }
          function inject(key, defaultValue, treatDefaultAsFactory = false) {
            // fallback to `currentRenderingInstance` so that this can be called in
            // a functional component
            const instance = currentInstance || currentRenderingInstance
            if (instance) {
              // #2400
              // to support `app.use` plugins,
              // fallback to appContext's `provides` if the intance is at root
              const provides =
                instance.parent == null
                  ? instance.vnode.appContext &&
                    instance.vnode.appContext.provides
                  : instance.parent.provides
              if (provides && key in provides) {
                // TS doesn't allow symbol as index type
                return provides[key]
              } else if (arguments.length > 1) {
                return treatDefaultAsFactory &&
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(defaultValue)
                  ? defaultValue()
                  : defaultValue
              } else if (true) {
                warn(`injection "${String(key)}" not found.`)
              }
            } else if (true) {
              warn(
                `inject() can only be used inside setup() or functional components.`
              )
            }
          }

          function createDuplicateChecker() {
            const cache = Object.create(null)
            return (type, key) => {
              if (cache[key]) {
                warn(
                  `${type} property "${key}" is already defined in ${
                    cache[key]
                  }.`
                )
              } else {
                cache[key] = type
              }
            }
          }
          let isInBeforeCreate = false
          function applyOptions(
            instance,
            options,
            deferredData = [],
            deferredWatch = [],
            deferredProvide = [],
            asMixin = false
          ) {
            const {
              // composition
              mixins,
              extends: extendsOptions,
              // state
              data: dataOptions,
              computed: computedOptions,
              methods,
              watch: watchOptions,
              provide: provideOptions,
              inject: injectOptions,
              // assets
              components,
              directives,
              // lifecycle
              beforeMount,
              mounted,
              beforeUpdate,
              updated,
              activated,
              deactivated,
              beforeDestroy,
              beforeUnmount,
              destroyed,
              unmounted,
              render,
              renderTracked,
              renderTriggered,
              errorCaptured,
              // public API
              expose
            } = options
            const publicThis = instance.proxy
            const ctx = instance.ctx
            const globalMixins = instance.appContext.mixins
            if (
              asMixin &&
              render &&
              instance.render ===
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
            ) {
              instance.render = render
            }
            // applyOptions is called non-as-mixin once per instance
            if (!asMixin) {
              isInBeforeCreate = true
              callSyncHook(
                'beforeCreate',
                'bc' /* BEFORE_CREATE */,
                options,
                instance,
                globalMixins
              )
              isInBeforeCreate = false
              // global mixins are applied first
              applyMixins(
                instance,
                globalMixins,
                deferredData,
                deferredWatch,
                deferredProvide
              )
            }
            // extending a base component...
            if (extendsOptions) {
              applyOptions(
                instance,
                extendsOptions,
                deferredData,
                deferredWatch,
                deferredProvide,
                true
              )
            }
            // local mixins
            if (mixins) {
              applyMixins(
                instance,
                mixins,
                deferredData,
                deferredWatch,
                deferredProvide
              )
            }
            const checkDuplicateProperties = true
              ? createDuplicateChecker()
              : undefined
            if (true) {
              const [propsOptions] = instance.propsOptions
              if (propsOptions) {
                for (const key in propsOptions) {
                  checkDuplicateProperties('Props' /* PROPS */, key)
                }
              }
            }
            // options initialization order (to be consistent with Vue 2):
            // - props (already done outside of this function)
            // - inject
            // - methods
            // - data (deferred since it relies on `this` access)
            // - computed
            // - watch (deferred since it relies on `this` access)
            if (injectOptions) {
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                  injectOptions
                )
              ) {
                for (let i = 0; i < injectOptions.length; i++) {
                  const key = injectOptions[i]
                  ctx[key] = inject(key)
                  if (true) {
                    checkDuplicateProperties('Inject' /* INJECT */, key)
                  }
                }
              } else {
                for (const key in injectOptions) {
                  const opt = injectOptions[key]
                  if (
                    Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject']
                    )(opt)
                  ) {
                    ctx[key] = inject(
                      opt.from || key,
                      opt.default,
                      true /* treat default function as factory */
                    )
                  } else {
                    ctx[key] = inject(opt)
                  }
                  if (true) {
                    checkDuplicateProperties('Inject' /* INJECT */, key)
                  }
                }
              }
            }
            if (methods) {
              for (const key in methods) {
                const methodHandler = methods[key]
                if (
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(methodHandler)
                ) {
                  // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,
                  // and those are read-only but reconfigurable, so it needs to be redefined here
                  if (true) {
                    Object.defineProperty(ctx, key, {
                      value: methodHandler.bind(publicThis),
                      configurable: true,
                      enumerable: false
                    })
                  } else {
                  }
                  if (true) {
                    checkDuplicateProperties('Methods' /* METHODS */, key)
                  }
                } else if (true) {
                  warn(
                    `Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                      `Did you reference the function correctly?`
                  )
                }
              }
            }
            if (!asMixin) {
              if (deferredData.length) {
                deferredData.forEach(dataFn =>
                  resolveData(instance, dataFn, publicThis)
                )
              }
              if (dataOptions) {
                // @ts-ignore dataOptions is not fully type safe
                resolveData(instance, dataOptions, publicThis)
              }
              if (true) {
                const rawData = Object(
                  _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
                )(instance.data)
                for (const key in rawData) {
                  checkDuplicateProperties('Data' /* DATA */, key)
                  // expose data on ctx during dev
                  if (key[0] !== '$' && key[0] !== '_') {
                    Object.defineProperty(ctx, key, {
                      configurable: true,
                      enumerable: true,
                      get: () => rawData[key],
                      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
                    })
                  }
                }
              }
            } else if (dataOptions) {
              deferredData.push(dataOptions)
            }
            if (computedOptions) {
              for (const key in computedOptions) {
                const opt = computedOptions[key]
                const get = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                )(opt)
                  ? opt.bind(publicThis, publicThis)
                  : Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                    )(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
                if (
                  true &&
                  get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
                ) {
                  warn(`Computed property "${key}" has no getter.`)
                }
                const set =
                  !Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(opt) &&
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(opt.set)
                    ? opt.set.bind(publicThis)
                    : true
                      ? () => {
                          warn(
                            `Write operation failed: computed property "${key}" is readonly.`
                          )
                        }
                      : undefined
                const c = computed({
                  get,
                  set
                })
                Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => c.value,
                  set: v => (c.value = v)
                })
                if (true) {
                  checkDuplicateProperties('Computed' /* COMPUTED */, key)
                }
              }
            }
            if (watchOptions) {
              deferredWatch.push(watchOptions)
            }
            if (!asMixin && deferredWatch.length) {
              deferredWatch.forEach(watchOptions => {
                for (const key in watchOptions) {
                  createWatcher(watchOptions[key], ctx, publicThis, key)
                }
              })
            }
            if (provideOptions) {
              deferredProvide.push(provideOptions)
            }
            if (!asMixin && deferredProvide.length) {
              deferredProvide.forEach(provideOptions => {
                const provides = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                )(provideOptions)
                  ? provideOptions.call(publicThis)
                  : provideOptions
                Reflect.ownKeys(provides).forEach(key => {
                  provide(key, provides[key])
                })
              })
            }
            // asset options.
            // To reduce memory usage, only components with mixins or extends will have
            // resolved asset registry attached to instance.
            if (asMixin) {
              if (components) {
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                  instance.components ||
                    (instance.components = Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
                    )({}, instance.type.components)),
                  components
                )
              }
              if (directives) {
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                  instance.directives ||
                    (instance.directives = Object(
                      _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
                    )({}, instance.type.directives)),
                  directives
                )
              }
            }
            // lifecycle options
            if (!asMixin) {
              callSyncHook(
                'created',
                'c' /* CREATED */,
                options,
                instance,
                globalMixins
              )
            }
            if (beforeMount) {
              onBeforeMount(beforeMount.bind(publicThis))
            }
            if (mounted) {
              onMounted(mounted.bind(publicThis))
            }
            if (beforeUpdate) {
              onBeforeUpdate(beforeUpdate.bind(publicThis))
            }
            if (updated) {
              onUpdated(updated.bind(publicThis))
            }
            if (activated) {
              onActivated(activated.bind(publicThis))
            }
            if (deactivated) {
              onDeactivated(deactivated.bind(publicThis))
            }
            if (errorCaptured) {
              onErrorCaptured(errorCaptured.bind(publicThis))
            }
            if (renderTracked) {
              onRenderTracked(renderTracked.bind(publicThis))
            }
            if (renderTriggered) {
              onRenderTriggered(renderTriggered.bind(publicThis))
            }
            if (true && beforeDestroy) {
              warn(`\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`)
            }
            if (beforeUnmount) {
              onBeforeUnmount(beforeUnmount.bind(publicThis))
            }
            if (true && destroyed) {
              warn(`\`destroyed\` has been renamed to \`unmounted\`.`)
            }
            if (unmounted) {
              onUnmounted(unmounted.bind(publicThis))
            }
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                expose
              )
            ) {
              if (!asMixin) {
                if (expose.length) {
                  const exposed =
                    instance.exposed ||
                    (instance.exposed = Object(
                      _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['proxyRefs']
                    )({}))
                  expose.forEach(key => {
                    exposed[key] = Object(
                      _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRef']
                    )(publicThis, key)
                  })
                } else if (!instance.exposed) {
                  instance.exposed =
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
                }
              } else if (true) {
                warn(`The \`expose\` option is ignored when used in mixins.`)
              }
            }
          }
          function callSyncHook(name, type, options, instance, globalMixins) {
            callHookFromMixins(name, type, globalMixins, instance)
            const { extends: base, mixins } = options
            if (base) {
              callHookFromExtends(name, type, base, instance)
            }
            if (mixins) {
              callHookFromMixins(name, type, mixins, instance)
            }
            const selfHook = options[name]
            if (selfHook) {
              callWithAsyncErrorHandling(
                selfHook.bind(instance.proxy),
                instance,
                type
              )
            }
          }
          function callHookFromExtends(name, type, base, instance) {
            if (base.extends) {
              callHookFromExtends(name, type, base.extends, instance)
            }
            const baseHook = base[name]
            if (baseHook) {
              callWithAsyncErrorHandling(
                baseHook.bind(instance.proxy),
                instance,
                type
              )
            }
          }
          function callHookFromMixins(name, type, mixins, instance) {
            for (let i = 0; i < mixins.length; i++) {
              const chainedMixins = mixins[i].mixins
              if (chainedMixins) {
                callHookFromMixins(name, type, chainedMixins, instance)
              }
              const fn = mixins[i][name]
              if (fn) {
                callWithAsyncErrorHandling(
                  fn.bind(instance.proxy),
                  instance,
                  type
                )
              }
            }
          }
          function applyMixins(
            instance,
            mixins,
            deferredData,
            deferredWatch,
            deferredProvide
          ) {
            for (let i = 0; i < mixins.length; i++) {
              applyOptions(
                instance,
                mixins[i],
                deferredData,
                deferredWatch,
                deferredProvide,
                true
              )
            }
          }
          function resolveData(instance, dataFn, publicThis) {
            if (
              true &&
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                dataFn
              )
            ) {
              warn(
                `The data option must be a function. ` +
                  `Plain object usage is no longer supported.`
              )
            }
            const data = dataFn.call(publicThis, publicThis)
            if (
              true &&
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isPromise'])(
                data
              )
            ) {
              warn(
                `data() returned a Promise - note data() cannot be async; If you ` +
                  `intend to perform data fetching before component renders, use ` +
                  `async setup() + <Suspense>.`
              )
            }
            if (
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                data
              )
            ) {
              true && warn(`data() should return an object.`)
            } else if (
              instance.data ===
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
            ) {
              instance.data = Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['reactive']
              )(data)
            } else {
              // existing data: this is a mixin or extends.
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
                instance.data,
                data
              )
            }
          }
          function createWatcher(raw, ctx, publicThis, key) {
            const getter = key.includes('.')
              ? createPathGetter(publicThis, key)
              : () => publicThis[key]
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(raw)
            ) {
              const handler = ctx[raw]
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                  handler
                )
              ) {
                watch(getter, handler)
              } else if (true) {
                warn(`Invalid watch handler specified by key "${raw}"`, handler)
              }
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                raw
              )
            ) {
              watch(getter, raw.bind(publicThis))
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(raw)
            ) {
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(raw)
              ) {
                raw.forEach(r => createWatcher(r, ctx, publicThis, key))
              } else {
                const handler = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                )(raw.handler)
                  ? raw.handler.bind(publicThis)
                  : ctx[raw.handler]
                if (
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
                  )(handler)
                ) {
                  watch(getter, handler, raw)
                } else if (true) {
                  warn(
                    `Invalid watch handler specified by key "${raw.handler}"`,
                    handler
                  )
                }
              }
            } else if (true) {
              warn(`Invalid watch option: "${key}"`, raw)
            }
          }
          function createPathGetter(ctx, path) {
            const segments = path.split('.')
            return () => {
              let cur = ctx
              for (let i = 0; i < segments.length && cur; i++) {
                cur = cur[segments[i]]
              }
              return cur
            }
          }
          function resolveMergedOptions(instance) {
            const raw = instance.type
            const { __merged, mixins, extends: extendsOptions } = raw
            if (__merged) return __merged
            const globalMixins = instance.appContext.mixins
            if (!globalMixins.length && !mixins && !extendsOptions) return raw
            const options = {}
            globalMixins.forEach(m => mergeOptions(options, m, instance))
            mergeOptions(options, raw, instance)
            return (raw.__merged = options)
          }
          function mergeOptions(to, from, instance) {
            const strats = instance.appContext.config.optionMergeStrategies
            const { mixins, extends: extendsOptions } = from
            extendsOptions && mergeOptions(to, extendsOptions, instance)
            mixins && mixins.forEach(m => mergeOptions(to, m, instance))
            for (const key in from) {
              if (
                strats &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  strats,
                  key
                )
              ) {
                to[key] = strats[key](to[key], from[key], instance.proxy, key)
              } else {
                to[key] = from[key]
              }
            }
          }

          /**
           * #2437 In Vue 3, functional components do not have a public instance proxy but
           * they exist in the internal parent chain. For code that relies on traversing
           * public $parent chains, skip functional ones and go to the parent instead.
           */
          const getPublicInstance = i => {
            if (!i) return null
            if (isStatefulComponent(i)) return i.exposed ? i.exposed : i.proxy
            return getPublicInstance(i.parent)
          }
          const publicPropertiesMap = Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
          )(Object.create(null), {
            $: i => i,
            $el: i => i.vnode.el,
            $data: i => i.data,
            $props: i =>
              true
                ? Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                      'shallowReadonly'
                    ]
                  )(i.props)
                : undefined,
            $attrs: i =>
              true
                ? Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                      'shallowReadonly'
                    ]
                  )(i.attrs)
                : undefined,
            $slots: i =>
              true
                ? Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                      'shallowReadonly'
                    ]
                  )(i.slots)
                : undefined,
            $refs: i =>
              true
                ? Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                      'shallowReadonly'
                    ]
                  )(i.refs)
                : undefined,
            $parent: i => getPublicInstance(i.parent),
            $root: i => getPublicInstance(i.root),
            $emit: i => i.emit,
            $options: i =>
              __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
            $forceUpdate: i => () => queueJob(i.update),
            $nextTick: i => nextTick.bind(i.proxy),
            $watch: i =>
              __VUE_OPTIONS_API__
                ? instanceWatch.bind(i)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
          })
          const PublicInstanceProxyHandlers = {
            get({ _: instance }, key) {
              const {
                ctx,
                setupState,
                data,
                props,
                accessCache,
                type,
                appContext
              } = instance
              // let @vue/reactivity know it should never observe Vue public instances.
              if (key === '__v_skip' /* SKIP */) {
                return true
              }
              // for internal formatters to know that this is a Vue instance
              if (true && key === '__isVue') {
                return true
              }
              // data / props / ctx
              // This getter gets called for every property access on the render context
              // during render and is a major hotspot. The most expensive part of this
              // is the multiple hasOwn() calls. It's much faster to do a simple property
              // access on a plain object, so we use an accessCache object (with null
              // prototype) to memoize what access type a key corresponds to.
              let normalizedProps
              if (key[0] !== '$') {
                const n = accessCache[key]
                if (n !== undefined) {
                  switch (n) {
                    case 0 /* SETUP */:
                      return setupState[key]
                    case 1 /* DATA */:
                      return data[key]
                    case 3 /* CONTEXT */:
                      return ctx[key]
                    case 2 /* PROPS */:
                      return props[key]
                    // default: just fallthrough
                  }
                } else if (
                  setupState !==
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    setupState,
                    key
                  )
                ) {
                  accessCache[key] = 0 /* SETUP */
                  return setupState[key]
                } else if (
                  data !==
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    data,
                    key
                  )
                ) {
                  accessCache[key] = 1 /* DATA */
                  return data[key]
                } else if (
                  // only cache other properties when instance has declared (thus stable)
                  // props
                  (normalizedProps = instance.propsOptions[0]) &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    normalizedProps,
                    key
                  )
                ) {
                  accessCache[key] = 2 /* PROPS */
                  return props[key]
                } else if (
                  ctx !==
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    ctx,
                    key
                  )
                ) {
                  accessCache[key] = 3 /* CONTEXT */
                  return ctx[key]
                } else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {
                  accessCache[key] = 4 /* OTHER */
                }
              }
              const publicGetter = publicPropertiesMap[key]
              let cssModule, globalProperties
              // public $xxx properties
              if (publicGetter) {
                if (key === '$attrs') {
                  Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['track'])(
                    instance,
                    'get' /* GET */,
                    key
                  )
                  true && markAttrsAccessed()
                }
                return publicGetter(instance)
              } else if (
                // css module (injected by vue-loader)
                (cssModule = type.__cssModules) &&
                (cssModule = cssModule[key])
              ) {
                return cssModule
              } else if (
                ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  ctx,
                  key
                )
              ) {
                // user may set custom properties to `this` that start with `$`
                accessCache[key] = 3 /* CONTEXT */
                return ctx[key]
              } else if (
                // global properties
                ((globalProperties = appContext.config.globalProperties),
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  globalProperties,
                  key
                ))
              ) {
                return globalProperties[key]
              } else if (
                true &&
                currentRenderingInstance &&
                (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                  key
                ) ||
                  // #1091 avoid internal isRef/isVNode checks on component instance leading
                  // to infinite warning loop
                  key.indexOf('__v') !== 0)
              ) {
                if (
                  data !==
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                  (key[0] === '$' || key[0] === '_') &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    data,
                    key
                  )
                ) {
                  warn(
                    `Property ${JSON.stringify(
                      key
                    )} must be accessed via $data because it starts with a reserved ` +
                      `character ("$" or "_") and is not proxied on the render context.`
                  )
                } else if (instance === currentRenderingInstance) {
                  warn(
                    `Property ${JSON.stringify(
                      key
                    )} was accessed during render ` +
                      `but is not defined on instance.`
                  )
                }
              }
            },
            set({ _: instance }, key, value) {
              const { data, setupState, ctx } = instance
              if (
                setupState !==
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  setupState,
                  key
                )
              ) {
                setupState[key] = value
              } else if (
                data !==
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  data,
                  key
                )
              ) {
                data[key] = value
              } else if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  instance.props,
                  key
                )
              ) {
                true &&
                  warn(
                    `Attempting to mutate prop "${key}". Props are readonly.`,
                    instance
                  )
                return false
              }
              if (key[0] === '$' && key.slice(1) in instance) {
                true &&
                  warn(
                    `Attempting to mutate public property "${key}". ` +
                      `Properties starting with $ are reserved and readonly.`,
                    instance
                  )
                return false
              } else {
                if (
                  true &&
                  key in instance.appContext.config.globalProperties
                ) {
                  Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value
                  })
                } else {
                  ctx[key] = value
                }
              }
              return true
            },
            has(
              {
                _: {
                  data,
                  setupState,
                  accessCache,
                  ctx,
                  appContext,
                  propsOptions
                }
              },
              key
            ) {
              let normalizedProps
              return (
                accessCache[key] !== undefined ||
                (data !==
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    data,
                    key
                  )) ||
                (setupState !==
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'] &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    setupState,
                    key
                  )) ||
                ((normalizedProps = propsOptions[0]) &&
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                    normalizedProps,
                    key
                  )) ||
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  ctx,
                  key
                ) ||
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  publicPropertiesMap,
                  key
                ) ||
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hasOwn'])(
                  appContext.config.globalProperties,
                  key
                )
              )
            }
          }
          if (true) {
            PublicInstanceProxyHandlers.ownKeys = target => {
              warn(
                `Avoid app logic that relies on enumerating keys on a component instance. ` +
                  `The keys will be empty in production mode to avoid performance overhead.`
              )
              return Reflect.ownKeys(target)
            }
          }
          const RuntimeCompiledPublicInstanceProxyHandlers = Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
          )({}, PublicInstanceProxyHandlers, {
            get(target, key) {
              // fast path for unscopables when using `with` block
              if (key === Symbol.unscopables) {
                return
              }
              return PublicInstanceProxyHandlers.get(target, key, target)
            },
            has(_, key) {
              const has =
                key[0] !== '_' &&
                !Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__[
                    'isGloballyWhitelisted'
                  ]
                )(key)
              if (true && !has && PublicInstanceProxyHandlers.has(_, key)) {
                warn(
                  `Property ${JSON.stringify(
                    key
                  )} should not start with _ which is a reserved prefix for Vue internals.`
                )
              }
              return has
            }
          })
          // In dev mode, the proxy target exposes the same properties as seen on `this`
          // for easier console inspection. In prod mode it will be an empty object so
          // these properties definitions can be skipped.
          function createRenderContext(instance) {
            const target = {}
            // expose internal instance for proxy handlers
            Object.defineProperty(target, `_`, {
              configurable: true,
              enumerable: false,
              get: () => instance
            })
            // expose public properties
            Object.keys(publicPropertiesMap).forEach(key => {
              Object.defineProperty(target, key, {
                configurable: true,
                enumerable: false,
                get: () => publicPropertiesMap[key](instance),
                // intercepted by the proxy so no need for implementation,
                // but needed to prevent set errors
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
              })
            })
            // expose global properties
            const { globalProperties } = instance.appContext.config
            Object.keys(globalProperties).forEach(key => {
              Object.defineProperty(target, key, {
                configurable: true,
                enumerable: false,
                get: () => globalProperties[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
              })
            })
            return target
          }
          // dev only
          function exposePropsOnRenderContext(instance) {
            const {
              ctx,
              propsOptions: [propsOptions]
            } = instance
            if (propsOptions) {
              Object.keys(propsOptions).forEach(key => {
                Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => instance.props[key],
                  set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
                })
              })
            }
          }
          // dev only
          function exposeSetupStateOnRenderContext(instance) {
            const { ctx, setupState } = instance
            Object.keys(
              Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw'])(
                setupState
              )
            ).forEach(key => {
              if (key[0] === '$' || key[0] === '_') {
                warn(
                  `setup() return property ${JSON.stringify(
                    key
                  )} should not start with "$" or "_" ` +
                    `which are reserved prefixes for Vue internals.`
                )
                return
              }
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => setupState[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
              })
            })
          }

          const emptyAppContext = createAppContext()
          let uid$1 = 0
          function createComponentInstance(vnode, parent, suspense) {
            const type = vnode.type
            // inherit parent app context - or - if root, adopt from root vnode
            const appContext =
              (parent ? parent.appContext : vnode.appContext) || emptyAppContext
            const instance = {
              uid: uid$1++,
              vnode,
              type,
              parent,
              appContext,
              root: null,
              next: null,
              subTree: null,
              update: null,
              render: null,
              proxy: null,
              exposed: null,
              withProxy: null,
              effects: null,
              provides: parent
                ? parent.provides
                : Object.create(appContext.provides),
              accessCache: null,
              renderCache: [],
              // local resovled assets
              components: null,
              directives: null,
              // resolved props and emits options
              propsOptions: normalizePropsOptions(type, appContext),
              emitsOptions: normalizeEmitsOptions(type, appContext),
              // emit
              emit: null,
              emitted: null,
              // state
              ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
              data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
              props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
              attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
              slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
              refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
              setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ'],
              setupContext: null,
              // suspense related
              suspense,
              suspenseId: suspense ? suspense.pendingId : 0,
              asyncDep: null,
              asyncResolved: false,
              // lifecycle hooks
              // not using enums here because it results in computed properties
              isMounted: false,
              isUnmounted: false,
              isDeactivated: false,
              bc: null,
              c: null,
              bm: null,
              m: null,
              bu: null,
              u: null,
              um: null,
              bum: null,
              da: null,
              a: null,
              rtg: null,
              rtc: null,
              ec: null
            }
            if (true) {
              instance.ctx = createRenderContext(instance)
            } else {
            }
            instance.root = parent ? parent.root : instance
            instance.emit = emit.bind(null, instance)
            return instance
          }
          let currentInstance = null
          const getCurrentInstance = () =>
            currentInstance || currentRenderingInstance
          const setCurrentInstance = instance => {
            currentInstance = instance
          }
          const isBuiltInTag = /*#__PURE__*/ Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__['makeMap']
          )('slot,component')
          function validateComponentName(name, config) {
            const appIsNativeTag =
              config.isNativeTag ||
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NO']
            if (isBuiltInTag(name) || appIsNativeTag(name)) {
              warn(
                'Do not use built-in or reserved HTML elements as component id: ' +
                  name
              )
            }
          }
          function isStatefulComponent(instance) {
            return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
          }
          let isInSSRComponentSetup = false
          function setupComponent(instance, isSSR = false) {
            isInSSRComponentSetup = isSSR
            const { props, children } = instance.vnode
            const isStateful = isStatefulComponent(instance)
            initProps(instance, props, isStateful, isSSR)
            initSlots(instance, children)
            const setupResult = isStateful
              ? setupStatefulComponent(instance, isSSR)
              : undefined
            isInSSRComponentSetup = false
            return setupResult
          }
          function setupStatefulComponent(instance, isSSR) {
            const Component = instance.type
            if (true) {
              if (Component.name) {
                validateComponentName(
                  Component.name,
                  instance.appContext.config
                )
              }
              if (Component.components) {
                const names = Object.keys(Component.components)
                for (let i = 0; i < names.length; i++) {
                  validateComponentName(names[i], instance.appContext.config)
                }
              }
              if (Component.directives) {
                const names = Object.keys(Component.directives)
                for (let i = 0; i < names.length; i++) {
                  validateDirectiveName(names[i])
                }
              }
            }
            // 0. create render proxy property access cache
            instance.accessCache = Object.create(null)
            // 1. create public instance / render proxy
            // also mark it raw so it's never observed
            instance.proxy = new Proxy(
              instance.ctx,
              PublicInstanceProxyHandlers
            )
            if (true) {
              exposePropsOnRenderContext(instance)
            }
            // 2. call setup()
            const { setup } = Component
            if (setup) {
              const setupContext = (instance.setupContext =
                setup.length > 1 ? createSetupContext(instance) : null)
              currentInstance = instance
              Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['pauseTracking']
              )()
              const setupResult = callWithErrorHandling(
                setup,
                instance,
                0 /* SETUP_FUNCTION */,
                [
                  true
                    ? Object(
                        _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                          'shallowReadonly'
                        ]
                      )(instance.props)
                    : undefined,
                  setupContext
                ]
              )
              Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['resetTracking']
              )()
              currentInstance = null
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isPromise'])(
                  setupResult
                )
              ) {
                if (isSSR) {
                  // return the promise so server-renderer can wait on it
                  return setupResult.then(resolvedResult => {
                    handleSetupResult(instance, resolvedResult)
                  })
                } else {
                  // async setup returned Promise.
                  // bail here and wait for re-entry.
                  instance.asyncDep = setupResult
                }
              } else {
                handleSetupResult(instance, setupResult)
              }
            } else {
              finishComponentSetup(instance)
            }
          }
          function handleSetupResult(instance, setupResult, isSSR) {
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                setupResult
              )
            ) {
              // setup returned an inline render function
              {
                instance.render = setupResult
              }
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                setupResult
              )
            ) {
              if (true && isVNode(setupResult)) {
                warn(
                  `setup() should not return VNodes directly - ` +
                    `return a render function instead.`
                )
              }
              // setup returned bindings.
              // assuming a render function compiled from template is present.
              if (true) {
                instance.devtoolsRawSetupState = setupResult
              }
              instance.setupState = Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['proxyRefs']
              )(setupResult)
              if (true) {
                exposeSetupStateOnRenderContext(instance)
              }
            } else if (true && setupResult !== undefined) {
              warn(
                `setup() should return an object. Received: ${
                  setupResult === null ? 'null' : typeof setupResult
                }`
              )
            }
            finishComponentSetup(instance)
          }
          let compile
          /**
           * For runtime-dom to register the compiler.
           * Note the exported method uses any to avoid d.ts relying on the compiler types.
           */
          function registerRuntimeCompiler(_compile) {
            compile = _compile
          }
          function finishComponentSetup(instance, isSSR) {
            const Component = instance.type
            // template / render function normalization
            if (!instance.render) {
              // could be set from setup()
              if (compile && Component.template && !Component.render) {
                if (true) {
                  startMeasure(instance, `compile`)
                }
                Component.render = compile(Component.template, {
                  isCustomElement: instance.appContext.config.isCustomElement,
                  delimiters: Component.delimiters
                })
                if (true) {
                  endMeasure(instance, `compile`)
                }
              }
              instance.render =
                Component.render ||
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
              // for runtime-compiled render functions using `with` blocks, the render
              // proxy used needs a different `has` handler which is more performant and
              // also only allows a whitelist of globals to fallthrough.
              if (instance.render._rc) {
                instance.withProxy = new Proxy(
                  instance.ctx,
                  RuntimeCompiledPublicInstanceProxyHandlers
                )
              }
            }
            // support for 2.x options
            if (__VUE_OPTIONS_API__) {
              currentInstance = instance
              Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['pauseTracking']
              )()
              applyOptions(instance, Component)
              Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['resetTracking']
              )()
              currentInstance = null
            }
            // warn missing template/render
            if (
              true &&
              !Component.render &&
              instance.render ===
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['NOOP']
            ) {
              /* istanbul ignore if */
              if (!compile && Component.template) {
                warn(
                  `Component provided template option but ` +
                    `runtime compilation is not supported in this build of Vue.` +
                    ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".` /* should not happen */
                )
              } else {
                warn(`Component is missing template or render function.`)
              }
            }
          }
          const attrHandlers = {
            get: (target, key) => {
              if (true) {
                markAttrsAccessed()
              }
              return target[key]
            },
            set: () => {
              warn(`setupContext.attrs is readonly.`)
              return false
            },
            deleteProperty: () => {
              warn(`setupContext.attrs is readonly.`)
              return false
            }
          }
          function createSetupContext(instance) {
            const expose = exposed => {
              if (true && instance.exposed) {
                warn(`expose() should be called only once per setup().`)
              }
              instance.exposed = Object(
                _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['proxyRefs']
              )(exposed)
            }
            if (true) {
              // We use getters in dev in case libs like test-utils overwrite instance
              // properties (overwrites should not be done in prod)
              return Object.freeze({
                get props() {
                  return instance.props
                },
                get attrs() {
                  return new Proxy(instance.attrs, attrHandlers)
                },
                get slots() {
                  return Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                      'shallowReadonly'
                    ]
                  )(instance.slots)
                },
                get emit() {
                  return (event, ...args) => instance.emit(event, ...args)
                },
                expose
              })
            } else {
            }
          }
          // record effects created during a component's setup() so that they can be
          // stopped when the component unmounts
          function recordInstanceBoundEffect(
            effect,
            instance = currentInstance
          ) {
            if (instance) {
              ;(instance.effects || (instance.effects = [])).push(effect)
            }
          }
          const classifyRE = /(?:^|[-_])(\w)/g
          const classify = str =>
            str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '')
          function getComponentName(Component) {
            return Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction']
            )(Component)
              ? Component.displayName || Component.name
              : Component.name
          }
          /* istanbul ignore next */
          function formatComponentName(instance, Component, isRoot = false) {
            let name = getComponentName(Component)
            if (!name && Component.__file) {
              const match = Component.__file.match(/([^/\\]+)\.\w+$/)
              if (match) {
                name = match[1]
              }
            }
            if (!name && instance && instance.parent) {
              // try to infer the name based on reverse resolution
              const inferFromRegistry = registry => {
                for (const key in registry) {
                  if (registry[key] === Component) {
                    return key
                  }
                }
              }
              name =
                inferFromRegistry(
                  instance.components || instance.parent.type.components
                ) || inferFromRegistry(instance.appContext.components)
            }
            return name ? classify(name) : isRoot ? `App` : `Anonymous`
          }
          function isClassComponent(value) {
            return (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                value
              ) && '__vccOpts' in value
            )
          }

          function computed(getterOrOptions) {
            const c = Object(
              _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['computed']
            )(getterOrOptions)
            recordInstanceBoundEffect(c.effect)
            return c
          }

          // implementation
          function defineProps() {
            if (true) {
              warn(
                `defineProps() is a compiler-hint helper that is only usable inside ` +
                  `<script setup> of a single file component. Its arguments should be ` +
                  `compiled away and passing it at runtime has no effect.`
              )
            }
            return null
          }
          // implementation
          function defineEmit() {
            if (true) {
              warn(
                `defineEmit() is a compiler-hint helper that is only usable inside ` +
                  `<script setup> of a single file component. Its arguments should be ` +
                  `compiled away and passing it at runtime has no effect.`
              )
            }
            return null
          }
          function useContext() {
            const i = getCurrentInstance()
            if (true && !i) {
              warn(`useContext() called without active instance.`)
            }
            return i.setupContext || (i.setupContext = createSetupContext(i))
          }

          // Actual implementation
          function h(type, propsOrChildren, children) {
            const l = arguments.length
            if (l === 2) {
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                  propsOrChildren
                ) &&
                !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                  propsOrChildren
                )
              ) {
                // single vnode without props
                if (isVNode(propsOrChildren)) {
                  return createVNode(type, null, [propsOrChildren])
                }
                // props without children
                return createVNode(type, propsOrChildren)
              } else {
                // omit props
                return createVNode(type, null, propsOrChildren)
              }
            } else {
              if (l > 3) {
                children = Array.prototype.slice.call(arguments, 2)
              } else if (l === 3 && isVNode(children)) {
                children = [children]
              }
              return createVNode(type, propsOrChildren, children)
            }
          }

          const ssrContextKey = Symbol(true ? `ssrContext` : undefined)
          const useSSRContext = () => {
            {
              const ctx = inject(ssrContextKey)
              if (!ctx) {
                warn(
                  `Server rendering context not provided. Make sure to only call ` +
                    `useSSRContext() conditionally in the server build.`
                )
              }
              return ctx
            }
          }

          function initCustomFormatter() {
            /* eslint-disable no-restricted-globals */
            if (false || typeof window === 'undefined') {
              return
            }
            const vueStyle = { style: 'color:#3ba776' }
            const numberStyle = { style: 'color:#0b1bc9' }
            const stringStyle = { style: 'color:#b62e24' }
            const keywordStyle = { style: 'color:#9d288c' }
            // custom formatter for Chrome
            // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
            const formatter = {
              header(obj) {
                // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
                if (
                  !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                    obj
                  )
                ) {
                  return null
                }
                if (obj.__isVue) {
                  return ['div', vueStyle, `VueInstance`]
                } else if (
                  Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isRef'])(
                    obj
                  )
                ) {
                  return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                  ]
                } else if (
                  Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isReactive']
                  )(obj)
                ) {
                  return [
                    'div',
                    {},
                    ['span', vueStyle, 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${
                      Object(
                        _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__[
                          'isReadonly'
                        ]
                      )(obj)
                        ? ` (readonly)`
                        : ``
                    }`
                  ]
                } else if (
                  Object(
                    _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['isReadonly']
                  )(obj)
                ) {
                  return [
                    'div',
                    {},
                    ['span', vueStyle, 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                  ]
                }
                return null
              },
              hasBody(obj) {
                return obj && obj.__isVue
              },
              body(obj) {
                if (obj && obj.__isVue) {
                  return ['div', {}, ...formatInstance(obj.$)]
                }
              }
            }
            function formatInstance(instance) {
              const blocks = []
              if (instance.type.props && instance.props) {
                blocks.push(
                  createInstanceBlock(
                    'props',
                    Object(
                      _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
                    )(instance.props)
                  )
                )
              }
              if (
                instance.setupState !==
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
              ) {
                blocks.push(createInstanceBlock('setup', instance.setupState))
              }
              if (
                instance.data !==
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
              ) {
                blocks.push(
                  createInstanceBlock(
                    'data',
                    Object(
                      _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
                    )(instance.data)
                  )
                )
              }
              const computed = extractKeys(instance, 'computed')
              if (computed) {
                blocks.push(createInstanceBlock('computed', computed))
              }
              const injected = extractKeys(instance, 'inject')
              if (injected) {
                blocks.push(createInstanceBlock('injected', injected))
              }
              blocks.push([
                'div',
                {},
                [
                  'span',
                  {
                    style: keywordStyle.style + ';opacity:0.66'
                  },
                  '$ (internal): '
                ],
                ['object', { object: instance }]
              ])
              return blocks
            }
            function createInstanceBlock(type, target) {
              target = Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
              )({}, target)
              if (!Object.keys(target).length) {
                return ['span', {}]
              }
              return [
                'div',
                { style: 'line-height:1.25em;margin-bottom:0.6em' },
                [
                  'div',
                  {
                    style: 'color:#476582'
                  },
                  type
                ],
                [
                  'div',
                  {
                    style: 'padding-left:1.25em'
                  },
                  ...Object.keys(target).map(key => {
                    return [
                      'div',
                      {},
                      ['span', keywordStyle, key + ': '],
                      formatValue(target[key], false)
                    ]
                  })
                ]
              ]
            }
            function formatValue(v, asRaw = true) {
              if (typeof v === 'number') {
                return ['span', numberStyle, v]
              } else if (typeof v === 'string') {
                return ['span', stringStyle, JSON.stringify(v)]
              } else if (typeof v === 'boolean') {
                return ['span', keywordStyle, v]
              } else if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(v)
              ) {
                return [
                  'object',
                  {
                    object: asRaw
                      ? Object(
                          _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__['toRaw']
                        )(v)
                      : v
                  }
                ]
              } else {
                return ['span', stringStyle, String(v)]
              }
            }
            function extractKeys(instance, type) {
              const Comp = instance.type
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                  Comp
                )
              ) {
                return
              }
              const extracted = {}
              for (const key in instance.ctx) {
                if (isKeyOfType(Comp, key, type)) {
                  extracted[key] = instance.ctx[key]
                }
              }
              return extracted
            }
            function isKeyOfType(Comp, key, type) {
              const opts = Comp[type]
              if (
                (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                  opts
                ) &&
                  opts.includes(key)) ||
                (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                  opts
                ) &&
                  key in opts)
              ) {
                return true
              }
              if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
                return true
              }
              if (
                Comp.mixins &&
                Comp.mixins.some(m => isKeyOfType(m, key, type))
              ) {
                return true
              }
            }
            function genRefFlag(v) {
              if (v._shallow) {
                return `ShallowRef`
              }
              if (v.effect) {
                return `ComputedRef`
              }
              return `Ref`
            }
            if (window.devtoolsFormatters) {
              window.devtoolsFormatters.push(formatter)
            } else {
              window.devtoolsFormatters = [formatter]
            }
          }

          /**
           * Actual implementation
           */
          function renderList(source, renderItem) {
            let ret
            if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                source
              ) ||
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                source
              )
            ) {
              ret = new Array(source.length)
              for (let i = 0, l = source.length; i < l; i++) {
                ret[i] = renderItem(source[i], i)
              }
            } else if (typeof source === 'number') {
              if (true && !Number.isInteger(source)) {
                warn(
                  `The v-for range expect an integer value but got ${source}.`
                )
                return []
              }
              ret = new Array(source)
              for (let i = 0; i < source; i++) {
                ret[i] = renderItem(i + 1, i)
              }
            } else if (
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
                source
              )
            ) {
              if (source[Symbol.iterator]) {
                ret = Array.from(source, renderItem)
              } else {
                const keys = Object.keys(source)
                ret = new Array(keys.length)
                for (let i = 0, l = keys.length; i < l; i++) {
                  const key = keys[i]
                  ret[i] = renderItem(source[key], key, i)
                }
              }
            } else {
              ret = []
            }
            return ret
          }

          /**
           * For prefixing keys in v-on="obj" with "on"
           * @private
           */
          function toHandlers(obj) {
            const ret = {}
            if (
              true &&
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(obj)
            ) {
              warn(`v-on with no argument expects an object value.`)
              return ret
            }
            for (const key in obj) {
              ret[
                Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toHandlerKey']
                )(key)
              ] = obj[key]
            }
            return ret
          }

          /**
           * Compiler runtime helper for creating dynamic slots object
           * @private
           */
          function createSlots(slots, dynamicSlots) {
            for (let i = 0; i < dynamicSlots.length; i++) {
              const slot = dynamicSlots[i]
              // array of dynamic slot generated by <template v-for="..." #[...]>
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                  slot
                )
              ) {
                for (let j = 0; j < slot.length; j++) {
                  slots[slot[j].name] = slot[j].fn
                }
              } else if (slot) {
                // conditional single slot generated by <template v-if="..." #foo>
                slots[slot.name] = slot.fn
              }
            }
            return slots
          }

          // Core API ------------------------------------------------------------------
          const version = '3.0.6'
          /**
           * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
           * @internal
           */
          const ssrUtils = null

          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../../_webpack@4.46.0@webpack/buildin/global.js */ './node_modules/_webpack@4.46.0@webpack/buildin/global.js'
          )
        ))

        /***/
      },

    /***/ './node_modules/_@vue_runtime-dom@3.0.6@@vue/runtime-dom/dist/runtime-dom.esm-bundler.js':
      /*!***********************************************************************************************!*\
  !*** ./node_modules/_@vue_runtime-dom@3.0.6@@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************************************/
      /*! exports provided: customRef, isProxy, isReactive, isReadonly, isRef, markRaw, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, camelize, capitalize, toDisplayString, toHandlerKey, BaseTransition, Comment, Fragment, KeepAlive, Static, Suspense, Teleport, Text, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, computed, createBlock, createCommentVNode, createHydrationRenderer, createRenderer, createSlots, createStaticVNode, createTextVNode, createVNode, defineAsyncComponent, defineComponent, defineEmit, defineProps, devtools, getCurrentInstance, getTransitionRawChildren, h, handleError, initCustomFormatter, inject, isVNode, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onUnmounted, onUpdated, openBlock, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useContext, useSSRContext, useTransitionState, version, warn, watch, watchEffect, withCtx, withDirectives, withScopeId, Transition, TransitionGroup, createApp, createSSRApp, hydrate, render, useCssModule, useCssVars, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, withKeys, withModifiers */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        'use strict'
        __webpack_require__.r(__webpack_exports__)
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'Transition',
          function() {
            return Transition
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'TransitionGroup',
          function() {
            return TransitionGroup
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'createApp',
          function() {
            return createApp
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'createSSRApp',
          function() {
            return createSSRApp
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'hydrate',
          function() {
            return hydrate
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'render',
          function() {
            return render
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'useCssModule',
          function() {
            return useCssModule
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'useCssVars',
          function() {
            return useCssVars
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelCheckbox',
          function() {
            return vModelCheckbox
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelDynamic',
          function() {
            return vModelDynamic
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelRadio',
          function() {
            return vModelRadio
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelSelect',
          function() {
            return vModelSelect
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'vModelText',
          function() {
            return vModelText
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'vShow',
          function() {
            return vShow
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'withKeys',
          function() {
            return withKeys
          }
        )
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          'withModifiers',
          function() {
            return withModifiers
          }
        )
        /* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @vue/runtime-core */ './node_modules/_@vue_runtime-core@3.0.6@@vue/runtime-core/dist/runtime-core.esm-bundler.js'
        )
        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'customRef',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['customRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isProxy',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['isProxy']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isReactive',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['isReactive']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isReadonly',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['isReadonly']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isRef',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['isRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'markRaw',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['markRaw']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'proxyRefs',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['proxyRefs']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'reactive',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['reactive']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'readonly',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['readonly']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'ref',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['ref']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowReactive',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'shallowReactive'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowReadonly',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'shallowReadonly'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'shallowRef',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['shallowRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toRaw',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['toRaw']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toRef',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['toRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toRefs',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['toRefs']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'triggerRef',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['triggerRef']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'unref',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['unref']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'camelize',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['camelize']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'capitalize',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['capitalize']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toDisplayString',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'toDisplayString'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toHandlerKey',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'toHandlerKey'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'BaseTransition',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'BaseTransition'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Comment',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['Comment']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Fragment',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['Fragment']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'KeepAlive',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['KeepAlive']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Static',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['Static']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Suspense',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['Suspense']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Teleport',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['Teleport']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'Text',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['Text']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'callWithAsyncErrorHandling',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'callWithAsyncErrorHandling'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'callWithErrorHandling',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'callWithErrorHandling'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'cloneVNode',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['cloneVNode']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'computed',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['computed']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createBlock',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['createBlock']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createCommentVNode',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'createCommentVNode'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createHydrationRenderer',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'createHydrationRenderer'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createRenderer',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'createRenderer'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createSlots',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['createSlots']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createStaticVNode',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'createStaticVNode'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createTextVNode',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'createTextVNode'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'createVNode',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['createVNode']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'defineAsyncComponent',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'defineAsyncComponent'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'defineComponent',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'defineComponent'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'defineEmit',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['defineEmit']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'defineProps',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['defineProps']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'devtools',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['devtools']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'getCurrentInstance',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'getCurrentInstance'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'getTransitionRawChildren',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'getTransitionRawChildren'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'h',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['h']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'handleError',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['handleError']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'initCustomFormatter',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'initCustomFormatter'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'inject',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['inject']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'isVNode',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['isVNode']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'mergeProps',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['mergeProps']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'nextTick',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['nextTick']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onActivated',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['onActivated']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onBeforeMount',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'onBeforeMount'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onBeforeUnmount',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'onBeforeUnmount'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onBeforeUpdate',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'onBeforeUpdate'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onDeactivated',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'onDeactivated'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onErrorCaptured',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'onErrorCaptured'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onMounted',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['onMounted']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onRenderTracked',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'onRenderTracked'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onRenderTriggered',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'onRenderTriggered'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onUnmounted',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['onUnmounted']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'onUpdated',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['onUpdated']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'openBlock',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['openBlock']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'popScopeId',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['popScopeId']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'provide',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['provide']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'pushScopeId',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['pushScopeId']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'queuePostFlushCb',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'queuePostFlushCb'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'registerRuntimeCompiler',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'registerRuntimeCompiler'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'renderList',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['renderList']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'renderSlot',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['renderSlot']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'resolveComponent',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'resolveComponent'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'resolveDirective',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'resolveDirective'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'resolveDynamicComponent',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'resolveDynamicComponent'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'resolveTransitionHooks',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'resolveTransitionHooks'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'setBlockTracking',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'setBlockTracking'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'setDevtoolsHook',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'setDevtoolsHook'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'setTransitionHooks',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'setTransitionHooks'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'ssrContextKey',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'ssrContextKey'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'ssrUtils',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['ssrUtils']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'toHandlers',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['toHandlers']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'transformVNodeArgs',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'transformVNodeArgs'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'useContext',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['useContext']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'useSSRContext',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'useSSRContext'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'useTransitionState',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'useTransitionState'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'version',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['version']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'warn',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'watch',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['watch']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'watchEffect',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['watchEffect']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'withCtx',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['withCtx']
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'withDirectives',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
              'withDirectives'
            ]
          }
        )

        /* harmony reexport (safe) */ __webpack_require__.d(
          __webpack_exports__,
          'withScopeId',
          function() {
            return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['withScopeId']
          }
        )

        /* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! @vue/shared */ './node_modules/_@vue_shared@3.0.6@@vue/shared/dist/shared.esm-bundler.js'
        )

        const svgNS = 'http://www.w3.org/2000/svg'
        const doc = typeof document !== 'undefined' ? document : null
        let tempContainer
        let tempSVGContainer
        const nodeOps = {
          insert: (child, parent, anchor) => {
            parent.insertBefore(child, anchor || null)
          },
          remove: child => {
            const parent = child.parentNode
            if (parent) {
              parent.removeChild(child)
            }
          },
          createElement: (tag, isSVG, is) =>
            isSVG
              ? doc.createElementNS(svgNS, tag)
              : doc.createElement(tag, is ? { is } : undefined),
          createText: text => doc.createTextNode(text),
          createComment: text => doc.createComment(text),
          setText: (node, text) => {
            node.nodeValue = text
          },
          setElementText: (el, text) => {
            el.textContent = text
          },
          parentNode: node => node.parentNode,
          nextSibling: node => node.nextSibling,
          querySelector: selector => doc.querySelector(selector),
          setScopeId(el, id) {
            el.setAttribute(id, '')
          },
          cloneNode(el) {
            return el.cloneNode(true)
          },
          // __UNSAFE__
          // Reason: innerHTML.
          // Static content here can only come from compiled templates.
          // As long as the user only uses trusted templates, this is safe.
          insertStaticContent(content, parent, anchor, isSVG) {
            const temp = isSVG
              ? tempSVGContainer ||
                (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))
              : tempContainer || (tempContainer = doc.createElement('div'))
            temp.innerHTML = content
            const first = temp.firstChild
            let node = first
            let last = node
            while (node) {
              last = node
              nodeOps.insert(node, parent, anchor)
              node = temp.firstChild
            }
            return [first, last]
          }
        }

        // compiler should normalize class + :class bindings on the same element
        // into a single binding ['staticClass', dynamic]
        function patchClass(el, value, isSVG) {
          if (value == null) {
            value = ''
          }
          if (isSVG) {
            el.setAttribute('class', value)
          } else {
            // directly setting className should be faster than setAttribute in theory
            // if this is an element during a transition, take the temporary transition
            // classes into account.
            const transitionClasses = el._vtc
            if (transitionClasses) {
              value = (value
                ? [value, ...transitionClasses]
                : [...transitionClasses]
              ).join(' ')
            }
            el.className = value
          }
        }

        function patchStyle(el, prev, next) {
          const style = el.style
          if (!next) {
            el.removeAttribute('style')
          } else if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(next)
          ) {
            if (prev !== next) {
              style.cssText = next
            }
          } else {
            for (const key in next) {
              setStyle(style, key, next[key])
            }
            if (
              prev &&
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
                prev
              )
            ) {
              for (const key in prev) {
                if (next[key] == null) {
                  setStyle(style, key, '')
                }
              }
            }
          }
        }
        const importantRE = /\s*!important$/
        function setStyle(style, name, val) {
          if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(val)
          ) {
            val.forEach(v => setStyle(style, name, v))
          } else {
            if (name.startsWith('--')) {
              // custom property definition
              style.setProperty(name, val)
            } else {
              const prefixed = autoPrefix(style, name)
              if (importantRE.test(val)) {
                // !important
                style.setProperty(
                  Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hyphenate'])(
                    prefixed
                  ),
                  val.replace(importantRE, ''),
                  'important'
                )
              } else {
                style[prefixed] = val
              }
            }
          }
        }
        const prefixes = ['Webkit', 'Moz', 'ms']
        const prefixCache = {}
        function autoPrefix(style, rawName) {
          const cached = prefixCache[rawName]
          if (cached) {
            return cached
          }
          let name = Object(
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['camelize']
          )(rawName)
          if (name !== 'filter' && name in style) {
            return (prefixCache[rawName] = name)
          }
          name = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['capitalize'])(
            name
          )
          for (let i = 0; i < prefixes.length; i++) {
            const prefixed = prefixes[i] + name
            if (prefixed in style) {
              return (prefixCache[rawName] = prefixed)
            }
          }
          return rawName
        }

        const xlinkNS = 'http://www.w3.org/1999/xlink'
        function patchAttr(el, key, value, isSVG) {
          if (isSVG && key.startsWith('xlink:')) {
            if (value == null) {
              el.removeAttributeNS(xlinkNS, key.slice(6, key.length))
            } else {
              el.setAttributeNS(xlinkNS, key, value)
            }
          } else {
            // note we are only checking boolean attributes that don't have a
            // corresponding dom prop of the same name here.
            const isBoolean = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isSpecialBooleanAttr']
            )(key)
            if (value == null || (isBoolean && value === false)) {
              el.removeAttribute(key)
            } else {
              el.setAttribute(key, isBoolean ? '' : value)
            }
          }
        }

        // __UNSAFE__
        // functions. The user is responsible for using them with only trusted content.
        function patchDOMProp(
          el,
          key,
          value,
          // the following args are passed only due to potential innerHTML/textContent
          // overriding existing VNodes, in which case the old tree must be properly
          // unmounted.
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        ) {
          if (key === 'innerHTML' || key === 'textContent') {
            if (prevChildren) {
              unmountChildren(prevChildren, parentComponent, parentSuspense)
            }
            el[key] = value == null ? '' : value
            return
          }
          if (key === 'value' && el.tagName !== 'PROGRESS') {
            // store value as _value as well since
            // non-string values will be stringified.
            el._value = value
            const newValue = value == null ? '' : value
            if (el.value !== newValue) {
              el.value = newValue
            }
            return
          }
          if (value === '' || value == null) {
            const type = typeof el[key]
            if (value === '' && type === 'boolean') {
              // e.g. <select multiple> compiles to { multiple: '' }
              el[key] = true
              return
            } else if (value == null && type === 'string') {
              // e.g. <div :id="null">
              el[key] = ''
              el.removeAttribute(key)
              return
            } else if (type === 'number') {
              // e.g. <img :width="null">
              el[key] = 0
              el.removeAttribute(key)
              return
            }
          }
          // some properties perform value validation and throw
          try {
            el[key] = value
          } catch (e) {
            if (true) {
              Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
                `Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                  `value ${value} is invalid.`,
                e
              )
            }
          }
        }

        // Async edge case fix requires storing an event listener's attach timestamp.
        let _getNow = Date.now
        // Determine what event timestamp the browser is using. Annoyingly, the
        // timestamp can either be hi-res (relative to page load) or low-res
        // (relative to UNIX epoch), so in order to compare time we have to use the
        // same timestamp type when saving the flush timestamp.
        if (
          typeof document !== 'undefined' &&
          _getNow() > document.createEvent('Event').timeStamp
        ) {
          // if the low-res timestamp which is bigger than the event timestamp
          // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
          // and we need to use the hi-res version for event listeners as well.
          _getNow = () => performance.now()
        }
        // To avoid the overhead of repeatedly calling performance.now(), we cache
        // and use the same timestamp for all event listeners attached in the same tick.
        let cachedNow = 0
        const p = Promise.resolve()
        const reset = () => {
          cachedNow = 0
        }
        const getNow = () =>
          cachedNow || (p.then(reset), (cachedNow = _getNow()))
        function addEventListener(el, event, handler, options) {
          el.addEventListener(event, handler, options)
        }
        function removeEventListener(el, event, handler, options) {
          el.removeEventListener(event, handler, options)
        }
        function patchEvent(
          el,
          rawName,
          prevValue,
          nextValue,
          instance = null
        ) {
          // vei = vue event invokers
          const invokers = el._vei || (el._vei = {})
          const existingInvoker = invokers[rawName]
          if (nextValue && existingInvoker) {
            // patch
            existingInvoker.value = nextValue
          } else {
            const [name, options] = parseName(rawName)
            if (nextValue) {
              // add
              const invoker = (invokers[rawName] = createInvoker(
                nextValue,
                instance
              ))
              addEventListener(el, name, invoker, options)
            } else if (existingInvoker) {
              // remove
              removeEventListener(el, name, existingInvoker, options)
              invokers[rawName] = undefined
            }
          }
        }
        const optionsModifierRE = /(?:Once|Passive|Capture)$/
        function parseName(name) {
          let options
          if (optionsModifierRE.test(name)) {
            options = {}
            let m
            while ((m = name.match(optionsModifierRE))) {
              name = name.slice(0, name.length - m[0].length)
              options[m[0].toLowerCase()] = true
            }
          }
          return [
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['hyphenate'])(
              name.slice(2)
            ),
            options
          ]
        }
        function createInvoker(initialValue, instance) {
          const invoker = e => {
            // async edge case #6566: inner click event triggers patch, event handler
            // attached to outer element during patch, and triggered again. This
            // happens because browsers fire microtask ticks between event propagation.
            // the solution is simple: we save the timestamp when a handler is attached,
            // and the handler would only fire if the event passed to it was fired
            // AFTER it was attached.
            const timeStamp = e.timeStamp || _getNow()
            if (timeStamp >= invoker.attached - 1) {
              Object(
                _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                  'callWithAsyncErrorHandling'
                ]
              )(
                patchStopImmediatePropagation(e, invoker.value),
                instance,
                5 /* NATIVE_EVENT_HANDLER */,
                [e]
              )
            }
          }
          invoker.value = initialValue
          invoker.attached = getNow()
          return invoker
        }
        function patchStopImmediatePropagation(e, value) {
          if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(value)
          ) {
            const originalStop = e.stopImmediatePropagation
            e.stopImmediatePropagation = () => {
              originalStop.call(e)
              e._stopped = true
            }
            return value.map(fn => e => !e._stopped && fn(e))
          } else {
            return value
          }
        }

        const nativeOnRE = /^on[a-z]/
        const forcePatchProp = (_, key) => key === 'value'
        const patchProp = (
          el,
          key,
          prevValue,
          nextValue,
          isSVG = false,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        ) => {
          switch (key) {
            // special
            case 'class':
              patchClass(el, nextValue, isSVG)
              break
            case 'style':
              patchStyle(el, prevValue, nextValue)
              break
            default:
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isOn'])(key)
              ) {
                // ignore v-model listeners
                if (
                  !Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isModelListener']
                  )(key)
                ) {
                  patchEvent(el, key, prevValue, nextValue, parentComponent)
                }
              } else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
                patchDOMProp(
                  el,
                  key,
                  nextValue,
                  prevChildren,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                )
              } else {
                // special case for <input v-model type="checkbox"> with
                // :true-value & :false-value
                // store value as dom properties since non-string values will be
                // stringified.
                if (key === 'true-value') {
                  el._trueValue = nextValue
                } else if (key === 'false-value') {
                  el._falseValue = nextValue
                }
                patchAttr(el, key, nextValue, isSVG)
              }
              break
          }
        }
        function shouldSetAsProp(el, key, value, isSVG) {
          if (isSVG) {
            // most keys must be set as attribute on svg elements to work
            // ...except innerHTML
            if (key === 'innerHTML') {
              return true
            }
            // or native onclick with function values
            if (
              key in el &&
              nativeOnRE.test(key) &&
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                value
              )
            ) {
              return true
            }
            return false
          }
          // spellcheck and draggable are numerated attrs, however their
          // corresponding DOM properties are actually booleans - this leads to
          // setting it with a string "false" value leading it to be coerced to
          // `true`, so we need to always treat them as attributes.
          // Note that `contentEditable` doesn't have this problem: its DOM
          // property is also enumerated string values.
          if (key === 'spellcheck' || key === 'draggable') {
            return false
          }
          // #1787, #2840 form property on form elements is readonly and must be set as
          // attribute.
          if (key === 'form') {
            return false
          }
          // #1526 <input list> must be set as attribute
          if (key === 'list' && el.tagName === 'INPUT') {
            return false
          }
          // #2766 <textarea type> must be set as attribute
          if (key === 'type' && el.tagName === 'TEXTAREA') {
            return false
          }
          // native onclick with string value, must be set as attribute
          if (
            nativeOnRE.test(key) &&
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(value)
          ) {
            return false
          }
          return key in el
        }

        function useCssModule(name = '$style') {
          /* istanbul ignore else */
          {
            const instance = Object(
              _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                'getCurrentInstance'
              ]
            )()
            if (!instance) {
              true &&
                Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
                  `useCssModule must be called inside setup()`
                )
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
            }
            const modules = instance.type.__cssModules
            if (!modules) {
              true &&
                Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
                  `Current instance does not have CSS modules injected.`
                )
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
            }
            const mod = modules[name]
            if (!mod) {
              true &&
                Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
                  `Current instance does not have CSS module named "${name}".`
                )
              return _vue_shared__WEBPACK_IMPORTED_MODULE_1__['EMPTY_OBJ']
            }
            return mod
          }
        }

        /**
         * Runtime helper for SFC's CSS variable injection feature.
         * @private
         */
        function useCssVars(getter) {
          const instance = Object(
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['getCurrentInstance']
          )()
          /* istanbul ignore next */
          if (!instance) {
            true &&
              Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
                `useCssVars is called without current active component instance.`
              )
            return
          }
          const setVars = () =>
            setVarsOnVNode(instance.subTree, getter(instance.proxy))
          Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['onMounted'])(
            () =>
              Object(
                _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['watchEffect']
              )(setVars, { flush: 'post' })
          )
          Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['onUpdated'])(
            setVars
          )
        }
        function setVarsOnVNode(vnode, vars) {
          if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            const suspense = vnode.suspense
            vnode = suspense.activeBranch
            if (suspense.pendingBranch && !suspense.isHydrating) {
              suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars)
              })
            }
          }
          // drill down HOCs until it's a non-component vnode
          while (vnode.component) {
            vnode = vnode.component.subTree
          }
          if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
            const style = vnode.el.style
            for (const key in vars) {
              style.setProperty(`--${key}`, vars[key])
            }
          } else if (
            vnode.type ===
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['Fragment']
          ) {
            vnode.children.forEach(c => setVarsOnVNode(c, vars))
          }
        }

        const TRANSITION = 'transition'
        const ANIMATION = 'animation'
        // DOM Transition is a higher-order-component based on the platform-agnostic
        // base Transition component, with DOM-specific logic.
        const Transition = (props, { slots }) =>
          Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['h'])(
            _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['BaseTransition'],
            resolveTransitionProps(props),
            slots
          )
        Transition.displayName = 'Transition'
        const DOMTransitionPropsValidators = {
          name: String,
          type: String,
          css: {
            type: Boolean,
            default: true
          },
          duration: [String, Number, Object],
          enterFromClass: String,
          enterActiveClass: String,
          enterToClass: String,
          appearFromClass: String,
          appearActiveClass: String,
          appearToClass: String,
          leaveFromClass: String,
          leaveActiveClass: String,
          leaveToClass: String
        }
        const TransitionPropsValidators = (Transition.props = /*#__PURE__*/ Object(
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
        )(
          {},
          _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['BaseTransition']
            .props,
          DOMTransitionPropsValidators
        ))
        function resolveTransitionProps(rawProps) {
          let {
            name = 'v',
            type,
            css = true,
            duration,
            enterFromClass = `${name}-enter-from`,
            enterActiveClass = `${name}-enter-active`,
            enterToClass = `${name}-enter-to`,
            appearFromClass = enterFromClass,
            appearActiveClass = enterActiveClass,
            appearToClass = enterToClass,
            leaveFromClass = `${name}-leave-from`,
            leaveActiveClass = `${name}-leave-active`,
            leaveToClass = `${name}-leave-to`
          } = rawProps
          const baseProps = {}
          for (const key in rawProps) {
            if (!(key in DOMTransitionPropsValidators)) {
              baseProps[key] = rawProps[key]
            }
          }
          if (!css) {
            return baseProps
          }
          const durations = normalizeDuration(duration)
          const enterDuration = durations && durations[0]
          const leaveDuration = durations && durations[1]
          const {
            onBeforeEnter,
            onEnter,
            onEnterCancelled,
            onLeave,
            onLeaveCancelled,
            onBeforeAppear = onBeforeEnter,
            onAppear = onEnter,
            onAppearCancelled = onEnterCancelled
          } = baseProps
          const finishEnter = (el, isAppear, done) => {
            removeTransitionClass(el, isAppear ? appearToClass : enterToClass)
            removeTransitionClass(
              el,
              isAppear ? appearActiveClass : enterActiveClass
            )
            done && done()
          }
          const finishLeave = (el, done) => {
            removeTransitionClass(el, leaveToClass)
            removeTransitionClass(el, leaveActiveClass)
            done && done()
          }
          const makeEnterHook = isAppear => {
            return (el, done) => {
              const hook = isAppear ? onAppear : onEnter
              const resolve = () => finishEnter(el, isAppear, done)
              hook && hook(el, resolve)
              nextFrame(() => {
                removeTransitionClass(
                  el,
                  isAppear ? appearFromClass : enterFromClass
                )
                addTransitionClass(el, isAppear ? appearToClass : enterToClass)
                if (!(hook && hook.length > 1)) {
                  whenTransitionEnds(el, type, enterDuration, resolve)
                }
              })
            }
          }
          return Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend'])(
            baseProps,
            {
              onBeforeEnter(el) {
                onBeforeEnter && onBeforeEnter(el)
                addTransitionClass(el, enterFromClass)
                addTransitionClass(el, enterActiveClass)
              },
              onBeforeAppear(el) {
                onBeforeAppear && onBeforeAppear(el)
                addTransitionClass(el, appearFromClass)
                addTransitionClass(el, appearActiveClass)
              },
              onEnter: makeEnterHook(false),
              onAppear: makeEnterHook(true),
              onLeave(el, done) {
                const resolve = () => finishLeave(el, done)
                addTransitionClass(el, leaveFromClass)
                // force reflow so *-leave-from classes immediately take effect (#2593)
                forceReflow()
                addTransitionClass(el, leaveActiveClass)
                nextFrame(() => {
                  removeTransitionClass(el, leaveFromClass)
                  addTransitionClass(el, leaveToClass)
                  if (!(onLeave && onLeave.length > 1)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve)
                  }
                })
                onLeave && onLeave(el, resolve)
              },
              onEnterCancelled(el) {
                finishEnter(el, false)
                onEnterCancelled && onEnterCancelled(el)
              },
              onAppearCancelled(el) {
                finishEnter(el, true)
                onAppearCancelled && onAppearCancelled(el)
              },
              onLeaveCancelled(el) {
                finishLeave(el)
                onLeaveCancelled && onLeaveCancelled(el)
              }
            }
          )
        }
        function normalizeDuration(duration) {
          if (duration == null) {
            return null
          } else if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isObject'])(
              duration
            )
          ) {
            return [NumberOf(duration.enter), NumberOf(duration.leave)]
          } else {
            const n = NumberOf(duration)
            return [n, n]
          }
        }
        function NumberOf(val) {
          const res = Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toNumber']
          )(val)
          if (true) validateDuration(res)
          return res
        }
        function validateDuration(val) {
          if (typeof val !== 'number') {
            Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
              `<transition> explicit duration is not a valid number - ` +
                `got ${JSON.stringify(val)}.`
            )
          } else if (isNaN(val)) {
            Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
              `<transition> explicit duration is NaN - ` +
                'the duration expression might be incorrect.'
            )
          }
        }
        function addTransitionClass(el, cls) {
          cls.split(/\s+/).forEach(c => c && el.classList.add(c))
          ;(el._vtc || (el._vtc = new Set())).add(cls)
        }
        function removeTransitionClass(el, cls) {
          cls.split(/\s+/).forEach(c => c && el.classList.remove(c))
          const { _vtc } = el
          if (_vtc) {
            _vtc.delete(cls)
            if (!_vtc.size) {
              el._vtc = undefined
            }
          }
        }
        function nextFrame(cb) {
          requestAnimationFrame(() => {
            requestAnimationFrame(cb)
          })
        }
        let endId = 0
        function whenTransitionEnds(
          el,
          expectedType,
          explicitTimeout,
          resolve
        ) {
          const id = (el._endId = ++endId)
          const resolveIfNotStale = () => {
            if (id === el._endId) {
              resolve()
            }
          }
          if (explicitTimeout) {
            return setTimeout(resolveIfNotStale, explicitTimeout)
          }
          const { type, timeout, propCount } = getTransitionInfo(
            el,
            expectedType
          )
          if (!type) {
            return resolve()
          }
          const endEvent = type + 'end'
          let ended = 0
          const end = () => {
            el.removeEventListener(endEvent, onEnd)
            resolveIfNotStale()
          }
          const onEnd = e => {
            if (e.target === el && ++ended >= propCount) {
              end()
            }
          }
          setTimeout(() => {
            if (ended < propCount) {
              end()
            }
          }, timeout + 1)
          el.addEventListener(endEvent, onEnd)
        }
        function getTransitionInfo(el, expectedType) {
          const styles = window.getComputedStyle(el)
          // JSDOM may return undefined for transition properties
          const getStyleProperties = key => (styles[key] || '').split(', ')
          const transitionDelays = getStyleProperties(TRANSITION + 'Delay')
          const transitionDurations = getStyleProperties(
            TRANSITION + 'Duration'
          )
          const transitionTimeout = getTimeout(
            transitionDelays,
            transitionDurations
          )
          const animationDelays = getStyleProperties(ANIMATION + 'Delay')
          const animationDurations = getStyleProperties(ANIMATION + 'Duration')
          const animationTimeout = getTimeout(
            animationDelays,
            animationDurations
          )
          let type = null
          let timeout = 0
          let propCount = 0
          /* istanbul ignore if */
          if (expectedType === TRANSITION) {
            if (transitionTimeout > 0) {
              type = TRANSITION
              timeout = transitionTimeout
              propCount = transitionDurations.length
            }
          } else if (expectedType === ANIMATION) {
            if (animationTimeout > 0) {
              type = ANIMATION
              timeout = animationTimeout
              propCount = animationDurations.length
            }
          } else {
            timeout = Math.max(transitionTimeout, animationTimeout)
            type =
              timeout > 0
                ? transitionTimeout > animationTimeout
                  ? TRANSITION
                  : ANIMATION
                : null
            propCount = type
              ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
              : 0
          }
          const hasTransform =
            type === TRANSITION &&
            /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property'])
          return {
            type,
            timeout,
            propCount,
            hasTransform
          }
        }
        function getTimeout(delays, durations) {
          while (delays.length < durations.length) {
            delays = delays.concat(delays)
          }
          return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])))
        }
        // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
        // numbers in a locale-dependent way, using a comma instead of a dot.
        // If comma is not replaced with a dot, the input will be rounded down
        // (i.e. acting as a floor function) causing unexpected behaviors
        function toMs(s) {
          return Number(s.slice(0, -1).replace(',', '.')) * 1000
        }
        // synchronously force layout to put elements into a certain state
        function forceReflow() {
          return document.body.offsetHeight
        }

        const positionMap = new WeakMap()
        const newPositionMap = new WeakMap()
        const TransitionGroupImpl = {
          name: 'TransitionGroup',
          props: /*#__PURE__*/ Object(
            _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
          )({}, TransitionPropsValidators, {
            tag: String,
            moveClass: String
          }),
          setup(props, { slots }) {
            const instance = Object(
              _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                'getCurrentInstance'
              ]
            )()
            const state = Object(
              _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                'useTransitionState'
              ]
            )()
            let prevChildren
            let children
            Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['onUpdated'])(
              () => {
                // children is guaranteed to exist after initial render
                if (!prevChildren.length) {
                  return
                }
                const moveClass = props.moveClass || `${props.name || 'v'}-move`
                if (
                  !hasCSSTransform(
                    prevChildren[0].el,
                    instance.vnode.el,
                    moveClass
                  )
                ) {
                  return
                }
                // we divide the work into three loops to avoid mixing DOM reads and writes
                // in each iteration - which helps prevent layout thrashing.
                prevChildren.forEach(callPendingCbs)
                prevChildren.forEach(recordPosition)
                const movedChildren = prevChildren.filter(applyTranslation)
                // force reflow to put everything in position
                forceReflow()
                movedChildren.forEach(c => {
                  const el = c.el
                  const style = el.style
                  addTransitionClass(el, moveClass)
                  style.transform = style.webkitTransform = style.transitionDuration =
                    ''
                  const cb = (el._moveCb = e => {
                    if (e && e.target !== el) {
                      return
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                      el.removeEventListener('transitionend', cb)
                      el._moveCb = null
                      removeTransitionClass(el, moveClass)
                    }
                  })
                  el.addEventListener('transitionend', cb)
                })
              }
            )
            return () => {
              const rawProps = Object(
                _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['toRaw']
              )(props)
              const cssTransitionProps = resolveTransitionProps(rawProps)
              const tag =
                rawProps.tag ||
                _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['Fragment']
              prevChildren = children
              children = slots.default
                ? Object(
                    _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                      'getTransitionRawChildren'
                    ]
                  )(slots.default())
                : []
              for (let i = 0; i < children.length; i++) {
                const child = children[i]
                if (child.key != null) {
                  Object(
                    _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                      'setTransitionHooks'
                    ]
                  )(
                    child,
                    Object(
                      _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                        'resolveTransitionHooks'
                      ]
                    )(child, cssTransitionProps, state, instance)
                  )
                } else if (true) {
                  Object(
                    _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn']
                  )(`<TransitionGroup> children must be keyed.`)
                }
              }
              if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                  const child = prevChildren[i]
                  Object(
                    _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                      'setTransitionHooks'
                    ]
                  )(
                    child,
                    Object(
                      _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                        'resolveTransitionHooks'
                      ]
                    )(child, cssTransitionProps, state, instance)
                  )
                  positionMap.set(child, child.el.getBoundingClientRect())
                }
              }
              return Object(
                _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['createVNode']
              )(tag, null, children)
            }
          }
        }
        const TransitionGroup = TransitionGroupImpl
        function callPendingCbs(c) {
          const el = c.el
          if (el._moveCb) {
            el._moveCb()
          }
          if (el._enterCb) {
            el._enterCb()
          }
        }
        function recordPosition(c) {
          newPositionMap.set(c, c.el.getBoundingClientRect())
        }
        function applyTranslation(c) {
          const oldPos = positionMap.get(c)
          const newPos = newPositionMap.get(c)
          const dx = oldPos.left - newPos.left
          const dy = oldPos.top - newPos.top
          if (dx || dy) {
            const s = c.el.style
            s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`
            s.transitionDuration = '0s'
            return c
          }
        }
        function hasCSSTransform(el, root, moveClass) {
          // Detect whether an element with the move class applied has
          // CSS transitions. Since the element may be inside an entering
          // transition at this very moment, we make a clone of it and remove
          // all other transition classes applied to ensure only the move class
          // is applied.
          const clone = el.cloneNode()
          if (el._vtc) {
            el._vtc.forEach(cls => {
              cls.split(/\s+/).forEach(c => c && clone.classList.remove(c))
            })
          }
          moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c))
          clone.style.display = 'none'
          const container = root.nodeType === 1 ? root : root.parentNode
          container.appendChild(clone)
          const { hasTransform } = getTransitionInfo(clone)
          container.removeChild(clone)
          return hasTransform
        }

        const getModelAssigner = vnode => {
          const fn = vnode.props['onUpdate:modelValue']
          return Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(fn)
            ? value =>
                Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['invokeArrayFns']
                )(fn, value)
            : fn
        }
        function onCompositionStart(e) {
          e.target.composing = true
        }
        function onCompositionEnd(e) {
          const target = e.target
          if (target.composing) {
            target.composing = false
            trigger(target, 'input')
          }
        }
        function trigger(el, type) {
          const e = document.createEvent('HTMLEvents')
          e.initEvent(type, true, true)
          el.dispatchEvent(e)
        }
        // We are exporting the v-model runtime directly as vnode hooks so that it can
        // be tree-shaken in case v-model is never used.
        const vModelText = {
          created(
            el,
            {
              modifiers: { lazy, trim, number }
            },
            vnode
          ) {
            el._assign = getModelAssigner(vnode)
            const castToNumber = number || el.type === 'number'
            addEventListener(el, lazy ? 'change' : 'input', e => {
              if (e.target.composing) return
              let domValue = el.value
              if (trim) {
                domValue = domValue.trim()
              } else if (castToNumber) {
                domValue = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toNumber']
                )(domValue)
              }
              el._assign(domValue)
            })
            if (trim) {
              addEventListener(el, 'change', () => {
                el.value = el.value.trim()
              })
            }
            if (!lazy) {
              addEventListener(el, 'compositionstart', onCompositionStart)
              addEventListener(el, 'compositionend', onCompositionEnd)
              // Safari < 10.2 & UIWebView doesn't fire compositionend when
              // switching focus before confirming composition choice
              // this also fixes the issue where some browsers e.g. iOS Chrome
              // fires "change" instead of "input" on autocomplete.
              addEventListener(el, 'change', onCompositionEnd)
            }
          },
          // set value on mounted so it's after min/max for type="range"
          mounted(el, { value }) {
            el.value = value == null ? '' : value
          },
          beforeUpdate(
            el,
            {
              value,
              modifiers: { trim, number }
            },
            vnode
          ) {
            el._assign = getModelAssigner(vnode)
            // avoid clearing unresolved text. #2302
            if (el.composing) return
            if (document.activeElement === el) {
              if (trim && el.value.trim() === value) {
                return
              }
              if (
                (number || el.type === 'number') &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['toNumber'])(
                  el.value
                ) === value
              ) {
                return
              }
            }
            const newValue = value == null ? '' : value
            if (el.value !== newValue) {
              el.value = newValue
            }
          }
        }
        const vModelCheckbox = {
          created(el, _, vnode) {
            el._assign = getModelAssigner(vnode)
            addEventListener(el, 'change', () => {
              const modelValue = el._modelValue
              const elementValue = getValue(el)
              const checked = el.checked
              const assign = el._assign
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                  modelValue
                )
              ) {
                const index = Object(
                  _vue_shared__WEBPACK_IMPORTED_MODULE_1__['looseIndexOf']
                )(modelValue, elementValue)
                const found = index !== -1
                if (checked && !found) {
                  assign(modelValue.concat(elementValue))
                } else if (!checked && found) {
                  const filtered = [...modelValue]
                  filtered.splice(index, 1)
                  assign(filtered)
                }
              } else if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isSet'])(
                  modelValue
                )
              ) {
                const cloned = new Set(modelValue)
                if (checked) {
                  cloned.add(elementValue)
                } else {
                  cloned.delete(elementValue)
                }
                assign(cloned)
              } else {
                assign(getCheckboxValue(el, checked))
              }
            })
          },
          // set initial checked on mount to wait for true-value/false-value
          mounted: setChecked,
          beforeUpdate(el, binding, vnode) {
            el._assign = getModelAssigner(vnode)
            setChecked(el, binding, vnode)
          }
        }
        function setChecked(el, { value, oldValue }, vnode) {
          el._modelValue = value
          if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(value)
          ) {
            el.checked =
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['looseIndexOf'])(
                value,
                vnode.props.value
              ) > -1
          } else if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isSet'])(value)
          ) {
            el.checked = value.has(vnode.props.value)
          } else if (value !== oldValue) {
            el.checked = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['looseEqual']
            )(value, getCheckboxValue(el, true))
          }
        }
        const vModelRadio = {
          created(el, { value }, vnode) {
            el.checked = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['looseEqual']
            )(value, vnode.props.value)
            el._assign = getModelAssigner(vnode)
            addEventListener(el, 'change', () => {
              el._assign(getValue(el))
            })
          },
          beforeUpdate(el, { value, oldValue }, vnode) {
            el._assign = getModelAssigner(vnode)
            if (value !== oldValue) {
              el.checked = Object(
                _vue_shared__WEBPACK_IMPORTED_MODULE_1__['looseEqual']
              )(value, vnode.props.value)
            }
          }
        }
        const vModelSelect = {
          created(
            el,
            {
              value,
              modifiers: { number }
            },
            vnode
          ) {
            const isSetModel = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['isSet']
            )(value)
            addEventListener(el, 'change', () => {
              const selectedVal = Array.prototype.filter
                .call(el.options, o => o.selected)
                .map(
                  o =>
                    number
                      ? Object(
                          _vue_shared__WEBPACK_IMPORTED_MODULE_1__['toNumber']
                        )(getValue(o))
                      : getValue(o)
                )
              el._assign(
                el.multiple
                  ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                  : selectedVal[0]
              )
            })
            el._assign = getModelAssigner(vnode)
          },
          // set value in mounted & updated because <select> relies on its children
          // <option>s.
          mounted(el, { value }) {
            setSelected(el, value)
          },
          beforeUpdate(el, _binding, vnode) {
            el._assign = getModelAssigner(vnode)
          },
          updated(el, { value }) {
            setSelected(el, value)
          }
        }
        function setSelected(el, value) {
          const isMultiple = el.multiple
          if (
            isMultiple &&
            !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
              value
            ) &&
            !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isSet'])(value)
          ) {
            true &&
              Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
                `<select multiple v-model> expects an Array or Set value for its binding, ` +
                  `but got ${Object.prototype.toString
                    .call(value)
                    .slice(8, -1)}.`
              )
            return
          }
          for (let i = 0, l = el.options.length; i < l; i++) {
            const option = el.options[i]
            const optionValue = getValue(option)
            if (isMultiple) {
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isArray'])(
                  value
                )
              ) {
                option.selected =
                  Object(
                    _vue_shared__WEBPACK_IMPORTED_MODULE_1__['looseIndexOf']
                  )(value, optionValue) > -1
              } else {
                option.selected = value.has(optionValue)
              }
            } else {
              if (
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['looseEqual'])(
                  getValue(option),
                  value
                )
              ) {
                el.selectedIndex = i
                return
              }
            }
          }
          if (!isMultiple) {
            el.selectedIndex = -1
          }
        }
        // retrieve raw value set via :value bindings
        function getValue(el) {
          return '_value' in el ? el._value : el.value
        }
        // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
        function getCheckboxValue(el, checked) {
          const key = checked ? '_trueValue' : '_falseValue'
          return key in el ? el[key] : checked
        }
        const vModelDynamic = {
          created(el, binding, vnode) {
            callModelHook(el, binding, vnode, null, 'created')
          },
          mounted(el, binding, vnode) {
            callModelHook(el, binding, vnode, null, 'mounted')
          },
          beforeUpdate(el, binding, vnode, prevVNode) {
            callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate')
          },
          updated(el, binding, vnode, prevVNode) {
            callModelHook(el, binding, vnode, prevVNode, 'updated')
          }
        }
        function callModelHook(el, binding, vnode, prevVNode, hook) {
          let modelToUse
          switch (el.tagName) {
            case 'SELECT':
              modelToUse = vModelSelect
              break
            case 'TEXTAREA':
              modelToUse = vModelText
              break
            default:
              switch (vnode.props && vnode.props.type) {
                case 'checkbox':
                  modelToUse = vModelCheckbox
                  break
                case 'radio':
                  modelToUse = vModelRadio
                  break
                default:
                  modelToUse = vModelText
              }
          }
          const fn = modelToUse[hook]
          fn && fn(el, binding, vnode, prevVNode)
        }

        const systemModifiers = ['ctrl', 'shift', 'alt', 'meta']
        const modifierGuards = {
          stop: e => e.stopPropagation(),
          prevent: e => e.preventDefault(),
          self: e => e.target !== e.currentTarget,
          ctrl: e => !e.ctrlKey,
          shift: e => !e.shiftKey,
          alt: e => !e.altKey,
          meta: e => !e.metaKey,
          left: e => 'button' in e && e.button !== 0,
          middle: e => 'button' in e && e.button !== 1,
          right: e => 'button' in e && e.button !== 2,
          exact: (e, modifiers) =>
            systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
        }
        /**
         * @private
         */
        const withModifiers = (fn, modifiers) => {
          return (event, ...args) => {
            for (let i = 0; i < modifiers.length; i++) {
              const guard = modifierGuards[modifiers[i]]
              if (guard && guard(event, modifiers)) return
            }
            return fn(event, ...args)
          }
        }
        // Kept for 2.x compat.
        // Note: IE11 compat for `spacebar` and `del` is removed for now.
        const keyNames = {
          esc: 'escape',
          space: ' ',
          up: 'arrow-up',
          left: 'arrow-left',
          right: 'arrow-right',
          down: 'arrow-down',
          delete: 'backspace'
        }
        /**
         * @private
         */
        const withKeys = (fn, modifiers) => {
          return event => {
            if (!('key' in event)) return
            const eventKey = Object(
              _vue_shared__WEBPACK_IMPORTED_MODULE_1__['hyphenate']
            )(event.key)
            if (
              // None of the provided key modifiers match the current event key
              !modifiers.some(k => k === eventKey || keyNames[k] === eventKey)
            ) {
              return
            }
            return fn(event)
          }
        }

        const vShow = {
          beforeMount(el, { value }, { transition }) {
            el._vod = el.style.display === 'none' ? '' : el.style.display
            if (transition && value) {
              transition.beforeEnter(el)
            } else {
              setDisplay(el, value)
            }
          },
          mounted(el, { value }, { transition }) {
            if (transition && value) {
              transition.enter(el)
            }
          },
          updated(el, { value, oldValue }, { transition }) {
            if (transition && value !== oldValue) {
              if (value) {
                transition.beforeEnter(el)
                setDisplay(el, true)
                transition.enter(el)
              } else {
                transition.leave(el, () => {
                  setDisplay(el, false)
                })
              }
            } else {
              setDisplay(el, value)
            }
          },
          beforeUnmount(el, { value }) {
            setDisplay(el, value)
          }
        }
        function setDisplay(el, value) {
          el.style.display = value ? el._vod : 'none'
        }

        const rendererOptions = Object(
          _vue_shared__WEBPACK_IMPORTED_MODULE_1__['extend']
        )({ patchProp, forcePatchProp }, nodeOps)
        // lazy create the renderer - this makes core renderer logic tree-shakable
        // in case the user only imports reactivity utilities from Vue.
        let renderer
        let enabledHydration = false
        function ensureRenderer() {
          return (
            renderer ||
            (renderer = Object(
              _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['createRenderer']
            )(rendererOptions))
          )
        }
        function ensureHydrationRenderer() {
          renderer = enabledHydration
            ? renderer
            : Object(
                _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[
                  'createHydrationRenderer'
                ]
              )(rendererOptions)
          enabledHydration = true
          return renderer
        }
        // use explicit type casts here to avoid import() calls in rolled-up d.ts
        const render = (...args) => {
          ensureRenderer().render(...args)
        }
        const hydrate = (...args) => {
          ensureHydrationRenderer().hydrate(...args)
        }
        const createApp = (...args) => {
          const app = ensureRenderer().createApp(...args)
          if (true) {
            injectNativeTagCheck(app)
          }
          const { mount } = app
          app.mount = containerOrSelector => {
            const container = normalizeContainer(containerOrSelector)
            if (!container) return
            const component = app._component
            if (
              !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isFunction'])(
                component
              ) &&
              !component.render &&
              !component.template
            ) {
              component.template = container.innerHTML
            }
            // clear content before mounting
            container.innerHTML = ''
            const proxy = mount(container)
            if (container instanceof Element) {
              container.removeAttribute('v-cloak')
              container.setAttribute('data-v-app', '')
            }
            return proxy
          }
          return app
        }
        const createSSRApp = (...args) => {
          const app = ensureHydrationRenderer().createApp(...args)
          if (true) {
            injectNativeTagCheck(app)
          }
          const { mount } = app
          app.mount = containerOrSelector => {
            const container = normalizeContainer(containerOrSelector)
            if (container) {
              return mount(container, true)
            }
          }
          return app
        }
        function injectNativeTagCheck(app) {
          // Inject `isNativeTag`
          // this is used for component name validation (dev only)
          Object.defineProperty(app.config, 'isNativeTag', {
            value: tag =>
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isHTMLTag'])(
                tag
              ) ||
              Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isSVGTag'])(tag),
            writable: false
          })
        }
        function normalizeContainer(container) {
          if (
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__['isString'])(
              container
            )
          ) {
            const res = document.querySelector(container)
            if (true && !res) {
              Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
                `Failed to mount app: mount target selector "${container}" returned null.`
              )
            }
            return res
          }
          if (
            true &&
            container instanceof window.ShadowRoot &&
            container.mode === 'closed'
          ) {
            Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__['warn'])(
              `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
            )
          }
          return container
        }

        /***/
      },

    /***/ './node_modules/_@vue_shared@3.0.6@@vue/shared/dist/shared.esm-bundler.js':
      /*!********************************************************************************!*\
  !*** ./node_modules/_@vue_shared@3.0.6@@vue/shared/dist/shared.esm-bundler.js ***!
  \********************************************************************************/
      /*! exports provided: EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, babelParserDefaultPlugins, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, invokeArrayFns, isArray, isBooleanAttr, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownAttr, isMap, isModelListener, isNoUnitNumericStyleProp, isObject, isOn, isPlainObject, isPromise, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, makeMap, normalizeClass, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        'use strict'
        __webpack_require__.r(__webpack_exports__)
        /* WEBPACK VAR INJECTION */ ;(function(global) {
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'EMPTY_ARR',
            function() {
              return EMPTY_ARR
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'EMPTY_OBJ',
            function() {
              return EMPTY_OBJ
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'NO',
            function() {
              return NO
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'NOOP',
            function() {
              return NOOP
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'PatchFlagNames',
            function() {
              return PatchFlagNames
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'babelParserDefaultPlugins',
            function() {
              return babelParserDefaultPlugins
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'camelize',
            function() {
              return camelize
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'capitalize',
            function() {
              return capitalize
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'def',
            function() {
              return def
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'escapeHtml',
            function() {
              return escapeHtml
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'escapeHtmlComment',
            function() {
              return escapeHtmlComment
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'extend',
            function() {
              return extend
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'generateCodeFrame',
            function() {
              return generateCodeFrame
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'getGlobalThis',
            function() {
              return getGlobalThis
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'hasChanged',
            function() {
              return hasChanged
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'hasOwn',
            function() {
              return hasOwn
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'hyphenate',
            function() {
              return hyphenate
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'invokeArrayFns',
            function() {
              return invokeArrayFns
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isArray',
            function() {
              return isArray
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isBooleanAttr',
            function() {
              return isBooleanAttr
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isDate',
            function() {
              return isDate
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isFunction',
            function() {
              return isFunction
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isGloballyWhitelisted',
            function() {
              return isGloballyWhitelisted
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isHTMLTag',
            function() {
              return isHTMLTag
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isIntegerKey',
            function() {
              return isIntegerKey
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isKnownAttr',
            function() {
              return isKnownAttr
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isMap',
            function() {
              return isMap
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isModelListener',
            function() {
              return isModelListener
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isNoUnitNumericStyleProp',
            function() {
              return isNoUnitNumericStyleProp
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isObject',
            function() {
              return isObject
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isOn',
            function() {
              return isOn
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isPlainObject',
            function() {
              return isPlainObject
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isPromise',
            function() {
              return isPromise
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isReservedProp',
            function() {
              return isReservedProp
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isSSRSafeAttrName',
            function() {
              return isSSRSafeAttrName
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isSVGTag',
            function() {
              return isSVGTag
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isSet',
            function() {
              return isSet
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isSpecialBooleanAttr',
            function() {
              return isSpecialBooleanAttr
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isString',
            function() {
              return isString
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isSymbol',
            function() {
              return isSymbol
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'isVoidTag',
            function() {
              return isVoidTag
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'looseEqual',
            function() {
              return looseEqual
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'looseIndexOf',
            function() {
              return looseIndexOf
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'makeMap',
            function() {
              return makeMap
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'normalizeClass',
            function() {
              return normalizeClass
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'normalizeStyle',
            function() {
              return normalizeStyle
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'objectToString',
            function() {
              return objectToString
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'parseStringStyle',
            function() {
              return parseStringStyle
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'propsToAttrMap',
            function() {
              return propsToAttrMap
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'remove',
            function() {
              return remove
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'slotFlagsText',
            function() {
              return slotFlagsText
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'stringifyStyle',
            function() {
              return stringifyStyle
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toDisplayString',
            function() {
              return toDisplayString
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toHandlerKey',
            function() {
              return toHandlerKey
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toNumber',
            function() {
              return toNumber
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toRawType',
            function() {
              return toRawType
            }
          )
          /* harmony export (binding) */ __webpack_require__.d(
            __webpack_exports__,
            'toTypeString',
            function() {
              return toTypeString
            }
          )
          /**
           * Make a map and return a function for checking if a key
           * is in that map.
           * IMPORTANT: all calls of this function must be prefixed with
           * \/\*#\_\_PURE\_\_\*\/
           * So that rollup can tree-shake them if necessary.
           */
          function makeMap(str, expectsLowerCase) {
            const map = Object.create(null)
            const list = str.split(',')
            for (let i = 0; i < list.length; i++) {
              map[list[i]] = true
            }
            return expectsLowerCase
              ? val => !!map[val.toLowerCase()]
              : val => !!map[val]
          }

          /**
           * dev only flag -> name mapping
           */
          const PatchFlagNames = {
            [1 /* TEXT */]: `TEXT`,
            [2 /* CLASS */]: `CLASS`,
            [4 /* STYLE */]: `STYLE`,
            [8 /* PROPS */]: `PROPS`,
            [16 /* FULL_PROPS */]: `FULL_PROPS`,
            [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
            [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
            [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
            [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
            [512 /* NEED_PATCH */]: `NEED_PATCH`,
            [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
            [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
            [-1 /* HOISTED */]: `HOISTED`,
            [-2 /* BAIL */]: `BAIL`
          }

          /**
           * Dev only
           */
          const slotFlagsText = {
            [1 /* STABLE */]: 'STABLE',
            [2 /* DYNAMIC */]: 'DYNAMIC',
            [3 /* FORWARDED */]: 'FORWARDED'
          }

          const GLOBALS_WHITE_LISTED =
            'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
            'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
            'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'
          const isGloballyWhitelisted = /*#__PURE__*/ makeMap(
            GLOBALS_WHITE_LISTED
          )

          const range = 2
          function generateCodeFrame(source, start = 0, end = source.length) {
            const lines = source.split(/\r?\n/)
            let count = 0
            const res = []
            for (let i = 0; i < lines.length; i++) {
              count += lines[i].length + 1
              if (count >= start) {
                for (let j = i - range; j <= i + range || end > count; j++) {
                  if (j < 0 || j >= lines.length) continue
                  const line = j + 1
                  res.push(
                    `${line}${' '.repeat(
                      Math.max(3 - String(line).length, 0)
                    )}|  ${lines[j]}`
                  )
                  const lineLength = lines[j].length
                  if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1
                    const length = Math.max(
                      1,
                      end > count ? lineLength - pad : end - start
                    )
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))
                  } else if (j > i) {
                    if (end > count) {
                      const length = Math.max(
                        Math.min(end - count, lineLength),
                        1
                      )
                      res.push(`   |  ` + '^'.repeat(length))
                    }
                    count += lineLength + 1
                  }
                }
                break
              }
            }
            return res.join('\n')
          }

          /**
           * On the client we only need to offer special cases for boolean attributes that
           * have different names from their corresponding dom properties:
           * - itemscope -> N/A
           * - allowfullscreen -> allowFullscreen
           * - formnovalidate -> formNoValidate
           * - ismap -> isMap
           * - nomodule -> noModule
           * - novalidate -> noValidate
           * - readonly -> readOnly
           */
          const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`
          const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(
            specialBooleanAttrs
          )
          /**
           * The full list is needed during SSR to produce the correct initial markup.
           */
          const isBooleanAttr = /*#__PURE__*/ makeMap(
            specialBooleanAttrs +
              `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
              `loop,open,required,reversed,scoped,seamless,` +
              `checked,muted,multiple,selected`
          )
          const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/
          const attrValidationCache = {}
          function isSSRSafeAttrName(name) {
            if (attrValidationCache.hasOwnProperty(name)) {
              return attrValidationCache[name]
            }
            const isUnsafe = unsafeAttrCharRE.test(name)
            if (isUnsafe) {
              console.error(`unsafe attribute name: ${name}`)
            }
            return (attrValidationCache[name] = !isUnsafe)
          }
          const propsToAttrMap = {
            acceptCharset: 'accept-charset',
            className: 'class',
            htmlFor: 'for',
            httpEquiv: 'http-equiv'
          }
          /**
           * CSS properties that accept plain numbers
           */
          const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(
            `animation-iteration-count,border-image-outset,border-image-slice,` +
              `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
              `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
              `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
              `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
              `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
              // SVG
              `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
              `stroke-miterlimit,stroke-opacity,stroke-width`
          )
          /**
           * Known attributes, this is used for stringification of runtime static nodes
           * so that we don't stringify bindings that cannot be set from HTML.
           * Don't also forget to allow `data-*` and `aria-*`!
           * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
           */
          const isKnownAttr = /*#__PURE__*/ makeMap(
            `accept,accept-charset,accesskey,action,align,allow,alt,async,` +
              `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
              `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
              `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
              `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
              `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
              `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
              `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
              `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
              `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
              `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
              `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
              `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
              `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
              `value,width,wrap`
          )

          function normalizeStyle(value) {
            if (isArray(value)) {
              const res = {}
              for (let i = 0; i < value.length; i++) {
                const item = value[i]
                const normalized = normalizeStyle(
                  isString(item) ? parseStringStyle(item) : item
                )
                if (normalized) {
                  for (const key in normalized) {
                    res[key] = normalized[key]
                  }
                }
              }
              return res
            } else if (isObject(value)) {
              return value
            }
          }
          const listDelimiterRE = /;(?![^(]*\))/g
          const propertyDelimiterRE = /:(.+)/
          function parseStringStyle(cssText) {
            const ret = {}
            cssText.split(listDelimiterRE).forEach(item => {
              if (item) {
                const tmp = item.split(propertyDelimiterRE)
                tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())
              }
            })
            return ret
          }
          function stringifyStyle(styles) {
            let ret = ''
            if (!styles) {
              return ret
            }
            for (const key in styles) {
              const value = styles[key]
              const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)
              if (
                isString(value) ||
                (typeof value === 'number' &&
                  isNoUnitNumericStyleProp(normalizedKey))
              ) {
                // only render valid values
                ret += `${normalizedKey}:${value};`
              }
            }
            return ret
          }
          function normalizeClass(value) {
            let res = ''
            if (isString(value)) {
              res = value
            } else if (isArray(value)) {
              for (let i = 0; i < value.length; i++) {
                const normalized = normalizeClass(value[i])
                if (normalized) {
                  res += normalized + ' '
                }
              }
            } else if (isObject(value)) {
              for (const name in value) {
                if (value[name]) {
                  res += name + ' '
                }
              }
            }
            return res.trim()
          }

          // These tag configs are shared between compiler-dom and runtime-dom, so they
          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
          const HTML_TAGS =
            'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
            'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
            'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
            'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
            'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
            'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
            'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
            'option,output,progress,select,textarea,details,dialog,menu,' +
            'summary,template,blockquote,iframe,tfoot'
          // https://developer.mozilla.org/en-US/docs/Web/SVG/Element
          const SVG_TAGS =
            'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
            'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
            'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
            'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
            'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
            'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
            'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
            'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
            'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
            'text,textPath,title,tspan,unknown,use,view'
          const VOID_TAGS =
            'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'
          const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)
          const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)
          const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)

          const escapeRE = /["'&<>]/
          function escapeHtml(string) {
            const str = '' + string
            const match = escapeRE.exec(str)
            if (!match) {
              return str
            }
            let html = ''
            let escaped
            let index
            let lastIndex = 0
            for (index = match.index; index < str.length; index++) {
              switch (str.charCodeAt(index)) {
                case 34: // "
                  escaped = '&quot;'
                  break
                case 38: // &
                  escaped = '&amp;'
                  break
                case 39: // '
                  escaped = '&#39;'
                  break
                case 60: // <
                  escaped = '&lt;'
                  break
                case 62: // >
                  escaped = '&gt;'
                  break
                default:
                  continue
              }
              if (lastIndex !== index) {
                html += str.substring(lastIndex, index)
              }
              lastIndex = index + 1
              html += escaped
            }
            return lastIndex !== index
              ? html + str.substring(lastIndex, index)
              : html
          }
          // https://www.w3.org/TR/html52/syntax.html#comments
          const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g
          function escapeHtmlComment(src) {
            return src.replace(commentStripRE, '')
          }

          function looseCompareArrays(a, b) {
            if (a.length !== b.length) return false
            let equal = true
            for (let i = 0; equal && i < a.length; i++) {
              equal = looseEqual(a[i], b[i])
            }
            return equal
          }
          function looseEqual(a, b) {
            if (a === b) return true
            let aValidType = isDate(a)
            let bValidType = isDate(b)
            if (aValidType || bValidType) {
              return aValidType && bValidType
                ? a.getTime() === b.getTime()
                : false
            }
            aValidType = isArray(a)
            bValidType = isArray(b)
            if (aValidType || bValidType) {
              return aValidType && bValidType ? looseCompareArrays(a, b) : false
            }
            aValidType = isObject(a)
            bValidType = isObject(b)
            if (aValidType || bValidType) {
              /* istanbul ignore if: this if will probably never be called */
              if (!aValidType || !bValidType) {
                return false
              }
              const aKeysCount = Object.keys(a).length
              const bKeysCount = Object.keys(b).length
              if (aKeysCount !== bKeysCount) {
                return false
              }
              for (const key in a) {
                const aHasKey = a.hasOwnProperty(key)
                const bHasKey = b.hasOwnProperty(key)
                if (
                  (aHasKey && !bHasKey) ||
                  (!aHasKey && bHasKey) ||
                  !looseEqual(a[key], b[key])
                ) {
                  return false
                }
              }
            }
            return String(a) === String(b)
          }
          function looseIndexOf(arr, val) {
            return arr.findIndex(item => looseEqual(item, val))
          }

          /**
           * For converting {{ interpolation }} values to displayed strings.
           * @private
           */
          const toDisplayString = val => {
            return val == null
              ? ''
              : isObject(val)
                ? JSON.stringify(val, replacer, 2)
                : String(val)
          }
          const replacer = (_key, val) => {
            if (isMap(val)) {
              return {
                [`Map(${val.size})`]: [...val.entries()].reduce(
                  (entries, [key, val]) => {
                    entries[`${key} =>`] = val
                    return entries
                  },
                  {}
                )
              }
            } else if (isSet(val)) {
              return {
                [`Set(${val.size})`]: [...val.values()]
              }
            } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
              return String(val)
            }
            return val
          }

          /**
           * List of @babel/parser plugins that are used for template expression
           * transforms and SFC script transforms. By default we enable proposals slated
           * for ES2020. This will need to be updated as the spec moves forward.
           * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins
           */
          const babelParserDefaultPlugins = [
            'bigInt',
            'optionalChaining',
            'nullishCoalescingOperator'
          ]
          const EMPTY_OBJ = true ? Object.freeze({}) : undefined
          const EMPTY_ARR = true ? Object.freeze([]) : undefined
          const NOOP = () => {}
          /**
           * Always return false.
           */
          const NO = () => false
          const onRE = /^on[^a-z]/
          const isOn = key => onRE.test(key)
          const isModelListener = key => key.startsWith('onUpdate:')
          const extend = Object.assign
          const remove = (arr, el) => {
            const i = arr.indexOf(el)
            if (i > -1) {
              arr.splice(i, 1)
            }
          }
          const hasOwnProperty = Object.prototype.hasOwnProperty
          const hasOwn = (val, key) => hasOwnProperty.call(val, key)
          const isArray = Array.isArray
          const isMap = val => toTypeString(val) === '[object Map]'
          const isSet = val => toTypeString(val) === '[object Set]'
          const isDate = val => val instanceof Date
          const isFunction = val => typeof val === 'function'
          const isString = val => typeof val === 'string'
          const isSymbol = val => typeof val === 'symbol'
          const isObject = val => val !== null && typeof val === 'object'
          const isPromise = val => {
            return (
              isObject(val) && isFunction(val.then) && isFunction(val.catch)
            )
          }
          const objectToString = Object.prototype.toString
          const toTypeString = value => objectToString.call(value)
          const toRawType = value => {
            // extract "RawType" from strings like "[object RawType]"
            return toTypeString(value).slice(8, -1)
          }
          const isPlainObject = val => toTypeString(val) === '[object Object]'
          const isIntegerKey = key =>
            isString(key) &&
            key !== 'NaN' &&
            key[0] !== '-' &&
            '' + parseInt(key, 10) === key
          const isReservedProp = /*#__PURE__*/ makeMap(
            // the leading comma is intentional so empty string "" is also included
            ',key,ref,' +
              'onVnodeBeforeMount,onVnodeMounted,' +
              'onVnodeBeforeUpdate,onVnodeUpdated,' +
              'onVnodeBeforeUnmount,onVnodeUnmounted'
          )
          const cacheStringFunction = fn => {
            const cache = Object.create(null)
            return str => {
              const hit = cache[str]
              return hit || (cache[str] = fn(str))
            }
          }
          const camelizeRE = /-(\w)/g
          /**
           * @private
           */
          const camelize = cacheStringFunction(str => {
            return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))
          })
          const hyphenateRE = /\B([A-Z])/g
          /**
           * @private
           */
          const hyphenate = cacheStringFunction(str =>
            str.replace(hyphenateRE, '-$1').toLowerCase()
          )
          /**
           * @private
           */
          const capitalize = cacheStringFunction(
            str => str.charAt(0).toUpperCase() + str.slice(1)
          )
          /**
           * @private
           */
          const toHandlerKey = cacheStringFunction(
            str => (str ? `on${capitalize(str)}` : ``)
          )
          // compare whether a value has changed, accounting for NaN.
          const hasChanged = (value, oldValue) =>
            value !== oldValue && (value === value || oldValue === oldValue)
          const invokeArrayFns = (fns, arg) => {
            for (let i = 0; i < fns.length; i++) {
              fns[i](arg)
            }
          }
          const def = (obj, key, value) => {
            Object.defineProperty(obj, key, {
              configurable: true,
              enumerable: false,
              value
            })
          }
          const toNumber = val => {
            const n = parseFloat(val)
            return isNaN(n) ? val : n
          }
          let _globalThis
          const getGlobalThis = () => {
            return (
              _globalThis ||
              (_globalThis =
                typeof globalThis !== 'undefined'
                  ? globalThis
                  : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                      ? window
                      : typeof global !== 'undefined'
                        ? global
                        : {})
            )
          }

          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../../_webpack@4.46.0@webpack/buildin/global.js */ './node_modules/_webpack@4.46.0@webpack/buildin/global.js'
          )
        ))

        /***/
      },

    /***/ './node_modules/_ansi-html@0.0.7@ansi-html/index.js':
      /*!**********************************************************!*\
  !*** ./node_modules/_ansi-html@0.0.7@ansi-html/index.js ***!
  \**********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        module.exports = ansiHTML

        // Reference to https://github.com/sindresorhus/ansi-regex
        var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

        var _defColors = {
          reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
          black: '000',
          red: 'ff0000',
          green: '209805',
          yellow: 'e8bf03',
          blue: '0000ff',
          magenta: 'ff00ff',
          cyan: '00ffee',
          lightgrey: 'f0f0f0',
          darkgrey: '888'
        }
        var _styles = {
          30: 'black',
          31: 'red',
          32: 'green',
          33: 'yellow',
          34: 'blue',
          35: 'magenta',
          36: 'cyan',
          37: 'lightgrey'
        }
        var _openTags = {
          '1': 'font-weight:bold', // bold
          '2': 'opacity:0.5', // dim
          '3': '<i>', // italic
          '4': '<u>', // underscore
          '8': 'display:none', // hidden
          '9': '<del>' // delete
        }
        var _closeTags = {
          '23': '</i>', // reset italic
          '24': '</u>', // reset underscore
          '29': '</del>' // reset delete
        }
        ;[0, 21, 22, 27, 28, 39, 49].forEach(function(n) {
          _closeTags[n] = '</span>'
        })

        /**
         * Converts text with ANSI color codes to HTML markup.
         * @param {String} text
         * @returns {*}
         */
        function ansiHTML(text) {
          // Returns the text if the string has no ANSI escape code.
          if (!_regANSI.test(text)) {
            return text
          }

          // Cache opened sequence.
          var ansiCodes = []
          // Replace with markup.
          var ret = text.replace(/\033\[(\d+)*m/g, function(match, seq) {
            var ot = _openTags[seq]
            if (ot) {
              // If current sequence has been opened, close it.
              if (!!~ansiCodes.indexOf(seq)) {
                // eslint-disable-line no-extra-boolean-cast
                ansiCodes.pop()
                return '</span>'
              }
              // Open tag.
              ansiCodes.push(seq)
              return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
            }

            var ct = _closeTags[seq]
            if (ct) {
              // Pop sequence
              ansiCodes.pop()
              return ct
            }
            return ''
          })

          // Make sure tags are closed.
          var l = ansiCodes.length
          l > 0 && (ret += Array(l + 1).join('</span>'))

          return ret
        }

        /**
         * Customize colors.
         * @param {Object} colors reference to _defColors
         */
        ansiHTML.setColors = function(colors) {
          if (typeof colors !== 'object') {
            throw new Error('`colors` parameter must be an Object.')
          }

          var _finalColors = {}
          for (var key in _defColors) {
            var hex = colors.hasOwnProperty(key) ? colors[key] : null
            if (!hex) {
              _finalColors[key] = _defColors[key]
              continue
            }
            if ('reset' === key) {
              if (typeof hex === 'string') {
                hex = [hex]
              }
              if (
                !Array.isArray(hex) ||
                hex.length === 0 ||
                hex.some(function(h) {
                  return typeof h !== 'string'
                })
              ) {
                throw new Error(
                  'The value of `' +
                    key +
                    '` property must be an Array and each item could only be a hex string, e.g.: FF0000'
                )
              }
              var defHexColor = _defColors[key]
              if (!hex[0]) {
                hex[0] = defHexColor[0]
              }
              if (hex.length === 1 || !hex[1]) {
                hex = [hex[0]]
                hex.push(defHexColor[1])
              }

              hex = hex.slice(0, 2)
            } else if (typeof hex !== 'string') {
              throw new Error(
                'The value of `' +
                  key +
                  '` property must be a hex string, e.g.: FF0000'
              )
            }
            _finalColors[key] = hex
          }
          _setTags(_finalColors)
        }

        /**
         * Reset colors.
         */
        ansiHTML.reset = function() {
          _setTags(_defColors)
        }

        /**
         * Expose tags, including open and close.
         * @type {Object}
         */
        ansiHTML.tags = {}

        if (Object.defineProperty) {
          Object.defineProperty(ansiHTML.tags, 'open', {
            get: function() {
              return _openTags
            }
          })
          Object.defineProperty(ansiHTML.tags, 'close', {
            get: function() {
              return _closeTags
            }
          })
        } else {
          ansiHTML.tags.open = _openTags
          ansiHTML.tags.close = _closeTags
        }

        function _setTags(colors) {
          // reset all
          _openTags['0'] =
            'font-weight:normal;opacity:1;color:#' +
            colors.reset[0] +
            ';background:#' +
            colors.reset[1]
          // inverse
          _openTags['7'] =
            'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
          // dark grey
          _openTags['90'] = 'color:#' + colors.darkgrey

          for (var code in _styles) {
            var color = _styles[code]
            var oriColor = colors[color] || '000'
            _openTags[code] = 'color:#' + oriColor
            code = parseInt(code)
            _openTags[(code + 10).toString()] = 'background:#' + oriColor
          }
        }

        ansiHTML.reset()

        /***/
      },

    /***/ './node_modules/_ansi-regex@2.1.1@ansi-regex/index.js':
      /*!************************************************************!*\
  !*** ./node_modules/_ansi-regex@2.1.1@ansi-regex/index.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        module.exports = function() {
          return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g
        }

        /***/
      },

    /***/ './node_modules/_events@3.3.0@events/events.js':
      /*!*****************************************************!*\
  !*** ./node_modules/_events@3.3.0@events/events.js ***!
  \*****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var R = typeof Reflect === 'object' ? Reflect : null
        var ReflectApply =
          R && typeof R.apply === 'function'
            ? R.apply
            : function ReflectApply(target, receiver, args) {
                return Function.prototype.apply.call(target, receiver, args)
              }

        var ReflectOwnKeys
        if (R && typeof R.ownKeys === 'function') {
          ReflectOwnKeys = R.ownKeys
        } else if (Object.getOwnPropertySymbols) {
          ReflectOwnKeys = function ReflectOwnKeys(target) {
            return Object.getOwnPropertyNames(target).concat(
              Object.getOwnPropertySymbols(target)
            )
          }
        } else {
          ReflectOwnKeys = function ReflectOwnKeys(target) {
            return Object.getOwnPropertyNames(target)
          }
        }

        function ProcessEmitWarning(warning) {
          if (console && console.warn) console.warn(warning)
        }

        var NumberIsNaN =
          Number.isNaN ||
          function NumberIsNaN(value) {
            return value !== value
          }

        function EventEmitter() {
          EventEmitter.init.call(this)
        }
        module.exports = EventEmitter
        module.exports.once = once

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter

        EventEmitter.prototype._events = undefined
        EventEmitter.prototype._eventsCount = 0
        EventEmitter.prototype._maxListeners = undefined

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10

        function checkListener(listener) {
          if (typeof listener !== 'function') {
            throw new TypeError(
              'The "listener" argument must be of type Function. Received type ' +
                typeof listener
            )
          }
        }

        Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
          enumerable: true,
          get: function() {
            return defaultMaxListeners
          },
          set: function(arg) {
            if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
              throw new RangeError(
                'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                  arg +
                  '.'
              )
            }
            defaultMaxListeners = arg
          }
        })

        EventEmitter.init = function() {
          if (
            this._events === undefined ||
            this._events === Object.getPrototypeOf(this)._events
          ) {
            this._events = Object.create(null)
            this._eventsCount = 0
          }

          this._maxListeners = this._maxListeners || undefined
        }

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
            throw new RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' +
                n +
                '.'
            )
          }
          this._maxListeners = n
          return this
        }

        function _getMaxListeners(that) {
          if (that._maxListeners === undefined)
            return EventEmitter.defaultMaxListeners
          return that._maxListeners
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this)
        }

        EventEmitter.prototype.emit = function emit(type) {
          var args = []
          for (var i = 1; i < arguments.length; i++) args.push(arguments[i])
          var doError = type === 'error'

          var events = this._events
          if (events !== undefined)
            doError = doError && events.error === undefined
          else if (!doError) return false

          // If there is no 'error' event listener then throw.
          if (doError) {
            var er
            if (args.length > 0) er = args[0]
            if (er instanceof Error) {
              // Note: The comments on the `throw` lines are intentional, they show
              // up in Node's output if this results in an unhandled exception.
              throw er // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            var err = new Error(
              'Unhandled error.' + (er ? ' (' + er.message + ')' : '')
            )
            err.context = er
            throw err // Unhandled 'error' event
          }

          var handler = events[type]

          if (handler === undefined) return false

          if (typeof handler === 'function') {
            ReflectApply(handler, this, args)
          } else {
            var len = handler.length
            var listeners = arrayClone(handler, len)
            for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args)
          }

          return true
        }

        function _addListener(target, type, listener, prepend) {
          var m
          var events
          var existing

          checkListener(listener)

          events = target._events
          if (events === undefined) {
            events = target._events = Object.create(null)
            target._eventsCount = 0
          } else {
            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (events.newListener !== undefined) {
              target.emit(
                'newListener',
                type,
                listener.listener ? listener.listener : listener
              )

              // Re-assign `events` because a newListener handler could have caused the
              // this._events to be assigned to a new object
              events = target._events
            }
            existing = events[type]
          }

          if (existing === undefined) {
            // Optimize the case of one listener. Don't need the extra array object.
            existing = events[type] = listener
            ++target._eventsCount
          } else {
            if (typeof existing === 'function') {
              // Adding the second element, need to change to array.
              existing = events[type] = prepend
                ? [listener, existing]
                : [existing, listener]
              // If we've already got an array, just append.
            } else if (prepend) {
              existing.unshift(listener)
            } else {
              existing.push(listener)
            }

            // Check for listener leak
            m = _getMaxListeners(target)
            if (m > 0 && existing.length > m && !existing.warned) {
              existing.warned = true
              // No error code for this since it is a Warning
              // eslint-disable-next-line no-restricted-syntax
              var w = new Error(
                'Possible EventEmitter memory leak detected. ' +
                  existing.length +
                  ' ' +
                  String(type) +
                  ' listeners ' +
                  'added. Use emitter.setMaxListeners() to ' +
                  'increase limit'
              )
              w.name = 'MaxListenersExceededWarning'
              w.emitter = target
              w.type = type
              w.count = existing.length
              ProcessEmitWarning(w)
            }
          }

          return target
        }

        EventEmitter.prototype.addListener = function addListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, false)
        }

        EventEmitter.prototype.on = EventEmitter.prototype.addListener

        EventEmitter.prototype.prependListener = function prependListener(
          type,
          listener
        ) {
          return _addListener(this, type, listener, true)
        }

        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn)
            this.fired = true
            if (arguments.length === 0) return this.listener.call(this.target)
            return this.listener.apply(this.target, arguments)
          }
        }

        function _onceWrap(target, type, listener) {
          var state = {
            fired: false,
            wrapFn: undefined,
            target: target,
            type: type,
            listener: listener
          }
          var wrapped = onceWrapper.bind(state)
          wrapped.listener = listener
          state.wrapFn = wrapped
          return wrapped
        }

        EventEmitter.prototype.once = function once(type, listener) {
          checkListener(listener)
          this.on(type, _onceWrap(this, type, listener))
          return this
        }

        EventEmitter.prototype.prependOnceListener = function prependOnceListener(
          type,
          listener
        ) {
          checkListener(listener)
          this.prependListener(type, _onceWrap(this, type, listener))
          return this
        }

        // Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener = function removeListener(
          type,
          listener
        ) {
          var list, events, position, i, originalListener

          checkListener(listener)

          events = this._events
          if (events === undefined) return this

          list = events[type]
          if (list === undefined) return this

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0) this._events = Object.create(null)
            else {
              delete events[type]
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener)
            }
          } else if (typeof list !== 'function') {
            position = -1

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener
                position = i
                break
              }
            }

            if (position < 0) return this

            if (position === 0) list.shift()
            else {
              spliceOne(list, position)
            }

            if (list.length === 1) events[type] = list[0]

            if (events.removeListener !== undefined)
              this.emit('removeListener', type, originalListener || listener)
          }

          return this
        }

        EventEmitter.prototype.off = EventEmitter.prototype.removeListener

        EventEmitter.prototype.removeAllListeners = function removeAllListeners(
          type
        ) {
          var listeners, events, i

          events = this._events
          if (events === undefined) return this

          // not listening for removeListener, no need to emit
          if (events.removeListener === undefined) {
            if (arguments.length === 0) {
              this._events = Object.create(null)
              this._eventsCount = 0
            } else if (events[type] !== undefined) {
              if (--this._eventsCount === 0) this._events = Object.create(null)
              else delete events[type]
            }
            return this
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events)
            var key
            for (i = 0; i < keys.length; ++i) {
              key = keys[i]
              if (key === 'removeListener') continue
              this.removeAllListeners(key)
            }
            this.removeAllListeners('removeListener')
            this._events = Object.create(null)
            this._eventsCount = 0
            return this
          }

          listeners = events[type]

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners)
          } else if (listeners !== undefined) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i])
            }
          }

          return this
        }

        function _listeners(target, type, unwrap) {
          var events = target._events

          if (events === undefined) return []

          var evlistener = events[type]
          if (evlistener === undefined) return []

          if (typeof evlistener === 'function')
            return unwrap ? [evlistener.listener || evlistener] : [evlistener]

          return unwrap
            ? unwrapListeners(evlistener)
            : arrayClone(evlistener, evlistener.length)
        }

        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true)
        }

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false)
        }

        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === 'function') {
            return emitter.listenerCount(type)
          } else {
            return listenerCount.call(emitter, type)
          }
        }

        EventEmitter.prototype.listenerCount = listenerCount
        function listenerCount(type) {
          var events = this._events

          if (events !== undefined) {
            var evlistener = events[type]

            if (typeof evlistener === 'function') {
              return 1
            } else if (evlistener !== undefined) {
              return evlistener.length
            }
          }

          return 0
        }

        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
        }

        function arrayClone(arr, n) {
          var copy = new Array(n)
          for (var i = 0; i < n; ++i) copy[i] = arr[i]
          return copy
        }

        function spliceOne(list, index) {
          for (; index + 1 < list.length; index++) list[index] = list[index + 1]
          list.pop()
        }

        function unwrapListeners(arr) {
          var ret = new Array(arr.length)
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i]
          }
          return ret
        }

        function once(emitter, name) {
          return new Promise(function(resolve, reject) {
            function errorListener(err) {
              emitter.removeListener(name, resolver)
              reject(err)
            }

            function resolver() {
              if (typeof emitter.removeListener === 'function') {
                emitter.removeListener('error', errorListener)
              }
              resolve([].slice.call(arguments))
            }

            eventTargetAgnosticAddListener(emitter, name, resolver, {
              once: true
            })
            if (name !== 'error') {
              addErrorHandlerIfEventEmitter(emitter, errorListener, {
                once: true
              })
            }
          })
        }

        function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
          if (typeof emitter.on === 'function') {
            eventTargetAgnosticAddListener(emitter, 'error', handler, flags)
          }
        }

        function eventTargetAgnosticAddListener(
          emitter,
          name,
          listener,
          flags
        ) {
          if (typeof emitter.on === 'function') {
            if (flags.once) {
              emitter.once(name, listener)
            } else {
              emitter.on(name, listener)
            }
          } else if (typeof emitter.addEventListener === 'function') {
            // EventTarget does not have `error` event semantics like Node
            // EventEmitters, we do not listen for `error` events here.
            emitter.addEventListener(name, function wrapListener(arg) {
              // IE does not have builtin `{ once: true }` support so we
              // have to do it manually.
              if (flags.once) {
                emitter.removeEventListener(name, wrapListener)
              }
              listener(arg)
            })
          } else {
            throw new TypeError(
              'The "emitter" argument must be of type EventEmitter. Received type ' +
                typeof emitter
            )
          }
        }

        /***/
      },

    /***/ './node_modules/_html-entities@1.4.0@html-entities/lib/html4-entities.js':
      /*!*******************************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/html4-entities.js ***!
  \*******************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        Object.defineProperty(exports, '__esModule', { value: true })
        var surrogate_pairs_1 = __webpack_require__(
          /*! ./surrogate-pairs */ './node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js'
        )
        var HTML_ALPHA = [
          'apos',
          'nbsp',
          'iexcl',
          'cent',
          'pound',
          'curren',
          'yen',
          'brvbar',
          'sect',
          'uml',
          'copy',
          'ordf',
          'laquo',
          'not',
          'shy',
          'reg',
          'macr',
          'deg',
          'plusmn',
          'sup2',
          'sup3',
          'acute',
          'micro',
          'para',
          'middot',
          'cedil',
          'sup1',
          'ordm',
          'raquo',
          'frac14',
          'frac12',
          'frac34',
          'iquest',
          'Agrave',
          'Aacute',
          'Acirc',
          'Atilde',
          'Auml',
          'Aring',
          'AElig',
          'Ccedil',
          'Egrave',
          'Eacute',
          'Ecirc',
          'Euml',
          'Igrave',
          'Iacute',
          'Icirc',
          'Iuml',
          'ETH',
          'Ntilde',
          'Ograve',
          'Oacute',
          'Ocirc',
          'Otilde',
          'Ouml',
          'times',
          'Oslash',
          'Ugrave',
          'Uacute',
          'Ucirc',
          'Uuml',
          'Yacute',
          'THORN',
          'szlig',
          'agrave',
          'aacute',
          'acirc',
          'atilde',
          'auml',
          'aring',
          'aelig',
          'ccedil',
          'egrave',
          'eacute',
          'ecirc',
          'euml',
          'igrave',
          'iacute',
          'icirc',
          'iuml',
          'eth',
          'ntilde',
          'ograve',
          'oacute',
          'ocirc',
          'otilde',
          'ouml',
          'divide',
          'oslash',
          'ugrave',
          'uacute',
          'ucirc',
          'uuml',
          'yacute',
          'thorn',
          'yuml',
          'quot',
          'amp',
          'lt',
          'gt',
          'OElig',
          'oelig',
          'Scaron',
          'scaron',
          'Yuml',
          'circ',
          'tilde',
          'ensp',
          'emsp',
          'thinsp',
          'zwnj',
          'zwj',
          'lrm',
          'rlm',
          'ndash',
          'mdash',
          'lsquo',
          'rsquo',
          'sbquo',
          'ldquo',
          'rdquo',
          'bdquo',
          'dagger',
          'Dagger',
          'permil',
          'lsaquo',
          'rsaquo',
          'euro',
          'fnof',
          'Alpha',
          'Beta',
          'Gamma',
          'Delta',
          'Epsilon',
          'Zeta',
          'Eta',
          'Theta',
          'Iota',
          'Kappa',
          'Lambda',
          'Mu',
          'Nu',
          'Xi',
          'Omicron',
          'Pi',
          'Rho',
          'Sigma',
          'Tau',
          'Upsilon',
          'Phi',
          'Chi',
          'Psi',
          'Omega',
          'alpha',
          'beta',
          'gamma',
          'delta',
          'epsilon',
          'zeta',
          'eta',
          'theta',
          'iota',
          'kappa',
          'lambda',
          'mu',
          'nu',
          'xi',
          'omicron',
          'pi',
          'rho',
          'sigmaf',
          'sigma',
          'tau',
          'upsilon',
          'phi',
          'chi',
          'psi',
          'omega',
          'thetasym',
          'upsih',
          'piv',
          'bull',
          'hellip',
          'prime',
          'Prime',
          'oline',
          'frasl',
          'weierp',
          'image',
          'real',
          'trade',
          'alefsym',
          'larr',
          'uarr',
          'rarr',
          'darr',
          'harr',
          'crarr',
          'lArr',
          'uArr',
          'rArr',
          'dArr',
          'hArr',
          'forall',
          'part',
          'exist',
          'empty',
          'nabla',
          'isin',
          'notin',
          'ni',
          'prod',
          'sum',
          'minus',
          'lowast',
          'radic',
          'prop',
          'infin',
          'ang',
          'and',
          'or',
          'cap',
          'cup',
          'int',
          'there4',
          'sim',
          'cong',
          'asymp',
          'ne',
          'equiv',
          'le',
          'ge',
          'sub',
          'sup',
          'nsub',
          'sube',
          'supe',
          'oplus',
          'otimes',
          'perp',
          'sdot',
          'lceil',
          'rceil',
          'lfloor',
          'rfloor',
          'lang',
          'rang',
          'loz',
          'spades',
          'clubs',
          'hearts',
          'diams'
        ]
        var HTML_CODES = [
          39,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          174,
          175,
          176,
          177,
          178,
          179,
          180,
          181,
          182,
          183,
          184,
          185,
          186,
          187,
          188,
          189,
          190,
          191,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255,
          34,
          38,
          60,
          62,
          338,
          339,
          352,
          353,
          376,
          710,
          732,
          8194,
          8195,
          8201,
          8204,
          8205,
          8206,
          8207,
          8211,
          8212,
          8216,
          8217,
          8218,
          8220,
          8221,
          8222,
          8224,
          8225,
          8240,
          8249,
          8250,
          8364,
          402,
          913,
          914,
          915,
          916,
          917,
          918,
          919,
          920,
          921,
          922,
          923,
          924,
          925,
          926,
          927,
          928,
          929,
          931,
          932,
          933,
          934,
          935,
          936,
          937,
          945,
          946,
          947,
          948,
          949,
          950,
          951,
          952,
          953,
          954,
          955,
          956,
          957,
          958,
          959,
          960,
          961,
          962,
          963,
          964,
          965,
          966,
          967,
          968,
          969,
          977,
          978,
          982,
          8226,
          8230,
          8242,
          8243,
          8254,
          8260,
          8472,
          8465,
          8476,
          8482,
          8501,
          8592,
          8593,
          8594,
          8595,
          8596,
          8629,
          8656,
          8657,
          8658,
          8659,
          8660,
          8704,
          8706,
          8707,
          8709,
          8711,
          8712,
          8713,
          8715,
          8719,
          8721,
          8722,
          8727,
          8730,
          8733,
          8734,
          8736,
          8743,
          8744,
          8745,
          8746,
          8747,
          8756,
          8764,
          8773,
          8776,
          8800,
          8801,
          8804,
          8805,
          8834,
          8835,
          8836,
          8838,
          8839,
          8853,
          8855,
          8869,
          8901,
          8968,
          8969,
          8970,
          8971,
          9001,
          9002,
          9674,
          9824,
          9827,
          9829,
          9830
        ]
        var alphaIndex = {}
        var numIndex = {}
        ;(function() {
          var i = 0
          var length = HTML_ALPHA.length
          while (i < length) {
            var a = HTML_ALPHA[i]
            var c = HTML_CODES[i]
            alphaIndex[a] = String.fromCharCode(c)
            numIndex[c] = a
            i++
          }
        })()
        var Html4Entities = /** @class */ (function() {
          function Html4Entities() {}
          Html4Entities.prototype.decode = function(str) {
            if (!str || !str.length) {
              return ''
            }
            return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
              var chr
              if (entity.charAt(0) === '#') {
                var code =
                  entity.charAt(1).toLowerCase() === 'x'
                    ? parseInt(entity.substr(2), 16)
                    : parseInt(entity.substr(1))
                if (!isNaN(code) || code >= -32768) {
                  if (code <= 65535) {
                    chr = String.fromCharCode(code)
                  } else {
                    chr = surrogate_pairs_1.fromCodePoint(code)
                  }
                }
              } else {
                chr = alphaIndex[entity]
              }
              return chr || s
            })
          }
          Html4Entities.decode = function(str) {
            return new Html4Entities().decode(str)
          }
          Html4Entities.prototype.encode = function(str) {
            if (!str || !str.length) {
              return ''
            }
            var strLength = str.length
            var result = ''
            var i = 0
            while (i < strLength) {
              var alpha = numIndex[str.charCodeAt(i)]
              result += alpha ? '&' + alpha + ';' : str.charAt(i)
              i++
            }
            return result
          }
          Html4Entities.encode = function(str) {
            return new Html4Entities().encode(str)
          }
          Html4Entities.prototype.encodeNonUTF = function(str) {
            if (!str || !str.length) {
              return ''
            }
            var strLength = str.length
            var result = ''
            var i = 0
            while (i < strLength) {
              var cc = str.charCodeAt(i)
              var alpha = numIndex[cc]
              if (alpha) {
                result += '&' + alpha + ';'
              } else if (cc < 32 || cc > 126) {
                if (
                  cc >= surrogate_pairs_1.highSurrogateFrom &&
                  cc <= surrogate_pairs_1.highSurrogateTo
                ) {
                  result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';'
                  i++
                } else {
                  result += '&#' + cc + ';'
                }
              } else {
                result += str.charAt(i)
              }
              i++
            }
            return result
          }
          Html4Entities.encodeNonUTF = function(str) {
            return new Html4Entities().encodeNonUTF(str)
          }
          Html4Entities.prototype.encodeNonASCII = function(str) {
            if (!str || !str.length) {
              return ''
            }
            var strLength = str.length
            var result = ''
            var i = 0
            while (i < strLength) {
              var c = str.charCodeAt(i)
              if (c <= 255) {
                result += str[i++]
                continue
              }
              if (
                c >= surrogate_pairs_1.highSurrogateFrom &&
                c <= surrogate_pairs_1.highSurrogateTo
              ) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';'
                i++
              } else {
                result += '&#' + c + ';'
              }
              i++
            }
            return result
          }
          Html4Entities.encodeNonASCII = function(str) {
            return new Html4Entities().encodeNonASCII(str)
          }
          return Html4Entities
        })()
        exports.Html4Entities = Html4Entities

        /***/
      },

    /***/ './node_modules/_html-entities@1.4.0@html-entities/lib/html5-entities.js':
      /*!*******************************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/html5-entities.js ***!
  \*******************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        Object.defineProperty(exports, '__esModule', { value: true })
        var surrogate_pairs_1 = __webpack_require__(
          /*! ./surrogate-pairs */ './node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js'
        )
        var ENTITIES = [
          ['Aacute', [193]],
          ['aacute', [225]],
          ['Abreve', [258]],
          ['abreve', [259]],
          ['ac', [8766]],
          ['acd', [8767]],
          ['acE', [8766, 819]],
          ['Acirc', [194]],
          ['acirc', [226]],
          ['acute', [180]],
          ['Acy', [1040]],
          ['acy', [1072]],
          ['AElig', [198]],
          ['aelig', [230]],
          ['af', [8289]],
          ['Afr', [120068]],
          ['afr', [120094]],
          ['Agrave', [192]],
          ['agrave', [224]],
          ['alefsym', [8501]],
          ['aleph', [8501]],
          ['Alpha', [913]],
          ['alpha', [945]],
          ['Amacr', [256]],
          ['amacr', [257]],
          ['amalg', [10815]],
          ['amp', [38]],
          ['AMP', [38]],
          ['andand', [10837]],
          ['And', [10835]],
          ['and', [8743]],
          ['andd', [10844]],
          ['andslope', [10840]],
          ['andv', [10842]],
          ['ang', [8736]],
          ['ange', [10660]],
          ['angle', [8736]],
          ['angmsdaa', [10664]],
          ['angmsdab', [10665]],
          ['angmsdac', [10666]],
          ['angmsdad', [10667]],
          ['angmsdae', [10668]],
          ['angmsdaf', [10669]],
          ['angmsdag', [10670]],
          ['angmsdah', [10671]],
          ['angmsd', [8737]],
          ['angrt', [8735]],
          ['angrtvb', [8894]],
          ['angrtvbd', [10653]],
          ['angsph', [8738]],
          ['angst', [197]],
          ['angzarr', [9084]],
          ['Aogon', [260]],
          ['aogon', [261]],
          ['Aopf', [120120]],
          ['aopf', [120146]],
          ['apacir', [10863]],
          ['ap', [8776]],
          ['apE', [10864]],
          ['ape', [8778]],
          ['apid', [8779]],
          ['apos', [39]],
          ['ApplyFunction', [8289]],
          ['approx', [8776]],
          ['approxeq', [8778]],
          ['Aring', [197]],
          ['aring', [229]],
          ['Ascr', [119964]],
          ['ascr', [119990]],
          ['Assign', [8788]],
          ['ast', [42]],
          ['asymp', [8776]],
          ['asympeq', [8781]],
          ['Atilde', [195]],
          ['atilde', [227]],
          ['Auml', [196]],
          ['auml', [228]],
          ['awconint', [8755]],
          ['awint', [10769]],
          ['backcong', [8780]],
          ['backepsilon', [1014]],
          ['backprime', [8245]],
          ['backsim', [8765]],
          ['backsimeq', [8909]],
          ['Backslash', [8726]],
          ['Barv', [10983]],
          ['barvee', [8893]],
          ['barwed', [8965]],
          ['Barwed', [8966]],
          ['barwedge', [8965]],
          ['bbrk', [9141]],
          ['bbrktbrk', [9142]],
          ['bcong', [8780]],
          ['Bcy', [1041]],
          ['bcy', [1073]],
          ['bdquo', [8222]],
          ['becaus', [8757]],
          ['because', [8757]],
          ['Because', [8757]],
          ['bemptyv', [10672]],
          ['bepsi', [1014]],
          ['bernou', [8492]],
          ['Bernoullis', [8492]],
          ['Beta', [914]],
          ['beta', [946]],
          ['beth', [8502]],
          ['between', [8812]],
          ['Bfr', [120069]],
          ['bfr', [120095]],
          ['bigcap', [8898]],
          ['bigcirc', [9711]],
          ['bigcup', [8899]],
          ['bigodot', [10752]],
          ['bigoplus', [10753]],
          ['bigotimes', [10754]],
          ['bigsqcup', [10758]],
          ['bigstar', [9733]],
          ['bigtriangledown', [9661]],
          ['bigtriangleup', [9651]],
          ['biguplus', [10756]],
          ['bigvee', [8897]],
          ['bigwedge', [8896]],
          ['bkarow', [10509]],
          ['blacklozenge', [10731]],
          ['blacksquare', [9642]],
          ['blacktriangle', [9652]],
          ['blacktriangledown', [9662]],
          ['blacktriangleleft', [9666]],
          ['blacktriangleright', [9656]],
          ['blank', [9251]],
          ['blk12', [9618]],
          ['blk14', [9617]],
          ['blk34', [9619]],
          ['block', [9608]],
          ['bne', [61, 8421]],
          ['bnequiv', [8801, 8421]],
          ['bNot', [10989]],
          ['bnot', [8976]],
          ['Bopf', [120121]],
          ['bopf', [120147]],
          ['bot', [8869]],
          ['bottom', [8869]],
          ['bowtie', [8904]],
          ['boxbox', [10697]],
          ['boxdl', [9488]],
          ['boxdL', [9557]],
          ['boxDl', [9558]],
          ['boxDL', [9559]],
          ['boxdr', [9484]],
          ['boxdR', [9554]],
          ['boxDr', [9555]],
          ['boxDR', [9556]],
          ['boxh', [9472]],
          ['boxH', [9552]],
          ['boxhd', [9516]],
          ['boxHd', [9572]],
          ['boxhD', [9573]],
          ['boxHD', [9574]],
          ['boxhu', [9524]],
          ['boxHu', [9575]],
          ['boxhU', [9576]],
          ['boxHU', [9577]],
          ['boxminus', [8863]],
          ['boxplus', [8862]],
          ['boxtimes', [8864]],
          ['boxul', [9496]],
          ['boxuL', [9563]],
          ['boxUl', [9564]],
          ['boxUL', [9565]],
          ['boxur', [9492]],
          ['boxuR', [9560]],
          ['boxUr', [9561]],
          ['boxUR', [9562]],
          ['boxv', [9474]],
          ['boxV', [9553]],
          ['boxvh', [9532]],
          ['boxvH', [9578]],
          ['boxVh', [9579]],
          ['boxVH', [9580]],
          ['boxvl', [9508]],
          ['boxvL', [9569]],
          ['boxVl', [9570]],
          ['boxVL', [9571]],
          ['boxvr', [9500]],
          ['boxvR', [9566]],
          ['boxVr', [9567]],
          ['boxVR', [9568]],
          ['bprime', [8245]],
          ['breve', [728]],
          ['Breve', [728]],
          ['brvbar', [166]],
          ['bscr', [119991]],
          ['Bscr', [8492]],
          ['bsemi', [8271]],
          ['bsim', [8765]],
          ['bsime', [8909]],
          ['bsolb', [10693]],
          ['bsol', [92]],
          ['bsolhsub', [10184]],
          ['bull', [8226]],
          ['bullet', [8226]],
          ['bump', [8782]],
          ['bumpE', [10926]],
          ['bumpe', [8783]],
          ['Bumpeq', [8782]],
          ['bumpeq', [8783]],
          ['Cacute', [262]],
          ['cacute', [263]],
          ['capand', [10820]],
          ['capbrcup', [10825]],
          ['capcap', [10827]],
          ['cap', [8745]],
          ['Cap', [8914]],
          ['capcup', [10823]],
          ['capdot', [10816]],
          ['CapitalDifferentialD', [8517]],
          ['caps', [8745, 65024]],
          ['caret', [8257]],
          ['caron', [711]],
          ['Cayleys', [8493]],
          ['ccaps', [10829]],
          ['Ccaron', [268]],
          ['ccaron', [269]],
          ['Ccedil', [199]],
          ['ccedil', [231]],
          ['Ccirc', [264]],
          ['ccirc', [265]],
          ['Cconint', [8752]],
          ['ccups', [10828]],
          ['ccupssm', [10832]],
          ['Cdot', [266]],
          ['cdot', [267]],
          ['cedil', [184]],
          ['Cedilla', [184]],
          ['cemptyv', [10674]],
          ['cent', [162]],
          ['centerdot', [183]],
          ['CenterDot', [183]],
          ['cfr', [120096]],
          ['Cfr', [8493]],
          ['CHcy', [1063]],
          ['chcy', [1095]],
          ['check', [10003]],
          ['checkmark', [10003]],
          ['Chi', [935]],
          ['chi', [967]],
          ['circ', [710]],
          ['circeq', [8791]],
          ['circlearrowleft', [8634]],
          ['circlearrowright', [8635]],
          ['circledast', [8859]],
          ['circledcirc', [8858]],
          ['circleddash', [8861]],
          ['CircleDot', [8857]],
          ['circledR', [174]],
          ['circledS', [9416]],
          ['CircleMinus', [8854]],
          ['CirclePlus', [8853]],
          ['CircleTimes', [8855]],
          ['cir', [9675]],
          ['cirE', [10691]],
          ['cire', [8791]],
          ['cirfnint', [10768]],
          ['cirmid', [10991]],
          ['cirscir', [10690]],
          ['ClockwiseContourIntegral', [8754]],
          ['clubs', [9827]],
          ['clubsuit', [9827]],
          ['colon', [58]],
          ['Colon', [8759]],
          ['Colone', [10868]],
          ['colone', [8788]],
          ['coloneq', [8788]],
          ['comma', [44]],
          ['commat', [64]],
          ['comp', [8705]],
          ['compfn', [8728]],
          ['complement', [8705]],
          ['complexes', [8450]],
          ['cong', [8773]],
          ['congdot', [10861]],
          ['Congruent', [8801]],
          ['conint', [8750]],
          ['Conint', [8751]],
          ['ContourIntegral', [8750]],
          ['copf', [120148]],
          ['Copf', [8450]],
          ['coprod', [8720]],
          ['Coproduct', [8720]],
          ['copy', [169]],
          ['COPY', [169]],
          ['copysr', [8471]],
          ['CounterClockwiseContourIntegral', [8755]],
          ['crarr', [8629]],
          ['cross', [10007]],
          ['Cross', [10799]],
          ['Cscr', [119966]],
          ['cscr', [119992]],
          ['csub', [10959]],
          ['csube', [10961]],
          ['csup', [10960]],
          ['csupe', [10962]],
          ['ctdot', [8943]],
          ['cudarrl', [10552]],
          ['cudarrr', [10549]],
          ['cuepr', [8926]],
          ['cuesc', [8927]],
          ['cularr', [8630]],
          ['cularrp', [10557]],
          ['cupbrcap', [10824]],
          ['cupcap', [10822]],
          ['CupCap', [8781]],
          ['cup', [8746]],
          ['Cup', [8915]],
          ['cupcup', [10826]],
          ['cupdot', [8845]],
          ['cupor', [10821]],
          ['cups', [8746, 65024]],
          ['curarr', [8631]],
          ['curarrm', [10556]],
          ['curlyeqprec', [8926]],
          ['curlyeqsucc', [8927]],
          ['curlyvee', [8910]],
          ['curlywedge', [8911]],
          ['curren', [164]],
          ['curvearrowleft', [8630]],
          ['curvearrowright', [8631]],
          ['cuvee', [8910]],
          ['cuwed', [8911]],
          ['cwconint', [8754]],
          ['cwint', [8753]],
          ['cylcty', [9005]],
          ['dagger', [8224]],
          ['Dagger', [8225]],
          ['daleth', [8504]],
          ['darr', [8595]],
          ['Darr', [8609]],
          ['dArr', [8659]],
          ['dash', [8208]],
          ['Dashv', [10980]],
          ['dashv', [8867]],
          ['dbkarow', [10511]],
          ['dblac', [733]],
          ['Dcaron', [270]],
          ['dcaron', [271]],
          ['Dcy', [1044]],
          ['dcy', [1076]],
          ['ddagger', [8225]],
          ['ddarr', [8650]],
          ['DD', [8517]],
          ['dd', [8518]],
          ['DDotrahd', [10513]],
          ['ddotseq', [10871]],
          ['deg', [176]],
          ['Del', [8711]],
          ['Delta', [916]],
          ['delta', [948]],
          ['demptyv', [10673]],
          ['dfisht', [10623]],
          ['Dfr', [120071]],
          ['dfr', [120097]],
          ['dHar', [10597]],
          ['dharl', [8643]],
          ['dharr', [8642]],
          ['DiacriticalAcute', [180]],
          ['DiacriticalDot', [729]],
          ['DiacriticalDoubleAcute', [733]],
          ['DiacriticalGrave', [96]],
          ['DiacriticalTilde', [732]],
          ['diam', [8900]],
          ['diamond', [8900]],
          ['Diamond', [8900]],
          ['diamondsuit', [9830]],
          ['diams', [9830]],
          ['die', [168]],
          ['DifferentialD', [8518]],
          ['digamma', [989]],
          ['disin', [8946]],
          ['div', [247]],
          ['divide', [247]],
          ['divideontimes', [8903]],
          ['divonx', [8903]],
          ['DJcy', [1026]],
          ['djcy', [1106]],
          ['dlcorn', [8990]],
          ['dlcrop', [8973]],
          ['dollar', [36]],
          ['Dopf', [120123]],
          ['dopf', [120149]],
          ['Dot', [168]],
          ['dot', [729]],
          ['DotDot', [8412]],
          ['doteq', [8784]],
          ['doteqdot', [8785]],
          ['DotEqual', [8784]],
          ['dotminus', [8760]],
          ['dotplus', [8724]],
          ['dotsquare', [8865]],
          ['doublebarwedge', [8966]],
          ['DoubleContourIntegral', [8751]],
          ['DoubleDot', [168]],
          ['DoubleDownArrow', [8659]],
          ['DoubleLeftArrow', [8656]],
          ['DoubleLeftRightArrow', [8660]],
          ['DoubleLeftTee', [10980]],
          ['DoubleLongLeftArrow', [10232]],
          ['DoubleLongLeftRightArrow', [10234]],
          ['DoubleLongRightArrow', [10233]],
          ['DoubleRightArrow', [8658]],
          ['DoubleRightTee', [8872]],
          ['DoubleUpArrow', [8657]],
          ['DoubleUpDownArrow', [8661]],
          ['DoubleVerticalBar', [8741]],
          ['DownArrowBar', [10515]],
          ['downarrow', [8595]],
          ['DownArrow', [8595]],
          ['Downarrow', [8659]],
          ['DownArrowUpArrow', [8693]],
          ['DownBreve', [785]],
          ['downdownarrows', [8650]],
          ['downharpoonleft', [8643]],
          ['downharpoonright', [8642]],
          ['DownLeftRightVector', [10576]],
          ['DownLeftTeeVector', [10590]],
          ['DownLeftVectorBar', [10582]],
          ['DownLeftVector', [8637]],
          ['DownRightTeeVector', [10591]],
          ['DownRightVectorBar', [10583]],
          ['DownRightVector', [8641]],
          ['DownTeeArrow', [8615]],
          ['DownTee', [8868]],
          ['drbkarow', [10512]],
          ['drcorn', [8991]],
          ['drcrop', [8972]],
          ['Dscr', [119967]],
          ['dscr', [119993]],
          ['DScy', [1029]],
          ['dscy', [1109]],
          ['dsol', [10742]],
          ['Dstrok', [272]],
          ['dstrok', [273]],
          ['dtdot', [8945]],
          ['dtri', [9663]],
          ['dtrif', [9662]],
          ['duarr', [8693]],
          ['duhar', [10607]],
          ['dwangle', [10662]],
          ['DZcy', [1039]],
          ['dzcy', [1119]],
          ['dzigrarr', [10239]],
          ['Eacute', [201]],
          ['eacute', [233]],
          ['easter', [10862]],
          ['Ecaron', [282]],
          ['ecaron', [283]],
          ['Ecirc', [202]],
          ['ecirc', [234]],
          ['ecir', [8790]],
          ['ecolon', [8789]],
          ['Ecy', [1069]],
          ['ecy', [1101]],
          ['eDDot', [10871]],
          ['Edot', [278]],
          ['edot', [279]],
          ['eDot', [8785]],
          ['ee', [8519]],
          ['efDot', [8786]],
          ['Efr', [120072]],
          ['efr', [120098]],
          ['eg', [10906]],
          ['Egrave', [200]],
          ['egrave', [232]],
          ['egs', [10902]],
          ['egsdot', [10904]],
          ['el', [10905]],
          ['Element', [8712]],
          ['elinters', [9191]],
          ['ell', [8467]],
          ['els', [10901]],
          ['elsdot', [10903]],
          ['Emacr', [274]],
          ['emacr', [275]],
          ['empty', [8709]],
          ['emptyset', [8709]],
          ['EmptySmallSquare', [9723]],
          ['emptyv', [8709]],
          ['EmptyVerySmallSquare', [9643]],
          ['emsp13', [8196]],
          ['emsp14', [8197]],
          ['emsp', [8195]],
          ['ENG', [330]],
          ['eng', [331]],
          ['ensp', [8194]],
          ['Eogon', [280]],
          ['eogon', [281]],
          ['Eopf', [120124]],
          ['eopf', [120150]],
          ['epar', [8917]],
          ['eparsl', [10723]],
          ['eplus', [10865]],
          ['epsi', [949]],
          ['Epsilon', [917]],
          ['epsilon', [949]],
          ['epsiv', [1013]],
          ['eqcirc', [8790]],
          ['eqcolon', [8789]],
          ['eqsim', [8770]],
          ['eqslantgtr', [10902]],
          ['eqslantless', [10901]],
          ['Equal', [10869]],
          ['equals', [61]],
          ['EqualTilde', [8770]],
          ['equest', [8799]],
          ['Equilibrium', [8652]],
          ['equiv', [8801]],
          ['equivDD', [10872]],
          ['eqvparsl', [10725]],
          ['erarr', [10609]],
          ['erDot', [8787]],
          ['escr', [8495]],
          ['Escr', [8496]],
          ['esdot', [8784]],
          ['Esim', [10867]],
          ['esim', [8770]],
          ['Eta', [919]],
          ['eta', [951]],
          ['ETH', [208]],
          ['eth', [240]],
          ['Euml', [203]],
          ['euml', [235]],
          ['euro', [8364]],
          ['excl', [33]],
          ['exist', [8707]],
          ['Exists', [8707]],
          ['expectation', [8496]],
          ['exponentiale', [8519]],
          ['ExponentialE', [8519]],
          ['fallingdotseq', [8786]],
          ['Fcy', [1060]],
          ['fcy', [1092]],
          ['female', [9792]],
          ['ffilig', [64259]],
          ['fflig', [64256]],
          ['ffllig', [64260]],
          ['Ffr', [120073]],
          ['ffr', [120099]],
          ['filig', [64257]],
          ['FilledSmallSquare', [9724]],
          ['FilledVerySmallSquare', [9642]],
          ['fjlig', [102, 106]],
          ['flat', [9837]],
          ['fllig', [64258]],
          ['fltns', [9649]],
          ['fnof', [402]],
          ['Fopf', [120125]],
          ['fopf', [120151]],
          ['forall', [8704]],
          ['ForAll', [8704]],
          ['fork', [8916]],
          ['forkv', [10969]],
          ['Fouriertrf', [8497]],
          ['fpartint', [10765]],
          ['frac12', [189]],
          ['frac13', [8531]],
          ['frac14', [188]],
          ['frac15', [8533]],
          ['frac16', [8537]],
          ['frac18', [8539]],
          ['frac23', [8532]],
          ['frac25', [8534]],
          ['frac34', [190]],
          ['frac35', [8535]],
          ['frac38', [8540]],
          ['frac45', [8536]],
          ['frac56', [8538]],
          ['frac58', [8541]],
          ['frac78', [8542]],
          ['frasl', [8260]],
          ['frown', [8994]],
          ['fscr', [119995]],
          ['Fscr', [8497]],
          ['gacute', [501]],
          ['Gamma', [915]],
          ['gamma', [947]],
          ['Gammad', [988]],
          ['gammad', [989]],
          ['gap', [10886]],
          ['Gbreve', [286]],
          ['gbreve', [287]],
          ['Gcedil', [290]],
          ['Gcirc', [284]],
          ['gcirc', [285]],
          ['Gcy', [1043]],
          ['gcy', [1075]],
          ['Gdot', [288]],
          ['gdot', [289]],
          ['ge', [8805]],
          ['gE', [8807]],
          ['gEl', [10892]],
          ['gel', [8923]],
          ['geq', [8805]],
          ['geqq', [8807]],
          ['geqslant', [10878]],
          ['gescc', [10921]],
          ['ges', [10878]],
          ['gesdot', [10880]],
          ['gesdoto', [10882]],
          ['gesdotol', [10884]],
          ['gesl', [8923, 65024]],
          ['gesles', [10900]],
          ['Gfr', [120074]],
          ['gfr', [120100]],
          ['gg', [8811]],
          ['Gg', [8921]],
          ['ggg', [8921]],
          ['gimel', [8503]],
          ['GJcy', [1027]],
          ['gjcy', [1107]],
          ['gla', [10917]],
          ['gl', [8823]],
          ['glE', [10898]],
          ['glj', [10916]],
          ['gnap', [10890]],
          ['gnapprox', [10890]],
          ['gne', [10888]],
          ['gnE', [8809]],
          ['gneq', [10888]],
          ['gneqq', [8809]],
          ['gnsim', [8935]],
          ['Gopf', [120126]],
          ['gopf', [120152]],
          ['grave', [96]],
          ['GreaterEqual', [8805]],
          ['GreaterEqualLess', [8923]],
          ['GreaterFullEqual', [8807]],
          ['GreaterGreater', [10914]],
          ['GreaterLess', [8823]],
          ['GreaterSlantEqual', [10878]],
          ['GreaterTilde', [8819]],
          ['Gscr', [119970]],
          ['gscr', [8458]],
          ['gsim', [8819]],
          ['gsime', [10894]],
          ['gsiml', [10896]],
          ['gtcc', [10919]],
          ['gtcir', [10874]],
          ['gt', [62]],
          ['GT', [62]],
          ['Gt', [8811]],
          ['gtdot', [8919]],
          ['gtlPar', [10645]],
          ['gtquest', [10876]],
          ['gtrapprox', [10886]],
          ['gtrarr', [10616]],
          ['gtrdot', [8919]],
          ['gtreqless', [8923]],
          ['gtreqqless', [10892]],
          ['gtrless', [8823]],
          ['gtrsim', [8819]],
          ['gvertneqq', [8809, 65024]],
          ['gvnE', [8809, 65024]],
          ['Hacek', [711]],
          ['hairsp', [8202]],
          ['half', [189]],
          ['hamilt', [8459]],
          ['HARDcy', [1066]],
          ['hardcy', [1098]],
          ['harrcir', [10568]],
          ['harr', [8596]],
          ['hArr', [8660]],
          ['harrw', [8621]],
          ['Hat', [94]],
          ['hbar', [8463]],
          ['Hcirc', [292]],
          ['hcirc', [293]],
          ['hearts', [9829]],
          ['heartsuit', [9829]],
          ['hellip', [8230]],
          ['hercon', [8889]],
          ['hfr', [120101]],
          ['Hfr', [8460]],
          ['HilbertSpace', [8459]],
          ['hksearow', [10533]],
          ['hkswarow', [10534]],
          ['hoarr', [8703]],
          ['homtht', [8763]],
          ['hookleftarrow', [8617]],
          ['hookrightarrow', [8618]],
          ['hopf', [120153]],
          ['Hopf', [8461]],
          ['horbar', [8213]],
          ['HorizontalLine', [9472]],
          ['hscr', [119997]],
          ['Hscr', [8459]],
          ['hslash', [8463]],
          ['Hstrok', [294]],
          ['hstrok', [295]],
          ['HumpDownHump', [8782]],
          ['HumpEqual', [8783]],
          ['hybull', [8259]],
          ['hyphen', [8208]],
          ['Iacute', [205]],
          ['iacute', [237]],
          ['ic', [8291]],
          ['Icirc', [206]],
          ['icirc', [238]],
          ['Icy', [1048]],
          ['icy', [1080]],
          ['Idot', [304]],
          ['IEcy', [1045]],
          ['iecy', [1077]],
          ['iexcl', [161]],
          ['iff', [8660]],
          ['ifr', [120102]],
          ['Ifr', [8465]],
          ['Igrave', [204]],
          ['igrave', [236]],
          ['ii', [8520]],
          ['iiiint', [10764]],
          ['iiint', [8749]],
          ['iinfin', [10716]],
          ['iiota', [8489]],
          ['IJlig', [306]],
          ['ijlig', [307]],
          ['Imacr', [298]],
          ['imacr', [299]],
          ['image', [8465]],
          ['ImaginaryI', [8520]],
          ['imagline', [8464]],
          ['imagpart', [8465]],
          ['imath', [305]],
          ['Im', [8465]],
          ['imof', [8887]],
          ['imped', [437]],
          ['Implies', [8658]],
          ['incare', [8453]],
          ['in', [8712]],
          ['infin', [8734]],
          ['infintie', [10717]],
          ['inodot', [305]],
          ['intcal', [8890]],
          ['int', [8747]],
          ['Int', [8748]],
          ['integers', [8484]],
          ['Integral', [8747]],
          ['intercal', [8890]],
          ['Intersection', [8898]],
          ['intlarhk', [10775]],
          ['intprod', [10812]],
          ['InvisibleComma', [8291]],
          ['InvisibleTimes', [8290]],
          ['IOcy', [1025]],
          ['iocy', [1105]],
          ['Iogon', [302]],
          ['iogon', [303]],
          ['Iopf', [120128]],
          ['iopf', [120154]],
          ['Iota', [921]],
          ['iota', [953]],
          ['iprod', [10812]],
          ['iquest', [191]],
          ['iscr', [119998]],
          ['Iscr', [8464]],
          ['isin', [8712]],
          ['isindot', [8949]],
          ['isinE', [8953]],
          ['isins', [8948]],
          ['isinsv', [8947]],
          ['isinv', [8712]],
          ['it', [8290]],
          ['Itilde', [296]],
          ['itilde', [297]],
          ['Iukcy', [1030]],
          ['iukcy', [1110]],
          ['Iuml', [207]],
          ['iuml', [239]],
          ['Jcirc', [308]],
          ['jcirc', [309]],
          ['Jcy', [1049]],
          ['jcy', [1081]],
          ['Jfr', [120077]],
          ['jfr', [120103]],
          ['jmath', [567]],
          ['Jopf', [120129]],
          ['jopf', [120155]],
          ['Jscr', [119973]],
          ['jscr', [119999]],
          ['Jsercy', [1032]],
          ['jsercy', [1112]],
          ['Jukcy', [1028]],
          ['jukcy', [1108]],
          ['Kappa', [922]],
          ['kappa', [954]],
          ['kappav', [1008]],
          ['Kcedil', [310]],
          ['kcedil', [311]],
          ['Kcy', [1050]],
          ['kcy', [1082]],
          ['Kfr', [120078]],
          ['kfr', [120104]],
          ['kgreen', [312]],
          ['KHcy', [1061]],
          ['khcy', [1093]],
          ['KJcy', [1036]],
          ['kjcy', [1116]],
          ['Kopf', [120130]],
          ['kopf', [120156]],
          ['Kscr', [119974]],
          ['kscr', [120000]],
          ['lAarr', [8666]],
          ['Lacute', [313]],
          ['lacute', [314]],
          ['laemptyv', [10676]],
          ['lagran', [8466]],
          ['Lambda', [923]],
          ['lambda', [955]],
          ['lang', [10216]],
          ['Lang', [10218]],
          ['langd', [10641]],
          ['langle', [10216]],
          ['lap', [10885]],
          ['Laplacetrf', [8466]],
          ['laquo', [171]],
          ['larrb', [8676]],
          ['larrbfs', [10527]],
          ['larr', [8592]],
          ['Larr', [8606]],
          ['lArr', [8656]],
          ['larrfs', [10525]],
          ['larrhk', [8617]],
          ['larrlp', [8619]],
          ['larrpl', [10553]],
          ['larrsim', [10611]],
          ['larrtl', [8610]],
          ['latail', [10521]],
          ['lAtail', [10523]],
          ['lat', [10923]],
          ['late', [10925]],
          ['lates', [10925, 65024]],
          ['lbarr', [10508]],
          ['lBarr', [10510]],
          ['lbbrk', [10098]],
          ['lbrace', [123]],
          ['lbrack', [91]],
          ['lbrke', [10635]],
          ['lbrksld', [10639]],
          ['lbrkslu', [10637]],
          ['Lcaron', [317]],
          ['lcaron', [318]],
          ['Lcedil', [315]],
          ['lcedil', [316]],
          ['lceil', [8968]],
          ['lcub', [123]],
          ['Lcy', [1051]],
          ['lcy', [1083]],
          ['ldca', [10550]],
          ['ldquo', [8220]],
          ['ldquor', [8222]],
          ['ldrdhar', [10599]],
          ['ldrushar', [10571]],
          ['ldsh', [8626]],
          ['le', [8804]],
          ['lE', [8806]],
          ['LeftAngleBracket', [10216]],
          ['LeftArrowBar', [8676]],
          ['leftarrow', [8592]],
          ['LeftArrow', [8592]],
          ['Leftarrow', [8656]],
          ['LeftArrowRightArrow', [8646]],
          ['leftarrowtail', [8610]],
          ['LeftCeiling', [8968]],
          ['LeftDoubleBracket', [10214]],
          ['LeftDownTeeVector', [10593]],
          ['LeftDownVectorBar', [10585]],
          ['LeftDownVector', [8643]],
          ['LeftFloor', [8970]],
          ['leftharpoondown', [8637]],
          ['leftharpoonup', [8636]],
          ['leftleftarrows', [8647]],
          ['leftrightarrow', [8596]],
          ['LeftRightArrow', [8596]],
          ['Leftrightarrow', [8660]],
          ['leftrightarrows', [8646]],
          ['leftrightharpoons', [8651]],
          ['leftrightsquigarrow', [8621]],
          ['LeftRightVector', [10574]],
          ['LeftTeeArrow', [8612]],
          ['LeftTee', [8867]],
          ['LeftTeeVector', [10586]],
          ['leftthreetimes', [8907]],
          ['LeftTriangleBar', [10703]],
          ['LeftTriangle', [8882]],
          ['LeftTriangleEqual', [8884]],
          ['LeftUpDownVector', [10577]],
          ['LeftUpTeeVector', [10592]],
          ['LeftUpVectorBar', [10584]],
          ['LeftUpVector', [8639]],
          ['LeftVectorBar', [10578]],
          ['LeftVector', [8636]],
          ['lEg', [10891]],
          ['leg', [8922]],
          ['leq', [8804]],
          ['leqq', [8806]],
          ['leqslant', [10877]],
          ['lescc', [10920]],
          ['les', [10877]],
          ['lesdot', [10879]],
          ['lesdoto', [10881]],
          ['lesdotor', [10883]],
          ['lesg', [8922, 65024]],
          ['lesges', [10899]],
          ['lessapprox', [10885]],
          ['lessdot', [8918]],
          ['lesseqgtr', [8922]],
          ['lesseqqgtr', [10891]],
          ['LessEqualGreater', [8922]],
          ['LessFullEqual', [8806]],
          ['LessGreater', [8822]],
          ['lessgtr', [8822]],
          ['LessLess', [10913]],
          ['lesssim', [8818]],
          ['LessSlantEqual', [10877]],
          ['LessTilde', [8818]],
          ['lfisht', [10620]],
          ['lfloor', [8970]],
          ['Lfr', [120079]],
          ['lfr', [120105]],
          ['lg', [8822]],
          ['lgE', [10897]],
          ['lHar', [10594]],
          ['lhard', [8637]],
          ['lharu', [8636]],
          ['lharul', [10602]],
          ['lhblk', [9604]],
          ['LJcy', [1033]],
          ['ljcy', [1113]],
          ['llarr', [8647]],
          ['ll', [8810]],
          ['Ll', [8920]],
          ['llcorner', [8990]],
          ['Lleftarrow', [8666]],
          ['llhard', [10603]],
          ['lltri', [9722]],
          ['Lmidot', [319]],
          ['lmidot', [320]],
          ['lmoustache', [9136]],
          ['lmoust', [9136]],
          ['lnap', [10889]],
          ['lnapprox', [10889]],
          ['lne', [10887]],
          ['lnE', [8808]],
          ['lneq', [10887]],
          ['lneqq', [8808]],
          ['lnsim', [8934]],
          ['loang', [10220]],
          ['loarr', [8701]],
          ['lobrk', [10214]],
          ['longleftarrow', [10229]],
          ['LongLeftArrow', [10229]],
          ['Longleftarrow', [10232]],
          ['longleftrightarrow', [10231]],
          ['LongLeftRightArrow', [10231]],
          ['Longleftrightarrow', [10234]],
          ['longmapsto', [10236]],
          ['longrightarrow', [10230]],
          ['LongRightArrow', [10230]],
          ['Longrightarrow', [10233]],
          ['looparrowleft', [8619]],
          ['looparrowright', [8620]],
          ['lopar', [10629]],
          ['Lopf', [120131]],
          ['lopf', [120157]],
          ['loplus', [10797]],
          ['lotimes', [10804]],
          ['lowast', [8727]],
          ['lowbar', [95]],
          ['LowerLeftArrow', [8601]],
          ['LowerRightArrow', [8600]],
          ['loz', [9674]],
          ['lozenge', [9674]],
          ['lozf', [10731]],
          ['lpar', [40]],
          ['lparlt', [10643]],
          ['lrarr', [8646]],
          ['lrcorner', [8991]],
          ['lrhar', [8651]],
          ['lrhard', [10605]],
          ['lrm', [8206]],
          ['lrtri', [8895]],
          ['lsaquo', [8249]],
          ['lscr', [120001]],
          ['Lscr', [8466]],
          ['lsh', [8624]],
          ['Lsh', [8624]],
          ['lsim', [8818]],
          ['lsime', [10893]],
          ['lsimg', [10895]],
          ['lsqb', [91]],
          ['lsquo', [8216]],
          ['lsquor', [8218]],
          ['Lstrok', [321]],
          ['lstrok', [322]],
          ['ltcc', [10918]],
          ['ltcir', [10873]],
          ['lt', [60]],
          ['LT', [60]],
          ['Lt', [8810]],
          ['ltdot', [8918]],
          ['lthree', [8907]],
          ['ltimes', [8905]],
          ['ltlarr', [10614]],
          ['ltquest', [10875]],
          ['ltri', [9667]],
          ['ltrie', [8884]],
          ['ltrif', [9666]],
          ['ltrPar', [10646]],
          ['lurdshar', [10570]],
          ['luruhar', [10598]],
          ['lvertneqq', [8808, 65024]],
          ['lvnE', [8808, 65024]],
          ['macr', [175]],
          ['male', [9794]],
          ['malt', [10016]],
          ['maltese', [10016]],
          ['Map', [10501]],
          ['map', [8614]],
          ['mapsto', [8614]],
          ['mapstodown', [8615]],
          ['mapstoleft', [8612]],
          ['mapstoup', [8613]],
          ['marker', [9646]],
          ['mcomma', [10793]],
          ['Mcy', [1052]],
          ['mcy', [1084]],
          ['mdash', [8212]],
          ['mDDot', [8762]],
          ['measuredangle', [8737]],
          ['MediumSpace', [8287]],
          ['Mellintrf', [8499]],
          ['Mfr', [120080]],
          ['mfr', [120106]],
          ['mho', [8487]],
          ['micro', [181]],
          ['midast', [42]],
          ['midcir', [10992]],
          ['mid', [8739]],
          ['middot', [183]],
          ['minusb', [8863]],
          ['minus', [8722]],
          ['minusd', [8760]],
          ['minusdu', [10794]],
          ['MinusPlus', [8723]],
          ['mlcp', [10971]],
          ['mldr', [8230]],
          ['mnplus', [8723]],
          ['models', [8871]],
          ['Mopf', [120132]],
          ['mopf', [120158]],
          ['mp', [8723]],
          ['mscr', [120002]],
          ['Mscr', [8499]],
          ['mstpos', [8766]],
          ['Mu', [924]],
          ['mu', [956]],
          ['multimap', [8888]],
          ['mumap', [8888]],
          ['nabla', [8711]],
          ['Nacute', [323]],
          ['nacute', [324]],
          ['nang', [8736, 8402]],
          ['nap', [8777]],
          ['napE', [10864, 824]],
          ['napid', [8779, 824]],
          ['napos', [329]],
          ['napprox', [8777]],
          ['natural', [9838]],
          ['naturals', [8469]],
          ['natur', [9838]],
          ['nbsp', [160]],
          ['nbump', [8782, 824]],
          ['nbumpe', [8783, 824]],
          ['ncap', [10819]],
          ['Ncaron', [327]],
          ['ncaron', [328]],
          ['Ncedil', [325]],
          ['ncedil', [326]],
          ['ncong', [8775]],
          ['ncongdot', [10861, 824]],
          ['ncup', [10818]],
          ['Ncy', [1053]],
          ['ncy', [1085]],
          ['ndash', [8211]],
          ['nearhk', [10532]],
          ['nearr', [8599]],
          ['neArr', [8663]],
          ['nearrow', [8599]],
          ['ne', [8800]],
          ['nedot', [8784, 824]],
          ['NegativeMediumSpace', [8203]],
          ['NegativeThickSpace', [8203]],
          ['NegativeThinSpace', [8203]],
          ['NegativeVeryThinSpace', [8203]],
          ['nequiv', [8802]],
          ['nesear', [10536]],
          ['nesim', [8770, 824]],
          ['NestedGreaterGreater', [8811]],
          ['NestedLessLess', [8810]],
          ['nexist', [8708]],
          ['nexists', [8708]],
          ['Nfr', [120081]],
          ['nfr', [120107]],
          ['ngE', [8807, 824]],
          ['nge', [8817]],
          ['ngeq', [8817]],
          ['ngeqq', [8807, 824]],
          ['ngeqslant', [10878, 824]],
          ['nges', [10878, 824]],
          ['nGg', [8921, 824]],
          ['ngsim', [8821]],
          ['nGt', [8811, 8402]],
          ['ngt', [8815]],
          ['ngtr', [8815]],
          ['nGtv', [8811, 824]],
          ['nharr', [8622]],
          ['nhArr', [8654]],
          ['nhpar', [10994]],
          ['ni', [8715]],
          ['nis', [8956]],
          ['nisd', [8954]],
          ['niv', [8715]],
          ['NJcy', [1034]],
          ['njcy', [1114]],
          ['nlarr', [8602]],
          ['nlArr', [8653]],
          ['nldr', [8229]],
          ['nlE', [8806, 824]],
          ['nle', [8816]],
          ['nleftarrow', [8602]],
          ['nLeftarrow', [8653]],
          ['nleftrightarrow', [8622]],
          ['nLeftrightarrow', [8654]],
          ['nleq', [8816]],
          ['nleqq', [8806, 824]],
          ['nleqslant', [10877, 824]],
          ['nles', [10877, 824]],
          ['nless', [8814]],
          ['nLl', [8920, 824]],
          ['nlsim', [8820]],
          ['nLt', [8810, 8402]],
          ['nlt', [8814]],
          ['nltri', [8938]],
          ['nltrie', [8940]],
          ['nLtv', [8810, 824]],
          ['nmid', [8740]],
          ['NoBreak', [8288]],
          ['NonBreakingSpace', [160]],
          ['nopf', [120159]],
          ['Nopf', [8469]],
          ['Not', [10988]],
          ['not', [172]],
          ['NotCongruent', [8802]],
          ['NotCupCap', [8813]],
          ['NotDoubleVerticalBar', [8742]],
          ['NotElement', [8713]],
          ['NotEqual', [8800]],
          ['NotEqualTilde', [8770, 824]],
          ['NotExists', [8708]],
          ['NotGreater', [8815]],
          ['NotGreaterEqual', [8817]],
          ['NotGreaterFullEqual', [8807, 824]],
          ['NotGreaterGreater', [8811, 824]],
          ['NotGreaterLess', [8825]],
          ['NotGreaterSlantEqual', [10878, 824]],
          ['NotGreaterTilde', [8821]],
          ['NotHumpDownHump', [8782, 824]],
          ['NotHumpEqual', [8783, 824]],
          ['notin', [8713]],
          ['notindot', [8949, 824]],
          ['notinE', [8953, 824]],
          ['notinva', [8713]],
          ['notinvb', [8951]],
          ['notinvc', [8950]],
          ['NotLeftTriangleBar', [10703, 824]],
          ['NotLeftTriangle', [8938]],
          ['NotLeftTriangleEqual', [8940]],
          ['NotLess', [8814]],
          ['NotLessEqual', [8816]],
          ['NotLessGreater', [8824]],
          ['NotLessLess', [8810, 824]],
          ['NotLessSlantEqual', [10877, 824]],
          ['NotLessTilde', [8820]],
          ['NotNestedGreaterGreater', [10914, 824]],
          ['NotNestedLessLess', [10913, 824]],
          ['notni', [8716]],
          ['notniva', [8716]],
          ['notnivb', [8958]],
          ['notnivc', [8957]],
          ['NotPrecedes', [8832]],
          ['NotPrecedesEqual', [10927, 824]],
          ['NotPrecedesSlantEqual', [8928]],
          ['NotReverseElement', [8716]],
          ['NotRightTriangleBar', [10704, 824]],
          ['NotRightTriangle', [8939]],
          ['NotRightTriangleEqual', [8941]],
          ['NotSquareSubset', [8847, 824]],
          ['NotSquareSubsetEqual', [8930]],
          ['NotSquareSuperset', [8848, 824]],
          ['NotSquareSupersetEqual', [8931]],
          ['NotSubset', [8834, 8402]],
          ['NotSubsetEqual', [8840]],
          ['NotSucceeds', [8833]],
          ['NotSucceedsEqual', [10928, 824]],
          ['NotSucceedsSlantEqual', [8929]],
          ['NotSucceedsTilde', [8831, 824]],
          ['NotSuperset', [8835, 8402]],
          ['NotSupersetEqual', [8841]],
          ['NotTilde', [8769]],
          ['NotTildeEqual', [8772]],
          ['NotTildeFullEqual', [8775]],
          ['NotTildeTilde', [8777]],
          ['NotVerticalBar', [8740]],
          ['nparallel', [8742]],
          ['npar', [8742]],
          ['nparsl', [11005, 8421]],
          ['npart', [8706, 824]],
          ['npolint', [10772]],
          ['npr', [8832]],
          ['nprcue', [8928]],
          ['nprec', [8832]],
          ['npreceq', [10927, 824]],
          ['npre', [10927, 824]],
          ['nrarrc', [10547, 824]],
          ['nrarr', [8603]],
          ['nrArr', [8655]],
          ['nrarrw', [8605, 824]],
          ['nrightarrow', [8603]],
          ['nRightarrow', [8655]],
          ['nrtri', [8939]],
          ['nrtrie', [8941]],
          ['nsc', [8833]],
          ['nsccue', [8929]],
          ['nsce', [10928, 824]],
          ['Nscr', [119977]],
          ['nscr', [120003]],
          ['nshortmid', [8740]],
          ['nshortparallel', [8742]],
          ['nsim', [8769]],
          ['nsime', [8772]],
          ['nsimeq', [8772]],
          ['nsmid', [8740]],
          ['nspar', [8742]],
          ['nsqsube', [8930]],
          ['nsqsupe', [8931]],
          ['nsub', [8836]],
          ['nsubE', [10949, 824]],
          ['nsube', [8840]],
          ['nsubset', [8834, 8402]],
          ['nsubseteq', [8840]],
          ['nsubseteqq', [10949, 824]],
          ['nsucc', [8833]],
          ['nsucceq', [10928, 824]],
          ['nsup', [8837]],
          ['nsupE', [10950, 824]],
          ['nsupe', [8841]],
          ['nsupset', [8835, 8402]],
          ['nsupseteq', [8841]],
          ['nsupseteqq', [10950, 824]],
          ['ntgl', [8825]],
          ['Ntilde', [209]],
          ['ntilde', [241]],
          ['ntlg', [8824]],
          ['ntriangleleft', [8938]],
          ['ntrianglelefteq', [8940]],
          ['ntriangleright', [8939]],
          ['ntrianglerighteq', [8941]],
          ['Nu', [925]],
          ['nu', [957]],
          ['num', [35]],
          ['numero', [8470]],
          ['numsp', [8199]],
          ['nvap', [8781, 8402]],
          ['nvdash', [8876]],
          ['nvDash', [8877]],
          ['nVdash', [8878]],
          ['nVDash', [8879]],
          ['nvge', [8805, 8402]],
          ['nvgt', [62, 8402]],
          ['nvHarr', [10500]],
          ['nvinfin', [10718]],
          ['nvlArr', [10498]],
          ['nvle', [8804, 8402]],
          ['nvlt', [60, 8402]],
          ['nvltrie', [8884, 8402]],
          ['nvrArr', [10499]],
          ['nvrtrie', [8885, 8402]],
          ['nvsim', [8764, 8402]],
          ['nwarhk', [10531]],
          ['nwarr', [8598]],
          ['nwArr', [8662]],
          ['nwarrow', [8598]],
          ['nwnear', [10535]],
          ['Oacute', [211]],
          ['oacute', [243]],
          ['oast', [8859]],
          ['Ocirc', [212]],
          ['ocirc', [244]],
          ['ocir', [8858]],
          ['Ocy', [1054]],
          ['ocy', [1086]],
          ['odash', [8861]],
          ['Odblac', [336]],
          ['odblac', [337]],
          ['odiv', [10808]],
          ['odot', [8857]],
          ['odsold', [10684]],
          ['OElig', [338]],
          ['oelig', [339]],
          ['ofcir', [10687]],
          ['Ofr', [120082]],
          ['ofr', [120108]],
          ['ogon', [731]],
          ['Ograve', [210]],
          ['ograve', [242]],
          ['ogt', [10689]],
          ['ohbar', [10677]],
          ['ohm', [937]],
          ['oint', [8750]],
          ['olarr', [8634]],
          ['olcir', [10686]],
          ['olcross', [10683]],
          ['oline', [8254]],
          ['olt', [10688]],
          ['Omacr', [332]],
          ['omacr', [333]],
          ['Omega', [937]],
          ['omega', [969]],
          ['Omicron', [927]],
          ['omicron', [959]],
          ['omid', [10678]],
          ['ominus', [8854]],
          ['Oopf', [120134]],
          ['oopf', [120160]],
          ['opar', [10679]],
          ['OpenCurlyDoubleQuote', [8220]],
          ['OpenCurlyQuote', [8216]],
          ['operp', [10681]],
          ['oplus', [8853]],
          ['orarr', [8635]],
          ['Or', [10836]],
          ['or', [8744]],
          ['ord', [10845]],
          ['order', [8500]],
          ['orderof', [8500]],
          ['ordf', [170]],
          ['ordm', [186]],
          ['origof', [8886]],
          ['oror', [10838]],
          ['orslope', [10839]],
          ['orv', [10843]],
          ['oS', [9416]],
          ['Oscr', [119978]],
          ['oscr', [8500]],
          ['Oslash', [216]],
          ['oslash', [248]],
          ['osol', [8856]],
          ['Otilde', [213]],
          ['otilde', [245]],
          ['otimesas', [10806]],
          ['Otimes', [10807]],
          ['otimes', [8855]],
          ['Ouml', [214]],
          ['ouml', [246]],
          ['ovbar', [9021]],
          ['OverBar', [8254]],
          ['OverBrace', [9182]],
          ['OverBracket', [9140]],
          ['OverParenthesis', [9180]],
          ['para', [182]],
          ['parallel', [8741]],
          ['par', [8741]],
          ['parsim', [10995]],
          ['parsl', [11005]],
          ['part', [8706]],
          ['PartialD', [8706]],
          ['Pcy', [1055]],
          ['pcy', [1087]],
          ['percnt', [37]],
          ['period', [46]],
          ['permil', [8240]],
          ['perp', [8869]],
          ['pertenk', [8241]],
          ['Pfr', [120083]],
          ['pfr', [120109]],
          ['Phi', [934]],
          ['phi', [966]],
          ['phiv', [981]],
          ['phmmat', [8499]],
          ['phone', [9742]],
          ['Pi', [928]],
          ['pi', [960]],
          ['pitchfork', [8916]],
          ['piv', [982]],
          ['planck', [8463]],
          ['planckh', [8462]],
          ['plankv', [8463]],
          ['plusacir', [10787]],
          ['plusb', [8862]],
          ['pluscir', [10786]],
          ['plus', [43]],
          ['plusdo', [8724]],
          ['plusdu', [10789]],
          ['pluse', [10866]],
          ['PlusMinus', [177]],
          ['plusmn', [177]],
          ['plussim', [10790]],
          ['plustwo', [10791]],
          ['pm', [177]],
          ['Poincareplane', [8460]],
          ['pointint', [10773]],
          ['popf', [120161]],
          ['Popf', [8473]],
          ['pound', [163]],
          ['prap', [10935]],
          ['Pr', [10939]],
          ['pr', [8826]],
          ['prcue', [8828]],
          ['precapprox', [10935]],
          ['prec', [8826]],
          ['preccurlyeq', [8828]],
          ['Precedes', [8826]],
          ['PrecedesEqual', [10927]],
          ['PrecedesSlantEqual', [8828]],
          ['PrecedesTilde', [8830]],
          ['preceq', [10927]],
          ['precnapprox', [10937]],
          ['precneqq', [10933]],
          ['precnsim', [8936]],
          ['pre', [10927]],
          ['prE', [10931]],
          ['precsim', [8830]],
          ['prime', [8242]],
          ['Prime', [8243]],
          ['primes', [8473]],
          ['prnap', [10937]],
          ['prnE', [10933]],
          ['prnsim', [8936]],
          ['prod', [8719]],
          ['Product', [8719]],
          ['profalar', [9006]],
          ['profline', [8978]],
          ['profsurf', [8979]],
          ['prop', [8733]],
          ['Proportional', [8733]],
          ['Proportion', [8759]],
          ['propto', [8733]],
          ['prsim', [8830]],
          ['prurel', [8880]],
          ['Pscr', [119979]],
          ['pscr', [120005]],
          ['Psi', [936]],
          ['psi', [968]],
          ['puncsp', [8200]],
          ['Qfr', [120084]],
          ['qfr', [120110]],
          ['qint', [10764]],
          ['qopf', [120162]],
          ['Qopf', [8474]],
          ['qprime', [8279]],
          ['Qscr', [119980]],
          ['qscr', [120006]],
          ['quaternions', [8461]],
          ['quatint', [10774]],
          ['quest', [63]],
          ['questeq', [8799]],
          ['quot', [34]],
          ['QUOT', [34]],
          ['rAarr', [8667]],
          ['race', [8765, 817]],
          ['Racute', [340]],
          ['racute', [341]],
          ['radic', [8730]],
          ['raemptyv', [10675]],
          ['rang', [10217]],
          ['Rang', [10219]],
          ['rangd', [10642]],
          ['range', [10661]],
          ['rangle', [10217]],
          ['raquo', [187]],
          ['rarrap', [10613]],
          ['rarrb', [8677]],
          ['rarrbfs', [10528]],
          ['rarrc', [10547]],
          ['rarr', [8594]],
          ['Rarr', [8608]],
          ['rArr', [8658]],
          ['rarrfs', [10526]],
          ['rarrhk', [8618]],
          ['rarrlp', [8620]],
          ['rarrpl', [10565]],
          ['rarrsim', [10612]],
          ['Rarrtl', [10518]],
          ['rarrtl', [8611]],
          ['rarrw', [8605]],
          ['ratail', [10522]],
          ['rAtail', [10524]],
          ['ratio', [8758]],
          ['rationals', [8474]],
          ['rbarr', [10509]],
          ['rBarr', [10511]],
          ['RBarr', [10512]],
          ['rbbrk', [10099]],
          ['rbrace', [125]],
          ['rbrack', [93]],
          ['rbrke', [10636]],
          ['rbrksld', [10638]],
          ['rbrkslu', [10640]],
          ['Rcaron', [344]],
          ['rcaron', [345]],
          ['Rcedil', [342]],
          ['rcedil', [343]],
          ['rceil', [8969]],
          ['rcub', [125]],
          ['Rcy', [1056]],
          ['rcy', [1088]],
          ['rdca', [10551]],
          ['rdldhar', [10601]],
          ['rdquo', [8221]],
          ['rdquor', [8221]],
          ['CloseCurlyDoubleQuote', [8221]],
          ['rdsh', [8627]],
          ['real', [8476]],
          ['realine', [8475]],
          ['realpart', [8476]],
          ['reals', [8477]],
          ['Re', [8476]],
          ['rect', [9645]],
          ['reg', [174]],
          ['REG', [174]],
          ['ReverseElement', [8715]],
          ['ReverseEquilibrium', [8651]],
          ['ReverseUpEquilibrium', [10607]],
          ['rfisht', [10621]],
          ['rfloor', [8971]],
          ['rfr', [120111]],
          ['Rfr', [8476]],
          ['rHar', [10596]],
          ['rhard', [8641]],
          ['rharu', [8640]],
          ['rharul', [10604]],
          ['Rho', [929]],
          ['rho', [961]],
          ['rhov', [1009]],
          ['RightAngleBracket', [10217]],
          ['RightArrowBar', [8677]],
          ['rightarrow', [8594]],
          ['RightArrow', [8594]],
          ['Rightarrow', [8658]],
          ['RightArrowLeftArrow', [8644]],
          ['rightarrowtail', [8611]],
          ['RightCeiling', [8969]],
          ['RightDoubleBracket', [10215]],
          ['RightDownTeeVector', [10589]],
          ['RightDownVectorBar', [10581]],
          ['RightDownVector', [8642]],
          ['RightFloor', [8971]],
          ['rightharpoondown', [8641]],
          ['rightharpoonup', [8640]],
          ['rightleftarrows', [8644]],
          ['rightleftharpoons', [8652]],
          ['rightrightarrows', [8649]],
          ['rightsquigarrow', [8605]],
          ['RightTeeArrow', [8614]],
          ['RightTee', [8866]],
          ['RightTeeVector', [10587]],
          ['rightthreetimes', [8908]],
          ['RightTriangleBar', [10704]],
          ['RightTriangle', [8883]],
          ['RightTriangleEqual', [8885]],
          ['RightUpDownVector', [10575]],
          ['RightUpTeeVector', [10588]],
          ['RightUpVectorBar', [10580]],
          ['RightUpVector', [8638]],
          ['RightVectorBar', [10579]],
          ['RightVector', [8640]],
          ['ring', [730]],
          ['risingdotseq', [8787]],
          ['rlarr', [8644]],
          ['rlhar', [8652]],
          ['rlm', [8207]],
          ['rmoustache', [9137]],
          ['rmoust', [9137]],
          ['rnmid', [10990]],
          ['roang', [10221]],
          ['roarr', [8702]],
          ['robrk', [10215]],
          ['ropar', [10630]],
          ['ropf', [120163]],
          ['Ropf', [8477]],
          ['roplus', [10798]],
          ['rotimes', [10805]],
          ['RoundImplies', [10608]],
          ['rpar', [41]],
          ['rpargt', [10644]],
          ['rppolint', [10770]],
          ['rrarr', [8649]],
          ['Rrightarrow', [8667]],
          ['rsaquo', [8250]],
          ['rscr', [120007]],
          ['Rscr', [8475]],
          ['rsh', [8625]],
          ['Rsh', [8625]],
          ['rsqb', [93]],
          ['rsquo', [8217]],
          ['rsquor', [8217]],
          ['CloseCurlyQuote', [8217]],
          ['rthree', [8908]],
          ['rtimes', [8906]],
          ['rtri', [9657]],
          ['rtrie', [8885]],
          ['rtrif', [9656]],
          ['rtriltri', [10702]],
          ['RuleDelayed', [10740]],
          ['ruluhar', [10600]],
          ['rx', [8478]],
          ['Sacute', [346]],
          ['sacute', [347]],
          ['sbquo', [8218]],
          ['scap', [10936]],
          ['Scaron', [352]],
          ['scaron', [353]],
          ['Sc', [10940]],
          ['sc', [8827]],
          ['sccue', [8829]],
          ['sce', [10928]],
          ['scE', [10932]],
          ['Scedil', [350]],
          ['scedil', [351]],
          ['Scirc', [348]],
          ['scirc', [349]],
          ['scnap', [10938]],
          ['scnE', [10934]],
          ['scnsim', [8937]],
          ['scpolint', [10771]],
          ['scsim', [8831]],
          ['Scy', [1057]],
          ['scy', [1089]],
          ['sdotb', [8865]],
          ['sdot', [8901]],
          ['sdote', [10854]],
          ['searhk', [10533]],
          ['searr', [8600]],
          ['seArr', [8664]],
          ['searrow', [8600]],
          ['sect', [167]],
          ['semi', [59]],
          ['seswar', [10537]],
          ['setminus', [8726]],
          ['setmn', [8726]],
          ['sext', [10038]],
          ['Sfr', [120086]],
          ['sfr', [120112]],
          ['sfrown', [8994]],
          ['sharp', [9839]],
          ['SHCHcy', [1065]],
          ['shchcy', [1097]],
          ['SHcy', [1064]],
          ['shcy', [1096]],
          ['ShortDownArrow', [8595]],
          ['ShortLeftArrow', [8592]],
          ['shortmid', [8739]],
          ['shortparallel', [8741]],
          ['ShortRightArrow', [8594]],
          ['ShortUpArrow', [8593]],
          ['shy', [173]],
          ['Sigma', [931]],
          ['sigma', [963]],
          ['sigmaf', [962]],
          ['sigmav', [962]],
          ['sim', [8764]],
          ['simdot', [10858]],
          ['sime', [8771]],
          ['simeq', [8771]],
          ['simg', [10910]],
          ['simgE', [10912]],
          ['siml', [10909]],
          ['simlE', [10911]],
          ['simne', [8774]],
          ['simplus', [10788]],
          ['simrarr', [10610]],
          ['slarr', [8592]],
          ['SmallCircle', [8728]],
          ['smallsetminus', [8726]],
          ['smashp', [10803]],
          ['smeparsl', [10724]],
          ['smid', [8739]],
          ['smile', [8995]],
          ['smt', [10922]],
          ['smte', [10924]],
          ['smtes', [10924, 65024]],
          ['SOFTcy', [1068]],
          ['softcy', [1100]],
          ['solbar', [9023]],
          ['solb', [10692]],
          ['sol', [47]],
          ['Sopf', [120138]],
          ['sopf', [120164]],
          ['spades', [9824]],
          ['spadesuit', [9824]],
          ['spar', [8741]],
          ['sqcap', [8851]],
          ['sqcaps', [8851, 65024]],
          ['sqcup', [8852]],
          ['sqcups', [8852, 65024]],
          ['Sqrt', [8730]],
          ['sqsub', [8847]],
          ['sqsube', [8849]],
          ['sqsubset', [8847]],
          ['sqsubseteq', [8849]],
          ['sqsup', [8848]],
          ['sqsupe', [8850]],
          ['sqsupset', [8848]],
          ['sqsupseteq', [8850]],
          ['square', [9633]],
          ['Square', [9633]],
          ['SquareIntersection', [8851]],
          ['SquareSubset', [8847]],
          ['SquareSubsetEqual', [8849]],
          ['SquareSuperset', [8848]],
          ['SquareSupersetEqual', [8850]],
          ['SquareUnion', [8852]],
          ['squarf', [9642]],
          ['squ', [9633]],
          ['squf', [9642]],
          ['srarr', [8594]],
          ['Sscr', [119982]],
          ['sscr', [120008]],
          ['ssetmn', [8726]],
          ['ssmile', [8995]],
          ['sstarf', [8902]],
          ['Star', [8902]],
          ['star', [9734]],
          ['starf', [9733]],
          ['straightepsilon', [1013]],
          ['straightphi', [981]],
          ['strns', [175]],
          ['sub', [8834]],
          ['Sub', [8912]],
          ['subdot', [10941]],
          ['subE', [10949]],
          ['sube', [8838]],
          ['subedot', [10947]],
          ['submult', [10945]],
          ['subnE', [10955]],
          ['subne', [8842]],
          ['subplus', [10943]],
          ['subrarr', [10617]],
          ['subset', [8834]],
          ['Subset', [8912]],
          ['subseteq', [8838]],
          ['subseteqq', [10949]],
          ['SubsetEqual', [8838]],
          ['subsetneq', [8842]],
          ['subsetneqq', [10955]],
          ['subsim', [10951]],
          ['subsub', [10965]],
          ['subsup', [10963]],
          ['succapprox', [10936]],
          ['succ', [8827]],
          ['succcurlyeq', [8829]],
          ['Succeeds', [8827]],
          ['SucceedsEqual', [10928]],
          ['SucceedsSlantEqual', [8829]],
          ['SucceedsTilde', [8831]],
          ['succeq', [10928]],
          ['succnapprox', [10938]],
          ['succneqq', [10934]],
          ['succnsim', [8937]],
          ['succsim', [8831]],
          ['SuchThat', [8715]],
          ['sum', [8721]],
          ['Sum', [8721]],
          ['sung', [9834]],
          ['sup1', [185]],
          ['sup2', [178]],
          ['sup3', [179]],
          ['sup', [8835]],
          ['Sup', [8913]],
          ['supdot', [10942]],
          ['supdsub', [10968]],
          ['supE', [10950]],
          ['supe', [8839]],
          ['supedot', [10948]],
          ['Superset', [8835]],
          ['SupersetEqual', [8839]],
          ['suphsol', [10185]],
          ['suphsub', [10967]],
          ['suplarr', [10619]],
          ['supmult', [10946]],
          ['supnE', [10956]],
          ['supne', [8843]],
          ['supplus', [10944]],
          ['supset', [8835]],
          ['Supset', [8913]],
          ['supseteq', [8839]],
          ['supseteqq', [10950]],
          ['supsetneq', [8843]],
          ['supsetneqq', [10956]],
          ['supsim', [10952]],
          ['supsub', [10964]],
          ['supsup', [10966]],
          ['swarhk', [10534]],
          ['swarr', [8601]],
          ['swArr', [8665]],
          ['swarrow', [8601]],
          ['swnwar', [10538]],
          ['szlig', [223]],
          ['Tab', [9]],
          ['target', [8982]],
          ['Tau', [932]],
          ['tau', [964]],
          ['tbrk', [9140]],
          ['Tcaron', [356]],
          ['tcaron', [357]],
          ['Tcedil', [354]],
          ['tcedil', [355]],
          ['Tcy', [1058]],
          ['tcy', [1090]],
          ['tdot', [8411]],
          ['telrec', [8981]],
          ['Tfr', [120087]],
          ['tfr', [120113]],
          ['there4', [8756]],
          ['therefore', [8756]],
          ['Therefore', [8756]],
          ['Theta', [920]],
          ['theta', [952]],
          ['thetasym', [977]],
          ['thetav', [977]],
          ['thickapprox', [8776]],
          ['thicksim', [8764]],
          ['ThickSpace', [8287, 8202]],
          ['ThinSpace', [8201]],
          ['thinsp', [8201]],
          ['thkap', [8776]],
          ['thksim', [8764]],
          ['THORN', [222]],
          ['thorn', [254]],
          ['tilde', [732]],
          ['Tilde', [8764]],
          ['TildeEqual', [8771]],
          ['TildeFullEqual', [8773]],
          ['TildeTilde', [8776]],
          ['timesbar', [10801]],
          ['timesb', [8864]],
          ['times', [215]],
          ['timesd', [10800]],
          ['tint', [8749]],
          ['toea', [10536]],
          ['topbot', [9014]],
          ['topcir', [10993]],
          ['top', [8868]],
          ['Topf', [120139]],
          ['topf', [120165]],
          ['topfork', [10970]],
          ['tosa', [10537]],
          ['tprime', [8244]],
          ['trade', [8482]],
          ['TRADE', [8482]],
          ['triangle', [9653]],
          ['triangledown', [9663]],
          ['triangleleft', [9667]],
          ['trianglelefteq', [8884]],
          ['triangleq', [8796]],
          ['triangleright', [9657]],
          ['trianglerighteq', [8885]],
          ['tridot', [9708]],
          ['trie', [8796]],
          ['triminus', [10810]],
          ['TripleDot', [8411]],
          ['triplus', [10809]],
          ['trisb', [10701]],
          ['tritime', [10811]],
          ['trpezium', [9186]],
          ['Tscr', [119983]],
          ['tscr', [120009]],
          ['TScy', [1062]],
          ['tscy', [1094]],
          ['TSHcy', [1035]],
          ['tshcy', [1115]],
          ['Tstrok', [358]],
          ['tstrok', [359]],
          ['twixt', [8812]],
          ['twoheadleftarrow', [8606]],
          ['twoheadrightarrow', [8608]],
          ['Uacute', [218]],
          ['uacute', [250]],
          ['uarr', [8593]],
          ['Uarr', [8607]],
          ['uArr', [8657]],
          ['Uarrocir', [10569]],
          ['Ubrcy', [1038]],
          ['ubrcy', [1118]],
          ['Ubreve', [364]],
          ['ubreve', [365]],
          ['Ucirc', [219]],
          ['ucirc', [251]],
          ['Ucy', [1059]],
          ['ucy', [1091]],
          ['udarr', [8645]],
          ['Udblac', [368]],
          ['udblac', [369]],
          ['udhar', [10606]],
          ['ufisht', [10622]],
          ['Ufr', [120088]],
          ['ufr', [120114]],
          ['Ugrave', [217]],
          ['ugrave', [249]],
          ['uHar', [10595]],
          ['uharl', [8639]],
          ['uharr', [8638]],
          ['uhblk', [9600]],
          ['ulcorn', [8988]],
          ['ulcorner', [8988]],
          ['ulcrop', [8975]],
          ['ultri', [9720]],
          ['Umacr', [362]],
          ['umacr', [363]],
          ['uml', [168]],
          ['UnderBar', [95]],
          ['UnderBrace', [9183]],
          ['UnderBracket', [9141]],
          ['UnderParenthesis', [9181]],
          ['Union', [8899]],
          ['UnionPlus', [8846]],
          ['Uogon', [370]],
          ['uogon', [371]],
          ['Uopf', [120140]],
          ['uopf', [120166]],
          ['UpArrowBar', [10514]],
          ['uparrow', [8593]],
          ['UpArrow', [8593]],
          ['Uparrow', [8657]],
          ['UpArrowDownArrow', [8645]],
          ['updownarrow', [8597]],
          ['UpDownArrow', [8597]],
          ['Updownarrow', [8661]],
          ['UpEquilibrium', [10606]],
          ['upharpoonleft', [8639]],
          ['upharpoonright', [8638]],
          ['uplus', [8846]],
          ['UpperLeftArrow', [8598]],
          ['UpperRightArrow', [8599]],
          ['upsi', [965]],
          ['Upsi', [978]],
          ['upsih', [978]],
          ['Upsilon', [933]],
          ['upsilon', [965]],
          ['UpTeeArrow', [8613]],
          ['UpTee', [8869]],
          ['upuparrows', [8648]],
          ['urcorn', [8989]],
          ['urcorner', [8989]],
          ['urcrop', [8974]],
          ['Uring', [366]],
          ['uring', [367]],
          ['urtri', [9721]],
          ['Uscr', [119984]],
          ['uscr', [120010]],
          ['utdot', [8944]],
          ['Utilde', [360]],
          ['utilde', [361]],
          ['utri', [9653]],
          ['utrif', [9652]],
          ['uuarr', [8648]],
          ['Uuml', [220]],
          ['uuml', [252]],
          ['uwangle', [10663]],
          ['vangrt', [10652]],
          ['varepsilon', [1013]],
          ['varkappa', [1008]],
          ['varnothing', [8709]],
          ['varphi', [981]],
          ['varpi', [982]],
          ['varpropto', [8733]],
          ['varr', [8597]],
          ['vArr', [8661]],
          ['varrho', [1009]],
          ['varsigma', [962]],
          ['varsubsetneq', [8842, 65024]],
          ['varsubsetneqq', [10955, 65024]],
          ['varsupsetneq', [8843, 65024]],
          ['varsupsetneqq', [10956, 65024]],
          ['vartheta', [977]],
          ['vartriangleleft', [8882]],
          ['vartriangleright', [8883]],
          ['vBar', [10984]],
          ['Vbar', [10987]],
          ['vBarv', [10985]],
          ['Vcy', [1042]],
          ['vcy', [1074]],
          ['vdash', [8866]],
          ['vDash', [8872]],
          ['Vdash', [8873]],
          ['VDash', [8875]],
          ['Vdashl', [10982]],
          ['veebar', [8891]],
          ['vee', [8744]],
          ['Vee', [8897]],
          ['veeeq', [8794]],
          ['vellip', [8942]],
          ['verbar', [124]],
          ['Verbar', [8214]],
          ['vert', [124]],
          ['Vert', [8214]],
          ['VerticalBar', [8739]],
          ['VerticalLine', [124]],
          ['VerticalSeparator', [10072]],
          ['VerticalTilde', [8768]],
          ['VeryThinSpace', [8202]],
          ['Vfr', [120089]],
          ['vfr', [120115]],
          ['vltri', [8882]],
          ['vnsub', [8834, 8402]],
          ['vnsup', [8835, 8402]],
          ['Vopf', [120141]],
          ['vopf', [120167]],
          ['vprop', [8733]],
          ['vrtri', [8883]],
          ['Vscr', [119985]],
          ['vscr', [120011]],
          ['vsubnE', [10955, 65024]],
          ['vsubne', [8842, 65024]],
          ['vsupnE', [10956, 65024]],
          ['vsupne', [8843, 65024]],
          ['Vvdash', [8874]],
          ['vzigzag', [10650]],
          ['Wcirc', [372]],
          ['wcirc', [373]],
          ['wedbar', [10847]],
          ['wedge', [8743]],
          ['Wedge', [8896]],
          ['wedgeq', [8793]],
          ['weierp', [8472]],
          ['Wfr', [120090]],
          ['wfr', [120116]],
          ['Wopf', [120142]],
          ['wopf', [120168]],
          ['wp', [8472]],
          ['wr', [8768]],
          ['wreath', [8768]],
          ['Wscr', [119986]],
          ['wscr', [120012]],
          ['xcap', [8898]],
          ['xcirc', [9711]],
          ['xcup', [8899]],
          ['xdtri', [9661]],
          ['Xfr', [120091]],
          ['xfr', [120117]],
          ['xharr', [10231]],
          ['xhArr', [10234]],
          ['Xi', [926]],
          ['xi', [958]],
          ['xlarr', [10229]],
          ['xlArr', [10232]],
          ['xmap', [10236]],
          ['xnis', [8955]],
          ['xodot', [10752]],
          ['Xopf', [120143]],
          ['xopf', [120169]],
          ['xoplus', [10753]],
          ['xotime', [10754]],
          ['xrarr', [10230]],
          ['xrArr', [10233]],
          ['Xscr', [119987]],
          ['xscr', [120013]],
          ['xsqcup', [10758]],
          ['xuplus', [10756]],
          ['xutri', [9651]],
          ['xvee', [8897]],
          ['xwedge', [8896]],
          ['Yacute', [221]],
          ['yacute', [253]],
          ['YAcy', [1071]],
          ['yacy', [1103]],
          ['Ycirc', [374]],
          ['ycirc', [375]],
          ['Ycy', [1067]],
          ['ycy', [1099]],
          ['yen', [165]],
          ['Yfr', [120092]],
          ['yfr', [120118]],
          ['YIcy', [1031]],
          ['yicy', [1111]],
          ['Yopf', [120144]],
          ['yopf', [120170]],
          ['Yscr', [119988]],
          ['yscr', [120014]],
          ['YUcy', [1070]],
          ['yucy', [1102]],
          ['yuml', [255]],
          ['Yuml', [376]],
          ['Zacute', [377]],
          ['zacute', [378]],
          ['Zcaron', [381]],
          ['zcaron', [382]],
          ['Zcy', [1047]],
          ['zcy', [1079]],
          ['Zdot', [379]],
          ['zdot', [380]],
          ['zeetrf', [8488]],
          ['ZeroWidthSpace', [8203]],
          ['Zeta', [918]],
          ['zeta', [950]],
          ['zfr', [120119]],
          ['Zfr', [8488]],
          ['ZHcy', [1046]],
          ['zhcy', [1078]],
          ['zigrarr', [8669]],
          ['zopf', [120171]],
          ['Zopf', [8484]],
          ['Zscr', [119989]],
          ['zscr', [120015]],
          ['zwj', [8205]],
          ['zwnj', [8204]]
        ]
        var DECODE_ONLY_ENTITIES = [['NewLine', [10]]]
        var alphaIndex = {}
        var charIndex = {}
        createIndexes(alphaIndex, charIndex)
        var Html5Entities = /** @class */ (function() {
          function Html5Entities() {}
          Html5Entities.prototype.decode = function(str) {
            if (!str || !str.length) {
              return ''
            }
            return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
              var chr
              if (entity.charAt(0) === '#') {
                var code =
                  entity.charAt(1) === 'x'
                    ? parseInt(entity.substr(2).toLowerCase(), 16)
                    : parseInt(entity.substr(1))
                if (!isNaN(code) || code >= -32768) {
                  if (code <= 65535) {
                    chr = String.fromCharCode(code)
                  } else {
                    chr = surrogate_pairs_1.fromCodePoint(code)
                  }
                }
              } else {
                chr = alphaIndex[entity]
              }
              return chr || s
            })
          }
          Html5Entities.decode = function(str) {
            return new Html5Entities().decode(str)
          }
          Html5Entities.prototype.encode = function(str) {
            if (!str || !str.length) {
              return ''
            }
            var strLength = str.length
            var result = ''
            var i = 0
            while (i < strLength) {
              var charInfo = charIndex[str.charCodeAt(i)]
              if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)]
                if (alpha) {
                  i++
                } else {
                  alpha = charInfo['']
                }
                if (alpha) {
                  result += '&' + alpha + ';'
                  i++
                  continue
                }
              }
              result += str.charAt(i)
              i++
            }
            return result
          }
          Html5Entities.encode = function(str) {
            return new Html5Entities().encode(str)
          }
          Html5Entities.prototype.encodeNonUTF = function(str) {
            if (!str || !str.length) {
              return ''
            }
            var strLength = str.length
            var result = ''
            var i = 0
            while (i < strLength) {
              var c = str.charCodeAt(i)
              var charInfo = charIndex[c]
              if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)]
                if (alpha) {
                  i++
                } else {
                  alpha = charInfo['']
                }
                if (alpha) {
                  result += '&' + alpha + ';'
                  i++
                  continue
                }
              }
              if (c < 32 || c > 126) {
                if (
                  c >= surrogate_pairs_1.highSurrogateFrom &&
                  c <= surrogate_pairs_1.highSurrogateTo
                ) {
                  result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';'
                  i++
                } else {
                  result += '&#' + c + ';'
                }
              } else {
                result += str.charAt(i)
              }
              i++
            }
            return result
          }
          Html5Entities.encodeNonUTF = function(str) {
            return new Html5Entities().encodeNonUTF(str)
          }
          Html5Entities.prototype.encodeNonASCII = function(str) {
            if (!str || !str.length) {
              return ''
            }
            var strLength = str.length
            var result = ''
            var i = 0
            while (i < strLength) {
              var c = str.charCodeAt(i)
              if (c <= 255) {
                result += str[i++]
                continue
              }
              if (
                c >= surrogate_pairs_1.highSurrogateFrom &&
                c <= surrogate_pairs_1.highSurrogateTo
              ) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';'
                i += 2
              } else {
                result += '&#' + c + ';'
                i++
              }
            }
            return result
          }
          Html5Entities.encodeNonASCII = function(str) {
            return new Html5Entities().encodeNonASCII(str)
          }
          return Html5Entities
        })()
        exports.Html5Entities = Html5Entities
        function createIndexes(alphaIndex, charIndex) {
          var i = ENTITIES.length
          while (i--) {
            var _a = ENTITIES[i],
              alpha = _a[0],
              _b = _a[1],
              chr = _b[0],
              chr2 = _b[1]
            var addChar =
              chr < 32 ||
              chr > 126 ||
              chr === 62 ||
              chr === 60 ||
              chr === 38 ||
              chr === 34 ||
              chr === 39
            var charInfo = void 0
            if (addChar) {
              charInfo = charIndex[chr] = charIndex[chr] || {}
            }
            if (chr2) {
              alphaIndex[alpha] =
                String.fromCharCode(chr) + String.fromCharCode(chr2)
              addChar && (charInfo[chr2] = alpha)
            } else {
              alphaIndex[alpha] = String.fromCharCode(chr)
              addChar && (charInfo[''] = alpha)
            }
          }
          i = DECODE_ONLY_ENTITIES.length
          while (i--) {
            var _c = DECODE_ONLY_ENTITIES[i],
              alpha = _c[0],
              _d = _c[1],
              chr = _d[0],
              chr2 = _d[1]
            alphaIndex[alpha] =
              String.fromCharCode(chr) + (chr2 ? String.fromCharCode(chr2) : '')
          }
        }

        /***/
      },

    /***/ './node_modules/_html-entities@1.4.0@html-entities/lib/index.js':
      /*!**********************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/index.js ***!
  \**********************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        Object.defineProperty(exports, '__esModule', { value: true })
        var xml_entities_1 = __webpack_require__(
          /*! ./xml-entities */ './node_modules/_html-entities@1.4.0@html-entities/lib/xml-entities.js'
        )
        exports.XmlEntities = xml_entities_1.XmlEntities
        var html4_entities_1 = __webpack_require__(
          /*! ./html4-entities */ './node_modules/_html-entities@1.4.0@html-entities/lib/html4-entities.js'
        )
        exports.Html4Entities = html4_entities_1.Html4Entities
        var html5_entities_1 = __webpack_require__(
          /*! ./html5-entities */ './node_modules/_html-entities@1.4.0@html-entities/lib/html5-entities.js'
        )
        exports.Html5Entities = html5_entities_1.Html5Entities
        exports.AllHtmlEntities = html5_entities_1.Html5Entities

        /***/
      },

    /***/ './node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js':
      /*!********************************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js ***!
  \********************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        Object.defineProperty(exports, '__esModule', { value: true })
        exports.fromCodePoint =
          String.fromCodePoint ||
          function(astralCodePoint) {
            return String.fromCharCode(
              Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xd800,
              ((astralCodePoint - 0x10000) % 0x400) + 0xdc00
            )
          }
        exports.getCodePoint = String.prototype.codePointAt
          ? function(input, position) {
              return input.codePointAt(position)
            }
          : function(input, position) {
              return (
                (input.charCodeAt(position) - 0xd800) * 0x400 +
                input.charCodeAt(position + 1) -
                0xdc00 +
                0x10000
              )
            }
        exports.highSurrogateFrom = 0xd800
        exports.highSurrogateTo = 0xdbff

        /***/
      },

    /***/ './node_modules/_html-entities@1.4.0@html-entities/lib/xml-entities.js':
      /*!*****************************************************************************!*\
  !*** ./node_modules/_html-entities@1.4.0@html-entities/lib/xml-entities.js ***!
  \*****************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        Object.defineProperty(exports, '__esModule', { value: true })
        var surrogate_pairs_1 = __webpack_require__(
          /*! ./surrogate-pairs */ './node_modules/_html-entities@1.4.0@html-entities/lib/surrogate-pairs.js'
        )
        var ALPHA_INDEX = {
          '&lt': '<',
          '&gt': '>',
          '&quot': '"',
          '&apos': "'",
          '&amp': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&apos;': "'",
          '&amp;': '&'
        }
        var CHAR_INDEX = {
          60: 'lt',
          62: 'gt',
          34: 'quot',
          39: 'apos',
          38: 'amp'
        }
        var CHAR_S_INDEX = {
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&apos;',
          '&': '&amp;'
        }
        var XmlEntities = /** @class */ (function() {
          function XmlEntities() {}
          XmlEntities.prototype.encode = function(str) {
            if (!str || !str.length) {
              return ''
            }
            return str.replace(/[<>"'&]/g, function(s) {
              return CHAR_S_INDEX[s]
            })
          }
          XmlEntities.encode = function(str) {
            return new XmlEntities().encode(str)
          }
          XmlEntities.prototype.decode = function(str) {
            if (!str || !str.length) {
              return ''
            }
            return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
              if (s.charAt(1) === '#') {
                var code =
                  s.charAt(2).toLowerCase() === 'x'
                    ? parseInt(s.substr(3), 16)
                    : parseInt(s.substr(2))
                if (!isNaN(code) || code >= -32768) {
                  if (code <= 65535) {
                    return String.fromCharCode(code)
                  } else {
                    return surrogate_pairs_1.fromCodePoint(code)
                  }
                }
                return ''
              }
              return ALPHA_INDEX[s] || s
            })
          }
          XmlEntities.decode = function(str) {
            return new XmlEntities().decode(str)
          }
          XmlEntities.prototype.encodeNonUTF = function(str) {
            if (!str || !str.length) {
              return ''
            }
            var strLength = str.length
            var result = ''
            var i = 0
            while (i < strLength) {
              var c = str.charCodeAt(i)
              var alpha = CHAR_INDEX[c]
              if (alpha) {
                result += '&' + alpha + ';'
                i++
                continue
              }
              if (c < 32 || c > 126) {
                if (
                  c >= surrogate_pairs_1.highSurrogateFrom &&
                  c <= surrogate_pairs_1.highSurrogateTo
                ) {
                  result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';'
                  i++
                } else {
                  result += '&#' + c + ';'
                }
              } else {
                result += str.charAt(i)
              }
              i++
            }
            return result
          }
          XmlEntities.encodeNonUTF = function(str) {
            return new XmlEntities().encodeNonUTF(str)
          }
          XmlEntities.prototype.encodeNonASCII = function(str) {
            if (!str || !str.length) {
              return ''
            }
            var strLength = str.length
            var result = ''
            var i = 0
            while (i < strLength) {
              var c = str.charCodeAt(i)
              if (c <= 255) {
                result += str[i++]
                continue
              }
              if (
                c >= surrogate_pairs_1.highSurrogateFrom &&
                c <= surrogate_pairs_1.highSurrogateTo
              ) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';'
                i++
              } else {
                result += '&#' + c + ';'
              }
              i++
            }
            return result
          }
          XmlEntities.encodeNonASCII = function(str) {
            return new XmlEntities().encodeNonASCII(str)
          }
          return XmlEntities
        })()
        exports.XmlEntities = XmlEntities

        /***/
      },

    /***/ './node_modules/_loglevel@1.7.1@loglevel/lib/loglevel.js':
      /*!***************************************************************!*\
  !*** ./node_modules/_loglevel@1.7.1@loglevel/lib/loglevel.js ***!
  \***************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_RESULT__ /*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
        ;(function(root, definition) {
          'use strict'
          if (true) {
            !((__WEBPACK_AMD_DEFINE_FACTORY__ = definition),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
                ? __WEBPACK_AMD_DEFINE_FACTORY__.call(
                    exports,
                    __webpack_require__,
                    exports,
                    module
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
          } else {
          }
        })(this, function() {
          'use strict'

          // Slightly dubious tricks to cut down minimized file size
          var noop = function() {}
          var undefinedType = 'undefined'
          var isIE =
            typeof window !== undefinedType &&
            typeof window.navigator !== undefinedType &&
            /Trident\/|MSIE /.test(window.navigator.userAgent)

          var logMethods = ['trace', 'debug', 'info', 'warn', 'error']

          // Cross-browser bind equivalent that works at least back to IE6
          function bindMethod(obj, methodName) {
            var method = obj[methodName]
            if (typeof method.bind === 'function') {
              return method.bind(obj)
            } else {
              try {
                return Function.prototype.bind.call(method, obj)
              } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                  return Function.prototype.apply.apply(method, [
                    obj,
                    arguments
                  ])
                }
              }
            }
          }

          // Trace() doesn't print the message in IE, so for that case we need to wrap it
          function traceForIE() {
            if (console.log) {
              if (console.log.apply) {
                console.log.apply(console, arguments)
              } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [
                  console,
                  arguments
                ])
              }
            }
            if (console.trace) console.trace()
          }

          // Build the best logging method possible for this env
          // Wherever possible we want to bind, not wrap, to preserve stack traces
          function realMethod(methodName) {
            if (methodName === 'debug') {
              methodName = 'log'
            }

            if (typeof console === undefinedType) {
              return false // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
            } else if (methodName === 'trace' && isIE) {
              return traceForIE
            } else if (console[methodName] !== undefined) {
              return bindMethod(console, methodName)
            } else if (console.log !== undefined) {
              return bindMethod(console, 'log')
            } else {
              return noop
            }
          }

          // These private functions always need `this` to be set properly

          function replaceLoggingMethods(level, loggerName) {
            /*jshint validthis:true */
            for (var i = 0; i < logMethods.length; i++) {
              var methodName = logMethods[i]
              this[methodName] =
                i < level
                  ? noop
                  : this.methodFactory(methodName, level, loggerName)
            }

            // Define log.log as an alias for log.debug
            this.log = this.debug
          }

          // In old IE versions, the console isn't present until you first open it.
          // We build realMethod() replacements here that regenerate logging methods
          function enableLoggingWhenConsoleArrives(
            methodName,
            level,
            loggerName
          ) {
            return function() {
              if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName)
                this[methodName].apply(this, arguments)
              }
            }
          }

          // By default, we use closely bound real methods wherever possible, and
          // otherwise we wait for a console to appear, and then try again.
          function defaultMethodFactory(methodName, level, loggerName) {
            /*jshint validthis:true */
            return (
              realMethod(methodName) ||
              enableLoggingWhenConsoleArrives.apply(this, arguments)
            )
          }

          function Logger(name, defaultLevel, factory) {
            var self = this
            var currentLevel

            var storageKey = 'loglevel'
            if (typeof name === 'string') {
              storageKey += ':' + name
            } else if (typeof name === 'symbol') {
              storageKey = undefined
            }

            function persistLevelIfPossible(levelNum) {
              var levelName = (logMethods[levelNum] || 'silent').toUpperCase()

              if (typeof window === undefinedType || !storageKey) return

              // Use localStorage if available
              try {
                window.localStorage[storageKey] = levelName
                return
              } catch (ignore) {}

              // Use session cookie as fallback
              try {
                window.document.cookie =
                  encodeURIComponent(storageKey) + '=' + levelName + ';'
              } catch (ignore) {}
            }

            function getPersistedLevel() {
              var storedLevel

              if (typeof window === undefinedType || !storageKey) return

              try {
                storedLevel = window.localStorage[storageKey]
              } catch (ignore) {}

              // Fallback to cookies if local storage gives us nothing
              if (typeof storedLevel === undefinedType) {
                try {
                  var cookie = window.document.cookie
                  var location = cookie.indexOf(
                    encodeURIComponent(storageKey) + '='
                  )
                  if (location !== -1) {
                    storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1]
                  }
                } catch (ignore) {}
              }

              // If the stored level is not valid, treat it as if nothing was stored.
              if (self.levels[storedLevel] === undefined) {
                storedLevel = undefined
              }

              return storedLevel
            }

            /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

            self.name = name

            self.levels = {
              TRACE: 0,
              DEBUG: 1,
              INFO: 2,
              WARN: 3,
              ERROR: 4,
              SILENT: 5
            }

            self.methodFactory = factory || defaultMethodFactory

            self.getLevel = function() {
              return currentLevel
            }

            self.setLevel = function(level, persist) {
              if (
                typeof level === 'string' &&
                self.levels[level.toUpperCase()] !== undefined
              ) {
                level = self.levels[level.toUpperCase()]
              }
              if (
                typeof level === 'number' &&
                level >= 0 &&
                level <= self.levels.SILENT
              ) {
                currentLevel = level
                if (persist !== false) {
                  // defaults to true
                  persistLevelIfPossible(level)
                }
                replaceLoggingMethods.call(self, level, name)
                if (
                  typeof console === undefinedType &&
                  level < self.levels.SILENT
                ) {
                  return 'No console available for logging'
                }
              } else {
                throw 'log.setLevel() called with invalid level: ' + level
              }
            }

            self.setDefaultLevel = function(level) {
              if (!getPersistedLevel()) {
                self.setLevel(level, false)
              }
            }

            self.enableAll = function(persist) {
              self.setLevel(self.levels.TRACE, persist)
            }

            self.disableAll = function(persist) {
              self.setLevel(self.levels.SILENT, persist)
            }

            // Initialize with the right level
            var initialLevel = getPersistedLevel()
            if (initialLevel == null) {
              initialLevel = defaultLevel == null ? 'WARN' : defaultLevel
            }
            self.setLevel(initialLevel, false)
          }

          /*
     *
     * Top-level API
     *
     */

          var defaultLogger = new Logger()

          var _loggersByName = {}
          defaultLogger.getLogger = function getLogger(name) {
            if (
              (typeof name !== 'symbol' && typeof name !== 'string') ||
              name === ''
            ) {
              throw new TypeError(
                'You must supply a name when creating a logger.'
              )
            }

            var logger = _loggersByName[name]
            if (!logger) {
              logger = _loggersByName[name] = new Logger(
                name,
                defaultLogger.getLevel(),
                defaultLogger.methodFactory
              )
            }
            return logger
          }

          // Grab the current global log variable in case of overwrite
          var _log = typeof window !== undefinedType ? window.log : undefined
          defaultLogger.noConflict = function() {
            if (
              typeof window !== undefinedType &&
              window.log === defaultLogger
            ) {
              window.log = _log
            }

            return defaultLogger
          }

          defaultLogger.getLoggers = function getLoggers() {
            return _loggersByName
          }

          // ES6 default export, for compatibility
          defaultLogger['default'] = defaultLogger

          return defaultLogger
        })

        /***/
      },

    /***/ './node_modules/_punycode@1.4.1@punycode/punycode.js':
      /*!***********************************************************!*\
  !*** ./node_modules/_punycode@1.4.1@punycode/punycode.js ***!
  \***********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ ;(function(module, global) {
          var __WEBPACK_AMD_DEFINE_RESULT__ /*! https://mths.be/punycode v1.4.1 by @mathias */
          ;(function(root) {
            /** Detect free variables */
            var freeExports = true && exports && !exports.nodeType && exports
            var freeModule = true && module && !module.nodeType && module
            var freeGlobal = typeof global == 'object' && global
            if (
              freeGlobal.global === freeGlobal ||
              freeGlobal.window === freeGlobal ||
              freeGlobal.self === freeGlobal
            ) {
              root = freeGlobal
            }

            /**
             * The `punycode` object.
             * @name punycode
             * @type Object
             */
            var punycode,
              /** Highest positive signed 32-bit float value */
              maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
              /** Bootstring parameters */
              base = 36,
              tMin = 1,
              tMax = 26,
              skew = 38,
              damp = 700,
              initialBias = 72,
              initialN = 128, // 0x80
              delimiter = '-', // '\x2D'
              /** Regular expressions */
              regexPunycode = /^xn--/,
              regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
              regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
              /** Error messages */
              errors = {
                overflow: 'Overflow: input needs wider integers to process',
                'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                'invalid-input': 'Invalid input'
              },
              /** Convenience shortcuts */
              baseMinusTMin = base - tMin,
              floor = Math.floor,
              stringFromCharCode = String.fromCharCode,
              /** Temporary variable */
              key

            /*--------------------------------------------------------------------------*/

            /**
             * A generic error utility function.
             * @private
             * @param {String} type The error type.
             * @returns {Error} Throws a `RangeError` with the applicable error message.
             */
            function error(type) {
              throw new RangeError(errors[type])
            }

            /**
             * A generic `Array#map` utility function.
             * @private
             * @param {Array} array The array to iterate over.
             * @param {Function} callback The function that gets called for every array
             * item.
             * @returns {Array} A new array of values returned by the callback function.
             */
            function map(array, fn) {
              var length = array.length
              var result = []
              while (length--) {
                result[length] = fn(array[length])
              }
              return result
            }

            /**
             * A simple `Array#map`-like wrapper to work with domain name strings or email
             * addresses.
             * @private
             * @param {String} domain The domain name or email address.
             * @param {Function} callback The function that gets called for every
             * character.
             * @returns {Array} A new string of characters returned by the callback
             * function.
             */
            function mapDomain(string, fn) {
              var parts = string.split('@')
              var result = ''
              if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@'
                string = parts[1]
              }
              // Avoid `split(regex)` for IE8 compatibility. See #17.
              string = string.replace(regexSeparators, '\x2E')
              var labels = string.split('.')
              var encoded = map(labels, fn).join('.')
              return result + encoded
            }

            /**
             * Creates an array containing the numeric code points of each Unicode
             * character in the string. While JavaScript uses UCS-2 internally,
             * this function will convert a pair of surrogate halves (each of which
             * UCS-2 exposes as separate characters) into a single code point,
             * matching UTF-16.
             * @see `punycode.ucs2.encode`
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode.ucs2
             * @name decode
             * @param {String} string The Unicode input string (UCS-2).
             * @returns {Array} The new array of code points.
             */
            function ucs2decode(string) {
              var output = [],
                counter = 0,
                length = string.length,
                value,
                extra
              while (counter < length) {
                value = string.charCodeAt(counter++)
                if (value >= 0xd800 && value <= 0xdbff && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++)
                  if ((extra & 0xfc00) == 0xdc00) {
                    // low surrogate
                    output.push(
                      ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                    )
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value)
                    counter--
                  }
                } else {
                  output.push(value)
                }
              }
              return output
            }

            /**
             * Creates a string based on an array of numeric code points.
             * @see `punycode.ucs2.decode`
             * @memberOf punycode.ucs2
             * @name encode
             * @param {Array} codePoints The array of numeric code points.
             * @returns {String} The new Unicode string (UCS-2).
             */
            function ucs2encode(array) {
              return map(array, function(value) {
                var output = ''
                if (value > 0xffff) {
                  value -= 0x10000
                  output += stringFromCharCode(
                    ((value >>> 10) & 0x3ff) | 0xd800
                  )
                  value = 0xdc00 | (value & 0x3ff)
                }
                output += stringFromCharCode(value)
                return output
              }).join('')
            }

            /**
             * Converts a basic code point into a digit/integer.
             * @see `digitToBasic()`
             * @private
             * @param {Number} codePoint The basic numeric code point value.
             * @returns {Number} The numeric value of a basic code point (for use in
             * representing integers) in the range `0` to `base - 1`, or `base` if
             * the code point does not represent a value.
             */
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97
              }
              return base
            }

            /**
             * Converts a digit/integer into a basic code point.
             * @see `basicToDigit()`
             * @private
             * @param {Number} digit The numeric value of a basic code point.
             * @returns {Number} The basic code point whose value (when used for
             * representing integers) is `digit`, which needs to be in the range
             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
             * used; else, the lowercase form is used. The behavior is undefined
             * if `flag` is non-zero and `digit` has no uppercase form.
             */
            function digitToBasic(digit, flag) {
              //  0..25 map to ASCII a..z or A..Z
              // 26..35 map to ASCII 0..9
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
            }

            /**
             * Bias adaptation function as per section 3.4 of RFC 3492.
             * https://tools.ietf.org/html/rfc3492#section-3.4
             * @private
             */
            function adapt(delta, numPoints, firstTime) {
              var k = 0
              delta = firstTime ? floor(delta / damp) : delta >> 1
              delta += floor(delta / numPoints)
              for (
                ;
                /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
                k += base
              ) {
                delta = floor(delta / baseMinusTMin)
              }
              return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew))
            }

            /**
             * Converts a Punycode string of ASCII-only symbols to a string of Unicode
             * symbols.
             * @memberOf punycode
             * @param {String} input The Punycode string of ASCII-only symbols.
             * @returns {String} The resulting string of Unicode symbols.
             */
            function decode(input) {
              // Don't use UCS-2
              var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,
                /** Cached calculation results */
                baseMinusT

              // Handle the basic code points: let `basic` be the number of input code
              // points before the last delimiter, or `0` if there is none, then copy
              // the first basic code points to the output.

              basic = input.lastIndexOf(delimiter)
              if (basic < 0) {
                basic = 0
              }

              for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                  error('not-basic')
                }
                output.push(input.charCodeAt(j))
              }

              // Main decoding loop: start just after the last delimiter if any basic code
              // points were copied; start at the beginning otherwise.

              for (
                index = basic > 0 ? basic + 1 : 0;
                index < inputLength /* no final expression */;

              ) {
                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (
                  oldi = i, w = 1, k = base /* no condition */;
                  ;
                  k += base
                ) {
                  if (index >= inputLength) {
                    error('invalid-input')
                  }

                  digit = basicToDigit(input.charCodeAt(index++))

                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow')
                  }

                  i += digit * w
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias

                  if (digit < t) {
                    break
                  }

                  baseMinusT = base - t
                  if (w > floor(maxInt / baseMinusT)) {
                    error('overflow')
                  }

                  w *= baseMinusT
                }

                out = output.length + 1
                bias = adapt(i - oldi, out, oldi == 0)

                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                  error('overflow')
                }

                n += floor(i / out)
                i %= out

                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n)
              }

              return ucs2encode(output)
            }

            /**
             * Converts a string of Unicode symbols (e.g. a domain name label) to a
             * Punycode string of ASCII-only symbols.
             * @memberOf punycode
             * @param {String} input The string of Unicode symbols.
             * @returns {String} The resulting Punycode string of ASCII-only symbols.
             */
            function encode(input) {
              var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],
                /** `inputLength` will hold the number of code points in `input`. */
                inputLength,
                /** Cached calculation results */
                handledCPCountPlusOne,
                baseMinusT,
                qMinusT

              // Convert the input in UCS-2 to Unicode
              input = ucs2decode(input)

              // Cache the length
              inputLength = input.length

              // Initialize the state
              n = initialN
              delta = 0
              bias = initialBias

              // Handle the basic code points
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j]
                if (currentValue < 0x80) {
                  output.push(stringFromCharCode(currentValue))
                }
              }

              handledCPCount = basicLength = output.length

              // `handledCPCount` is the number of code points that have been handled;
              // `basicLength` is the number of basic code points.

              // Finish the basic string - if it is not empty - with a delimiter
              if (basicLength) {
                output.push(delimiter)
              }

              // Main encoding loop:
              while (handledCPCount < inputLength) {
                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j]
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue
                  }
                }

                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error('overflow')
                }

                delta += (m - n) * handledCPCountPlusOne
                n = m

                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j]

                  if (currentValue < n && ++delta > maxInt) {
                    error('overflow')
                  }

                  if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base /* no condition */; ; k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias
                      if (q < t) {
                        break
                      }
                      qMinusT = q - t
                      baseMinusT = base - t
                      output.push(
                        stringFromCharCode(
                          digitToBasic(t + (qMinusT % baseMinusT), 0)
                        )
                      )
                      q = floor(qMinusT / baseMinusT)
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)))
                    bias = adapt(
                      delta,
                      handledCPCountPlusOne,
                      handledCPCount == basicLength
                    )
                    delta = 0
                    ++handledCPCount
                  }
                }

                ++delta
                ++n
              }
              return output.join('')
            }

            /**
             * Converts a Punycode string representing a domain name or an email address
             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
             * it doesn't matter if you call it on a string that has already been
             * converted to Unicode.
             * @memberOf punycode
             * @param {String} input The Punycoded domain name or email address to
             * convert to Unicode.
             * @returns {String} The Unicode representation of the given Punycode
             * string.
             */
            function toUnicode(input) {
              return mapDomain(input, function(string) {
                return regexPunycode.test(string)
                  ? decode(string.slice(4).toLowerCase())
                  : string
              })
            }

            /**
             * Converts a Unicode string representing a domain name or an email address to
             * Punycode. Only the non-ASCII parts of the domain name will be converted,
             * i.e. it doesn't matter if you call it with a domain that's already in
             * ASCII.
             * @memberOf punycode
             * @param {String} input The domain name or email address to convert, as a
             * Unicode string.
             * @returns {String} The Punycode representation of the given domain name or
             * email address.
             */
            function toASCII(input) {
              return mapDomain(input, function(string) {
                return regexNonASCII.test(string)
                  ? 'xn--' + encode(string)
                  : string
              })
            }

            /*--------------------------------------------------------------------------*/

            /** Define the public API */
            punycode = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              version: '1.4.1',
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              ucs2: {
                decode: ucs2decode,
                encode: ucs2encode
              },
              decode: decode,
              encode: encode,
              toASCII: toASCII,
              toUnicode: toUnicode
            }

            /** Expose `punycode` */
            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (true) {
              !((__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return punycode
              }.call(exports, __webpack_require__, exports, module)),
              __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
            } else {
            }
          })(this)

          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../_webpack@4.46.0@webpack/buildin/module.js */ './node_modules/_webpack@4.46.0@webpack/buildin/module.js'
          )(module),
          __webpack_require__(
            /*! ./../_webpack@4.46.0@webpack/buildin/global.js */ './node_modules/_webpack@4.46.0@webpack/buildin/global.js'
          )
        ))

        /***/
      },

    /***/ './node_modules/_querystring-es3@0.2.1@querystring-es3/decode.js':
      /*!***********************************************************************!*\
  !*** ./node_modules/_querystring-es3@0.2.1@querystring-es3/decode.js ***!
  \***********************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop)
        }

        module.exports = function(qs, sep, eq, options) {
          sep = sep || '&'
          eq = eq || '='
          var obj = {}

          if (typeof qs !== 'string' || qs.length === 0) {
            return obj
          }

          var regexp = /\+/g
          qs = qs.split(sep)

          var maxKeys = 1000
          if (options && typeof options.maxKeys === 'number') {
            maxKeys = options.maxKeys
          }

          var len = qs.length
          // maxKeys <= 0 means that we should not limit keys count
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys
          }

          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, '%20'),
              idx = x.indexOf(eq),
              kstr,
              vstr,
              k,
              v

            if (idx >= 0) {
              kstr = x.substr(0, idx)
              vstr = x.substr(idx + 1)
            } else {
              kstr = x
              vstr = ''
            }

            k = decodeURIComponent(kstr)
            v = decodeURIComponent(vstr)

            if (!hasOwnProperty(obj, k)) {
              obj[k] = v
            } else if (isArray(obj[k])) {
              obj[k].push(v)
            } else {
              obj[k] = [obj[k], v]
            }
          }

          return obj
        }

        var isArray =
          Array.isArray ||
          function(xs) {
            return Object.prototype.toString.call(xs) === '[object Array]'
          }

        /***/
      },

    /***/ './node_modules/_querystring-es3@0.2.1@querystring-es3/encode.js':
      /*!***********************************************************************!*\
  !*** ./node_modules/_querystring-es3@0.2.1@querystring-es3/encode.js ***!
  \***********************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var stringifyPrimitive = function(v) {
          switch (typeof v) {
            case 'string':
              return v

            case 'boolean':
              return v ? 'true' : 'false'

            case 'number':
              return isFinite(v) ? v : ''

            default:
              return ''
          }
        }

        module.exports = function(obj, sep, eq, name) {
          sep = sep || '&'
          eq = eq || '='
          if (obj === null) {
            obj = undefined
          }

          if (typeof obj === 'object') {
            return map(objectKeys(obj), function(k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq
              if (isArray(obj[k])) {
                return map(obj[k], function(v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v))
                }).join(sep)
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]))
              }
            }).join(sep)
          }

          if (!name) return ''
          return (
            encodeURIComponent(stringifyPrimitive(name)) +
            eq +
            encodeURIComponent(stringifyPrimitive(obj))
          )
        }

        var isArray =
          Array.isArray ||
          function(xs) {
            return Object.prototype.toString.call(xs) === '[object Array]'
          }

        function map(xs, f) {
          if (xs.map) return xs.map(f)
          var res = []
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i))
          }
          return res
        }

        var objectKeys =
          Object.keys ||
          function(obj) {
            var res = []
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key)
            }
            return res
          }

        /***/
      },

    /***/ './node_modules/_querystring-es3@0.2.1@querystring-es3/index.js':
      /*!**********************************************************************!*\
  !*** ./node_modules/_querystring-es3@0.2.1@querystring-es3/index.js ***!
  \**********************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        exports.decode = exports.parse = __webpack_require__(
          /*! ./decode */ './node_modules/_querystring-es3@0.2.1@querystring-es3/decode.js'
        )
        exports.encode = exports.stringify = __webpack_require__(
          /*! ./encode */ './node_modules/_querystring-es3@0.2.1@querystring-es3/encode.js'
        )

        /***/
      },

    /***/ './node_modules/_sockjs-client@1.5.0@sockjs-client/dist/sockjs.js':
      /*!************************************************************************!*\
  !*** ./node_modules/_sockjs-client@1.5.0@sockjs-client/dist/sockjs.js ***!
  \************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ ;(function(global) {
          var require
          var require /* sockjs-client v1.5.0 | http://sockjs.org | MIT license */
          ;(function(f) {
            if (true) {
              module.exports = f()
            } else {
              var g
            }
          })(function() {
            var define, module, exports
            return (function() {
              function r(e, n, t) {
                function o(i, f) {
                  if (!n[i]) {
                    if (!e[i]) {
                      var c = 'function' == typeof require && require
                      if (!f && c) return require(i, !0)
                      if (u) return u(i, !0)
                      var a = new Error("Cannot find module '" + i + "'")
                      throw ((a.code = 'MODULE_NOT_FOUND'), a)
                    }
                    var p = (n[i] = { exports: {} })
                    e[i][0].call(
                      p.exports,
                      function(r) {
                        var n = e[i][1][r]
                        return o(n || r)
                      },
                      p,
                      p.exports,
                      r,
                      e,
                      n,
                      t
                    )
                  }
                  return n[i].exports
                }
                for (
                  var u = 'function' == typeof require && require, i = 0;
                  i < t.length;
                  i++
                )
                  o(t[i])
                return o
              }
              return r
            })()(
              {
                1: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      var transportList = require('./transport-list')

                      module.exports = require('./main')(transportList)

                      // TODO can't get rid of this until all servers do
                      if ('_sockjs_onload' in global) {
                        setTimeout(global._sockjs_onload, 1)
                      }
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  { './main': 14, './transport-list': 16 }
                ],
                2: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      Event = require('./event')

                    function CloseEvent() {
                      Event.call(this)
                      this.initEvent('close', false, false)
                      this.wasClean = false
                      this.code = 0
                      this.reason = ''
                    }

                    inherits(CloseEvent, Event)

                    module.exports = CloseEvent
                  },
                  { './event': 4, inherits: 57 }
                ],
                3: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      EventTarget = require('./eventtarget')

                    function EventEmitter() {
                      EventTarget.call(this)
                    }

                    inherits(EventEmitter, EventTarget)

                    EventEmitter.prototype.removeAllListeners = function(type) {
                      if (type) {
                        delete this._listeners[type]
                      } else {
                        this._listeners = {}
                      }
                    }

                    EventEmitter.prototype.once = function(type, listener) {
                      var self = this,
                        fired = false

                      function g() {
                        self.removeListener(type, g)

                        if (!fired) {
                          fired = true
                          listener.apply(this, arguments)
                        }
                      }

                      this.on(type, g)
                    }

                    EventEmitter.prototype.emit = function() {
                      var type = arguments[0]
                      var listeners = this._listeners[type]
                      if (!listeners) {
                        return
                      }
                      // equivalent of Array.prototype.slice.call(arguments, 1);
                      var l = arguments.length
                      var args = new Array(l - 1)
                      for (var ai = 1; ai < l; ai++) {
                        args[ai - 1] = arguments[ai]
                      }
                      for (var i = 0; i < listeners.length; i++) {
                        listeners[i].apply(this, args)
                      }
                    }

                    EventEmitter.prototype.on = EventEmitter.prototype.addListener =
                      EventTarget.prototype.addEventListener
                    EventEmitter.prototype.removeListener =
                      EventTarget.prototype.removeEventListener

                    module.exports.EventEmitter = EventEmitter
                  },
                  { './eventtarget': 5, inherits: 57 }
                ],
                4: [
                  function(require, module, exports) {
                    'use strict'

                    function Event(eventType) {
                      this.type = eventType
                    }

                    Event.prototype.initEvent = function(
                      eventType,
                      canBubble,
                      cancelable
                    ) {
                      this.type = eventType
                      this.bubbles = canBubble
                      this.cancelable = cancelable
                      this.timeStamp = +new Date()
                      return this
                    }

                    Event.prototype.stopPropagation = function() {}
                    Event.prototype.preventDefault = function() {}

                    Event.CAPTURING_PHASE = 1
                    Event.AT_TARGET = 2
                    Event.BUBBLING_PHASE = 3

                    module.exports = Event
                  },
                  {}
                ],
                5: [
                  function(require, module, exports) {
                    'use strict'

                    /* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

                    function EventTarget() {
                      this._listeners = {}
                    }

                    EventTarget.prototype.addEventListener = function(
                      eventType,
                      listener
                    ) {
                      if (!(eventType in this._listeners)) {
                        this._listeners[eventType] = []
                      }
                      var arr = this._listeners[eventType]
                      // #4
                      if (arr.indexOf(listener) === -1) {
                        // Make a copy so as not to interfere with a current dispatchEvent.
                        arr = arr.concat([listener])
                      }
                      this._listeners[eventType] = arr
                    }

                    EventTarget.prototype.removeEventListener = function(
                      eventType,
                      listener
                    ) {
                      var arr = this._listeners[eventType]
                      if (!arr) {
                        return
                      }
                      var idx = arr.indexOf(listener)
                      if (idx !== -1) {
                        if (arr.length > 1) {
                          // Make a copy so as not to interfere with a current dispatchEvent.
                          this._listeners[eventType] = arr
                            .slice(0, idx)
                            .concat(arr.slice(idx + 1))
                        } else {
                          delete this._listeners[eventType]
                        }
                        return
                      }
                    }

                    EventTarget.prototype.dispatchEvent = function() {
                      var event = arguments[0]
                      var t = event.type
                      // equivalent of Array.prototype.slice.call(arguments, 0);
                      var args =
                        arguments.length === 1
                          ? [event]
                          : Array.apply(null, arguments)
                      // TODO: This doesn't match the real behavior; per spec, onfoo get
                      // their place in line from the /first/ time they're set from
                      // non-null. Although WebKit bumps it to the end every time it's
                      // set.
                      if (this['on' + t]) {
                        this['on' + t].apply(this, args)
                      }
                      if (t in this._listeners) {
                        // Grab a reference to the listeners list. removeEventListener may alter the list.
                        var listeners = this._listeners[t]
                        for (var i = 0; i < listeners.length; i++) {
                          listeners[i].apply(this, args)
                        }
                      }
                    }

                    module.exports = EventTarget
                  },
                  {}
                ],
                6: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      Event = require('./event')

                    function TransportMessageEvent(data) {
                      Event.call(this)
                      this.initEvent('message', false, false)
                      this.data = data
                    }

                    inherits(TransportMessageEvent, Event)

                    module.exports = TransportMessageEvent
                  },
                  { './event': 4, inherits: 57 }
                ],
                7: [
                  function(require, module, exports) {
                    'use strict'

                    var JSON3 = require('json3'),
                      iframeUtils = require('./utils/iframe')

                    function FacadeJS(transport) {
                      this._transport = transport
                      transport.on('message', this._transportMessage.bind(this))
                      transport.on('close', this._transportClose.bind(this))
                    }

                    FacadeJS.prototype._transportClose = function(
                      code,
                      reason
                    ) {
                      iframeUtils.postMessage(
                        'c',
                        JSON3.stringify([code, reason])
                      )
                    }
                    FacadeJS.prototype._transportMessage = function(frame) {
                      iframeUtils.postMessage('t', frame)
                    }
                    FacadeJS.prototype._send = function(data) {
                      this._transport.send(data)
                    }
                    FacadeJS.prototype._close = function() {
                      this._transport.close()
                      this._transport.removeAllListeners()
                    }

                    module.exports = FacadeJS
                  },
                  { './utils/iframe': 47, json3: 58 }
                ],
                8: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var urlUtils = require('./utils/url'),
                        eventUtils = require('./utils/event'),
                        JSON3 = require('json3'),
                        FacadeJS = require('./facade'),
                        InfoIframeReceiver = require('./info-iframe-receiver'),
                        iframeUtils = require('./utils/iframe'),
                        loc = require('./location')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')(
                          'sockjs-client:iframe-bootstrap'
                        )
                      }

                      module.exports = function(SockJS, availableTransports) {
                        var transportMap = {}
                        availableTransports.forEach(function(at) {
                          if (at.facadeTransport) {
                            transportMap[at.facadeTransport.transportName] =
                              at.facadeTransport
                          }
                        })

                        // hard-coded for the info iframe
                        // TODO see if we can make this more dynamic
                        transportMap[
                          InfoIframeReceiver.transportName
                        ] = InfoIframeReceiver
                        var parentOrigin

                        /* eslint-disable camelcase */
                        SockJS.bootstrap_iframe = function() {
                          /* eslint-enable camelcase */
                          var facade
                          iframeUtils.currentWindowId = loc.hash.slice(1)
                          var onMessage = function(e) {
                            if (e.source !== parent) {
                              return
                            }
                            if (typeof parentOrigin === 'undefined') {
                              parentOrigin = e.origin
                            }
                            if (e.origin !== parentOrigin) {
                              return
                            }

                            var iframeMessage
                            try {
                              iframeMessage = JSON3.parse(e.data)
                            } catch (ignored) {
                              debug('bad json', e.data)
                              return
                            }

                            if (
                              iframeMessage.windowId !==
                              iframeUtils.currentWindowId
                            ) {
                              return
                            }
                            switch (iframeMessage.type) {
                              case 's':
                                var p
                                try {
                                  p = JSON3.parse(iframeMessage.data)
                                } catch (ignored) {
                                  debug('bad json', iframeMessage.data)
                                  break
                                }
                                var version = p[0]
                                var transport = p[1]
                                var transUrl = p[2]
                                var baseUrl = p[3]
                                debug(version, transport, transUrl, baseUrl)
                                // change this to semver logic
                                if (version !== SockJS.version) {
                                  throw new Error(
                                    'Incompatible SockJS! Main site uses:' +
                                      ' "' +
                                      version +
                                      '", the iframe:' +
                                      ' "' +
                                      SockJS.version +
                                      '".'
                                  )
                                }

                                if (
                                  !urlUtils.isOriginEqual(transUrl, loc.href) ||
                                  !urlUtils.isOriginEqual(baseUrl, loc.href)
                                ) {
                                  throw new Error(
                                    "Can't connect to different domain from within an " +
                                      'iframe. (' +
                                      loc.href +
                                      ', ' +
                                      transUrl +
                                      ', ' +
                                      baseUrl +
                                      ')'
                                  )
                                }
                                facade = new FacadeJS(
                                  new transportMap[transport](transUrl, baseUrl)
                                )
                                break
                              case 'm':
                                facade._send(iframeMessage.data)
                                break
                              case 'c':
                                if (facade) {
                                  facade._close()
                                }
                                facade = null
                                break
                            }
                          }

                          eventUtils.attachEvent('message', onMessage)

                          // Start
                          iframeUtils.postMessage('s')
                        }
                      }
                    }.call(this, { env: {} }))
                  },
                  {
                    './facade': 7,
                    './info-iframe-receiver': 10,
                    './location': 13,
                    './utils/event': 46,
                    './utils/iframe': 47,
                    './utils/url': 52,
                    debug: 55,
                    json3: 58
                  }
                ],
                9: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var EventEmitter = require('events').EventEmitter,
                        inherits = require('inherits'),
                        JSON3 = require('json3'),
                        objectUtils = require('./utils/object')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:info-ajax')
                      }

                      function InfoAjax(url, AjaxObject) {
                        EventEmitter.call(this)

                        var self = this
                        var t0 = +new Date()
                        this.xo = new AjaxObject('GET', url)

                        this.xo.once('finish', function(status, text) {
                          var info, rtt
                          if (status === 200) {
                            rtt = +new Date() - t0
                            if (text) {
                              try {
                                info = JSON3.parse(text)
                              } catch (e) {
                                debug('bad json', text)
                              }
                            }

                            if (!objectUtils.isObject(info)) {
                              info = {}
                            }
                          }
                          self.emit('finish', info, rtt)
                          self.removeAllListeners()
                        })
                      }

                      inherits(InfoAjax, EventEmitter)

                      InfoAjax.prototype.close = function() {
                        this.removeAllListeners()
                        this.xo.close()
                      }

                      module.exports = InfoAjax
                    }.call(this, { env: {} }))
                  },
                  {
                    './utils/object': 49,
                    debug: 55,
                    events: 3,
                    inherits: 57,
                    json3: 58
                  }
                ],
                10: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      EventEmitter = require('events').EventEmitter,
                      JSON3 = require('json3'),
                      XHRLocalObject = require('./transport/sender/xhr-local'),
                      InfoAjax = require('./info-ajax')

                    function InfoReceiverIframe(transUrl) {
                      var self = this
                      EventEmitter.call(this)

                      this.ir = new InfoAjax(transUrl, XHRLocalObject)
                      this.ir.once('finish', function(info, rtt) {
                        self.ir = null
                        self.emit('message', JSON3.stringify([info, rtt]))
                      })
                    }

                    inherits(InfoReceiverIframe, EventEmitter)

                    InfoReceiverIframe.transportName = 'iframe-info-receiver'

                    InfoReceiverIframe.prototype.close = function() {
                      if (this.ir) {
                        this.ir.close()
                        this.ir = null
                      }
                      this.removeAllListeners()
                    }

                    module.exports = InfoReceiverIframe
                  },
                  {
                    './info-ajax': 9,
                    './transport/sender/xhr-local': 37,
                    events: 3,
                    inherits: 57,
                    json3: 58
                  }
                ],
                11: [
                  function(require, module, exports) {
                    ;(function(process, global) {
                      'use strict'

                      var EventEmitter = require('events').EventEmitter,
                        inherits = require('inherits'),
                        JSON3 = require('json3'),
                        utils = require('./utils/event'),
                        IframeTransport = require('./transport/iframe'),
                        InfoReceiverIframe = require('./info-iframe-receiver')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:info-iframe')
                      }

                      function InfoIframe(baseUrl, url) {
                        var self = this
                        EventEmitter.call(this)

                        var go = function() {
                          var ifr = (self.ifr = new IframeTransport(
                            InfoReceiverIframe.transportName,
                            url,
                            baseUrl
                          ))

                          ifr.once('message', function(msg) {
                            if (msg) {
                              var d
                              try {
                                d = JSON3.parse(msg)
                              } catch (e) {
                                debug('bad json', msg)
                                self.emit('finish')
                                self.close()
                                return
                              }

                              var info = d[0],
                                rtt = d[1]
                              self.emit('finish', info, rtt)
                            }
                            self.close()
                          })

                          ifr.once('close', function() {
                            self.emit('finish')
                            self.close()
                          })
                        }

                        // TODO this seems the same as the 'needBody' from transports
                        if (!global.document.body) {
                          utils.attachEvent('load', go)
                        } else {
                          go()
                        }
                      }

                      inherits(InfoIframe, EventEmitter)

                      InfoIframe.enabled = function() {
                        return IframeTransport.enabled()
                      }

                      InfoIframe.prototype.close = function() {
                        if (this.ifr) {
                          this.ifr.close()
                        }
                        this.removeAllListeners()
                        this.ifr = null
                      }

                      module.exports = InfoIframe
                    }.call(
                      this,
                      { env: {} },
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {
                    './info-iframe-receiver': 10,
                    './transport/iframe': 22,
                    './utils/event': 46,
                    debug: 55,
                    events: 3,
                    inherits: 57,
                    json3: 58
                  }
                ],
                12: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var EventEmitter = require('events').EventEmitter,
                        inherits = require('inherits'),
                        urlUtils = require('./utils/url'),
                        XDR = require('./transport/sender/xdr'),
                        XHRCors = require('./transport/sender/xhr-cors'),
                        XHRLocal = require('./transport/sender/xhr-local'),
                        XHRFake = require('./transport/sender/xhr-fake'),
                        InfoIframe = require('./info-iframe'),
                        InfoAjax = require('./info-ajax')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:info-receiver')
                      }

                      function InfoReceiver(baseUrl, urlInfo) {
                        debug(baseUrl)
                        var self = this
                        EventEmitter.call(this)

                        setTimeout(function() {
                          self.doXhr(baseUrl, urlInfo)
                        }, 0)
                      }

                      inherits(InfoReceiver, EventEmitter)

                      // TODO this is currently ignoring the list of available transports and the whitelist

                      InfoReceiver._getReceiver = function(
                        baseUrl,
                        url,
                        urlInfo
                      ) {
                        // determine method of CORS support (if needed)
                        if (urlInfo.sameOrigin) {
                          return new InfoAjax(url, XHRLocal)
                        }
                        if (XHRCors.enabled) {
                          return new InfoAjax(url, XHRCors)
                        }
                        if (XDR.enabled && urlInfo.sameScheme) {
                          return new InfoAjax(url, XDR)
                        }
                        if (InfoIframe.enabled()) {
                          return new InfoIframe(baseUrl, url)
                        }
                        return new InfoAjax(url, XHRFake)
                      }

                      InfoReceiver.prototype.doXhr = function(
                        baseUrl,
                        urlInfo
                      ) {
                        var self = this,
                          url = urlUtils.addPath(baseUrl, '/info')
                        debug('doXhr', url)

                        this.xo = InfoReceiver._getReceiver(
                          baseUrl,
                          url,
                          urlInfo
                        )

                        this.timeoutRef = setTimeout(function() {
                          debug('timeout')
                          self._cleanup(false)
                          self.emit('finish')
                        }, InfoReceiver.timeout)

                        this.xo.once('finish', function(info, rtt) {
                          debug('finish', info, rtt)
                          self._cleanup(true)
                          self.emit('finish', info, rtt)
                        })
                      }

                      InfoReceiver.prototype._cleanup = function(wasClean) {
                        debug('_cleanup')
                        clearTimeout(this.timeoutRef)
                        this.timeoutRef = null
                        if (!wasClean && this.xo) {
                          this.xo.close()
                        }
                        this.xo = null
                      }

                      InfoReceiver.prototype.close = function() {
                        debug('close')
                        this.removeAllListeners()
                        this._cleanup(false)
                      }

                      InfoReceiver.timeout = 8000

                      module.exports = InfoReceiver
                    }.call(this, { env: {} }))
                  },
                  {
                    './info-ajax': 9,
                    './info-iframe': 11,
                    './transport/sender/xdr': 34,
                    './transport/sender/xhr-cors': 35,
                    './transport/sender/xhr-fake': 36,
                    './transport/sender/xhr-local': 37,
                    './utils/url': 52,
                    debug: 55,
                    events: 3,
                    inherits: 57
                  }
                ],
                13: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      module.exports = global.location || {
                        origin: 'http://localhost:80',
                        protocol: 'http:',
                        host: 'localhost',
                        port: 80,
                        href: 'http://localhost/',
                        hash: ''
                      }
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {}
                ],
                14: [
                  function(require, module, exports) {
                    ;(function(process, global) {
                      'use strict'

                      require('./shims')

                      var URL = require('url-parse'),
                        inherits = require('inherits'),
                        JSON3 = require('json3'),
                        random = require('./utils/random'),
                        escape = require('./utils/escape'),
                        urlUtils = require('./utils/url'),
                        eventUtils = require('./utils/event'),
                        transport = require('./utils/transport'),
                        objectUtils = require('./utils/object'),
                        browser = require('./utils/browser'),
                        log = require('./utils/log'),
                        Event = require('./event/event'),
                        EventTarget = require('./event/eventtarget'),
                        loc = require('./location'),
                        CloseEvent = require('./event/close'),
                        TransportMessageEvent = require('./event/trans-message'),
                        InfoReceiver = require('./info-receiver')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:main')
                      }

                      var transports

                      // follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
                      function SockJS(url, protocols, options) {
                        if (!(this instanceof SockJS)) {
                          return new SockJS(url, protocols, options)
                        }
                        if (arguments.length < 1) {
                          throw new TypeError(
                            "Failed to construct 'SockJS: 1 argument required, but only 0 present"
                          )
                        }
                        EventTarget.call(this)

                        this.readyState = SockJS.CONNECTING
                        this.extensions = ''
                        this.protocol = ''

                        // non-standard extension
                        options = options || {}
                        if (options.protocols_whitelist) {
                          log.warn(
                            "'protocols_whitelist' is DEPRECATED. Use 'transports' instead."
                          )
                        }
                        this._transportsWhitelist = options.transports
                        this._transportOptions = options.transportOptions || {}
                        this._timeout = options.timeout || 0

                        var sessionId = options.sessionId || 8
                        if (typeof sessionId === 'function') {
                          this._generateSessionId = sessionId
                        } else if (typeof sessionId === 'number') {
                          this._generateSessionId = function() {
                            return random.string(sessionId)
                          }
                        } else {
                          throw new TypeError(
                            'If sessionId is used in the options, it needs to be a number or a function.'
                          )
                        }

                        this._server =
                          options.server || random.numberString(1000)

                        // Step 1 of WS spec - parse and validate the url. Issue #8
                        var parsedUrl = new URL(url)
                        if (!parsedUrl.host || !parsedUrl.protocol) {
                          throw new SyntaxError(
                            "The URL '" + url + "' is invalid"
                          )
                        } else if (parsedUrl.hash) {
                          throw new SyntaxError(
                            'The URL must not contain a fragment'
                          )
                        } else if (
                          parsedUrl.protocol !== 'http:' &&
                          parsedUrl.protocol !== 'https:'
                        ) {
                          throw new SyntaxError(
                            "The URL's scheme must be either 'http:' or 'https:'. '" +
                              parsedUrl.protocol +
                              "' is not allowed."
                          )
                        }

                        var secure = parsedUrl.protocol === 'https:'
                        // Step 2 - don't allow secure origin with an insecure protocol
                        if (loc.protocol === 'https:' && !secure) {
                          // exception is 127.0.0.0/8 and ::1 urls
                          if (!urlUtils.isLoopbackAddr(parsedUrl.hostname)) {
                            throw new Error(
                              'SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS'
                            )
                          }
                        }

                        // Step 3 - check port access - no need here
                        // Step 4 - parse protocols argument
                        if (!protocols) {
                          protocols = []
                        } else if (!Array.isArray(protocols)) {
                          protocols = [protocols]
                        }

                        // Step 5 - check protocols argument
                        var sortedProtocols = protocols.sort()
                        sortedProtocols.forEach(function(proto, i) {
                          if (!proto) {
                            throw new SyntaxError(
                              "The protocols entry '" + proto + "' is invalid."
                            )
                          }
                          if (
                            i < sortedProtocols.length - 1 &&
                            proto === sortedProtocols[i + 1]
                          ) {
                            throw new SyntaxError(
                              "The protocols entry '" +
                                proto +
                                "' is duplicated."
                            )
                          }
                        })

                        // Step 6 - convert origin
                        var o = urlUtils.getOrigin(loc.href)
                        this._origin = o ? o.toLowerCase() : null

                        // remove the trailing slash
                        parsedUrl.set(
                          'pathname',
                          parsedUrl.pathname.replace(/\/+$/, '')
                        )

                        // store the sanitized url
                        this.url = parsedUrl.href
                        debug('using url', this.url)

                        // Step 7 - start connection in background
                        // obtain server info
                        // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
                        this._urlInfo = {
                          nullOrigin: !browser.hasDomain(),
                          sameOrigin: urlUtils.isOriginEqual(
                            this.url,
                            loc.href
                          ),
                          sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
                        }

                        this._ir = new InfoReceiver(this.url, this._urlInfo)
                        this._ir.once('finish', this._receiveInfo.bind(this))
                      }

                      inherits(SockJS, EventTarget)

                      function userSetCode(code) {
                        return code === 1000 || (code >= 3000 && code <= 4999)
                      }

                      SockJS.prototype.close = function(code, reason) {
                        // Step 1
                        if (code && !userSetCode(code)) {
                          throw new Error('InvalidAccessError: Invalid code')
                        }
                        // Step 2.4 states the max is 123 bytes, but we are just checking length
                        if (reason && reason.length > 123) {
                          throw new SyntaxError(
                            'reason argument has an invalid length'
                          )
                        }

                        // Step 3.1
                        if (
                          this.readyState === SockJS.CLOSING ||
                          this.readyState === SockJS.CLOSED
                        ) {
                          return
                        }

                        // TODO look at docs to determine how to set this
                        var wasClean = true
                        this._close(
                          code || 1000,
                          reason || 'Normal closure',
                          wasClean
                        )
                      }

                      SockJS.prototype.send = function(data) {
                        // #13 - convert anything non-string to string
                        // TODO this currently turns objects into [object Object]
                        if (typeof data !== 'string') {
                          data = '' + data
                        }
                        if (this.readyState === SockJS.CONNECTING) {
                          throw new Error(
                            'InvalidStateError: The connection has not been established yet'
                          )
                        }
                        if (this.readyState !== SockJS.OPEN) {
                          return
                        }
                        this._transport.send(escape.quote(data))
                      }

                      SockJS.version = require('./version')

                      SockJS.CONNECTING = 0
                      SockJS.OPEN = 1
                      SockJS.CLOSING = 2
                      SockJS.CLOSED = 3

                      SockJS.prototype._receiveInfo = function(info, rtt) {
                        debug('_receiveInfo', rtt)
                        this._ir = null
                        if (!info) {
                          this._close(1002, 'Cannot connect to server')
                          return
                        }

                        // establish a round-trip timeout (RTO) based on the
                        // round-trip time (RTT)
                        this._rto = this.countRTO(rtt)
                        // allow server to override url used for the actual transport
                        this._transUrl = info.base_url
                          ? info.base_url
                          : this.url
                        info = objectUtils.extend(info, this._urlInfo)
                        debug('info', info)
                        // determine list of desired and supported transports
                        var enabledTransports = transports.filterToEnabled(
                          this._transportsWhitelist,
                          info
                        )
                        this._transports = enabledTransports.main
                        debug(this._transports.length + ' enabled transports')

                        this._connect()
                      }

                      SockJS.prototype._connect = function() {
                        for (
                          var Transport = this._transports.shift();
                          Transport;
                          Transport = this._transports.shift()
                        ) {
                          debug('attempt', Transport.transportName)
                          if (Transport.needBody) {
                            if (
                              !global.document.body ||
                              (typeof global.document.readyState !==
                                'undefined' &&
                                global.document.readyState !== 'complete' &&
                                global.document.readyState !== 'interactive')
                            ) {
                              debug('waiting for body')
                              this._transports.unshift(Transport)
                              eventUtils.attachEvent(
                                'load',
                                this._connect.bind(this)
                              )
                              return
                            }
                          }

                          // calculate timeout based on RTO and round trips. Default to 5s
                          var timeoutMs = Math.max(
                            this._timeout,
                            this._rto * Transport.roundTrips || 5000
                          )
                          this._transportTimeoutId = setTimeout(
                            this._transportTimeout.bind(this),
                            timeoutMs
                          )
                          debug('using timeout', timeoutMs)

                          var transportUrl = urlUtils.addPath(
                            this._transUrl,
                            '/' + this._server + '/' + this._generateSessionId()
                          )
                          var options = this._transportOptions[
                            Transport.transportName
                          ]
                          debug('transport url', transportUrl)
                          var transportObj = new Transport(
                            transportUrl,
                            this._transUrl,
                            options
                          )
                          transportObj.on(
                            'message',
                            this._transportMessage.bind(this)
                          )
                          transportObj.once(
                            'close',
                            this._transportClose.bind(this)
                          )
                          transportObj.transportName = Transport.transportName
                          this._transport = transportObj

                          return
                        }
                        this._close(2000, 'All transports failed', false)
                      }

                      SockJS.prototype._transportTimeout = function() {
                        debug('_transportTimeout')
                        if (this.readyState === SockJS.CONNECTING) {
                          if (this._transport) {
                            this._transport.close()
                          }

                          this._transportClose(2007, 'Transport timed out')
                        }
                      }

                      SockJS.prototype._transportMessage = function(msg) {
                        debug('_transportMessage', msg)
                        var self = this,
                          type = msg.slice(0, 1),
                          content = msg.slice(1),
                          payload

                        // first check for messages that don't need a payload
                        switch (type) {
                          case 'o':
                            this._open()
                            return
                          case 'h':
                            this.dispatchEvent(new Event('heartbeat'))
                            debug('heartbeat', this.transport)
                            return
                        }

                        if (content) {
                          try {
                            payload = JSON3.parse(content)
                          } catch (e) {
                            debug('bad json', content)
                          }
                        }

                        if (typeof payload === 'undefined') {
                          debug('empty payload', content)
                          return
                        }

                        switch (type) {
                          case 'a':
                            if (Array.isArray(payload)) {
                              payload.forEach(function(p) {
                                debug('message', self.transport, p)
                                self.dispatchEvent(new TransportMessageEvent(p))
                              })
                            }
                            break
                          case 'm':
                            debug('message', this.transport, payload)
                            this.dispatchEvent(
                              new TransportMessageEvent(payload)
                            )
                            break
                          case 'c':
                            if (
                              Array.isArray(payload) &&
                              payload.length === 2
                            ) {
                              this._close(payload[0], payload[1], true)
                            }
                            break
                        }
                      }

                      SockJS.prototype._transportClose = function(
                        code,
                        reason
                      ) {
                        debug('_transportClose', this.transport, code, reason)
                        if (this._transport) {
                          this._transport.removeAllListeners()
                          this._transport = null
                          this.transport = null
                        }

                        if (
                          !userSetCode(code) &&
                          code !== 2000 &&
                          this.readyState === SockJS.CONNECTING
                        ) {
                          this._connect()
                          return
                        }

                        this._close(code, reason)
                      }

                      SockJS.prototype._open = function() {
                        debug(
                          '_open',
                          this._transport && this._transport.transportName,
                          this.readyState
                        )
                        if (this.readyState === SockJS.CONNECTING) {
                          if (this._transportTimeoutId) {
                            clearTimeout(this._transportTimeoutId)
                            this._transportTimeoutId = null
                          }
                          this.readyState = SockJS.OPEN
                          this.transport = this._transport.transportName
                          this.dispatchEvent(new Event('open'))
                          debug('connected', this.transport)
                        } else {
                          // The server might have been restarted, and lost track of our
                          // connection.
                          this._close(1006, 'Server lost session')
                        }
                      }

                      SockJS.prototype._close = function(
                        code,
                        reason,
                        wasClean
                      ) {
                        debug(
                          '_close',
                          this.transport,
                          code,
                          reason,
                          wasClean,
                          this.readyState
                        )
                        var forceFail = false

                        if (this._ir) {
                          forceFail = true
                          this._ir.close()
                          this._ir = null
                        }
                        if (this._transport) {
                          this._transport.close()
                          this._transport = null
                          this.transport = null
                        }

                        if (this.readyState === SockJS.CLOSED) {
                          throw new Error(
                            'InvalidStateError: SockJS has already been closed'
                          )
                        }

                        this.readyState = SockJS.CLOSING
                        setTimeout(
                          function() {
                            this.readyState = SockJS.CLOSED

                            if (forceFail) {
                              this.dispatchEvent(new Event('error'))
                            }

                            var e = new CloseEvent('close')
                            e.wasClean = wasClean || false
                            e.code = code || 1000
                            e.reason = reason

                            this.dispatchEvent(e)
                            this.onmessage = this.onclose = this.onerror = null
                            debug('disconnected')
                          }.bind(this),
                          0
                        )
                      }

                      // See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
                      // and RFC 2988.
                      SockJS.prototype.countRTO = function(rtt) {
                        // In a local environment, when using IE8/9 and the `jsonp-polling`
                        // transport the time needed to establish a connection (the time that pass
                        // from the opening of the transport to the call of `_dispatchOpen`) is
                        // around 200msec (the lower bound used in the article above) and this
                        // causes spurious timeouts. For this reason we calculate a value slightly
                        // larger than that used in the article.
                        if (rtt > 100) {
                          return 4 * rtt // rto > 400msec
                        }
                        return 300 + rtt // 300msec < rto <= 400msec
                      }

                      module.exports = function(availableTransports) {
                        transports = transport(availableTransports)
                        require('./iframe-bootstrap')(
                          SockJS,
                          availableTransports
                        )
                        return SockJS
                      }
                    }.call(
                      this,
                      { env: {} },
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {
                    './event/close': 2,
                    './event/event': 4,
                    './event/eventtarget': 5,
                    './event/trans-message': 6,
                    './iframe-bootstrap': 8,
                    './info-receiver': 12,
                    './location': 13,
                    './shims': 15,
                    './utils/browser': 44,
                    './utils/escape': 45,
                    './utils/event': 46,
                    './utils/log': 48,
                    './utils/object': 49,
                    './utils/random': 50,
                    './utils/transport': 51,
                    './utils/url': 52,
                    './version': 53,
                    debug: 55,
                    inherits: 57,
                    json3: 58,
                    'url-parse': 61
                  }
                ],
                15: [
                  function(require, module, exports) {
                    /* eslint-disable */
                    /* jscs: disable */
                    'use strict'

                    // pulled specific shims from https://github.com/es-shims/es5-shim

                    var ArrayPrototype = Array.prototype
                    var ObjectPrototype = Object.prototype
                    var FunctionPrototype = Function.prototype
                    var StringPrototype = String.prototype
                    var array_slice = ArrayPrototype.slice

                    var _toString = ObjectPrototype.toString
                    var isFunction = function(val) {
                      return (
                        ObjectPrototype.toString.call(val) ===
                        '[object Function]'
                      )
                    }
                    var isArray = function isArray(obj) {
                      return _toString.call(obj) === '[object Array]'
                    }
                    var isString = function isString(obj) {
                      return _toString.call(obj) === '[object String]'
                    }

                    var supportsDescriptors =
                      Object.defineProperty &&
                      (function() {
                        try {
                          Object.defineProperty({}, 'x', {})
                          return true
                        } catch (e) {
                          /* this is ES3 */
                          return false
                        }
                      })()

                    // Define configurable, writable and non-enumerable props
                    // if they don't exist.
                    var defineProperty
                    if (supportsDescriptors) {
                      defineProperty = function(
                        object,
                        name,
                        method,
                        forceAssign
                      ) {
                        if (!forceAssign && name in object) {
                          return
                        }
                        Object.defineProperty(object, name, {
                          configurable: true,
                          enumerable: false,
                          writable: true,
                          value: method
                        })
                      }
                    } else {
                      defineProperty = function(
                        object,
                        name,
                        method,
                        forceAssign
                      ) {
                        if (!forceAssign && name in object) {
                          return
                        }
                        object[name] = method
                      }
                    }
                    var defineProperties = function(object, map, forceAssign) {
                      for (var name in map) {
                        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
                          defineProperty(object, name, map[name], forceAssign)
                        }
                      }
                    }

                    var toObject = function(o) {
                      if (o == null) {
                        // this matches both null and undefined
                        throw new TypeError("can't convert " + o + ' to object')
                      }
                      return Object(o)
                    }

                    //
                    // Util
                    // ======
                    //

                    // ES5 9.4
                    // http://es5.github.com/#x9.4
                    // http://jsperf.com/to-integer

                    function toInteger(num) {
                      var n = +num
                      if (n !== n) {
                        // isNaN
                        n = 0
                      } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
                        n = (n > 0 || -1) * Math.floor(Math.abs(n))
                      }
                      return n
                    }

                    function ToUint32(x) {
                      return x >>> 0
                    }

                    //
                    // Function
                    // ========
                    //

                    // ES-5 15.3.4.5
                    // http://es5.github.com/#x15.3.4.5

                    function Empty() {}

                    defineProperties(FunctionPrototype, {
                      bind: function bind(that) {
                        // .length is 1
                        // 1. Let Target be the this value.
                        var target = this
                        // 2. If IsCallable(Target) is false, throw a TypeError exception.
                        if (!isFunction(target)) {
                          throw new TypeError(
                            'Function.prototype.bind called on incompatible ' +
                              target
                          )
                        }
                        // 3. Let A be a new (possibly empty) internal list of all of the
                        //   argument values provided after thisArg (arg1, arg2 etc), in order.
                        // XXX slicedArgs will stand in for "A" if used
                        var args = array_slice.call(arguments, 1) // for normal call
                        // 4. Let F be a new native ECMAScript object.
                        // 11. Set the [[Prototype]] internal property of F to the standard
                        //   built-in Function prototype object as specified in 15.3.3.1.
                        // 12. Set the [[Call]] internal property of F as described in
                        //   15.3.4.5.1.
                        // 13. Set the [[Construct]] internal property of F as described in
                        //   15.3.4.5.2.
                        // 14. Set the [[HasInstance]] internal property of F as described in
                        //   15.3.4.5.3.
                        var binder = function() {
                          if (this instanceof bound) {
                            // 15.3.4.5.2 [[Construct]]
                            // When the [[Construct]] internal method of a function object,
                            // F that was created using the bind function is called with a
                            // list of arguments ExtraArgs, the following steps are taken:
                            // 1. Let target be the value of F's [[TargetFunction]]
                            //   internal property.
                            // 2. If target has no [[Construct]] internal method, a
                            //   TypeError exception is thrown.
                            // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                            //   property.
                            // 4. Let args be a new list containing the same values as the
                            //   list boundArgs in the same order followed by the same
                            //   values as the list ExtraArgs in the same order.
                            // 5. Return the result of calling the [[Construct]] internal
                            //   method of target providing args as the arguments.

                            var result = target.apply(
                              this,
                              args.concat(array_slice.call(arguments))
                            )
                            if (Object(result) === result) {
                              return result
                            }
                            return this
                          } else {
                            // 15.3.4.5.1 [[Call]]
                            // When the [[Call]] internal method of a function object, F,
                            // which was created using the bind function is called with a
                            // this value and a list of arguments ExtraArgs, the following
                            // steps are taken:
                            // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                            //   property.
                            // 2. Let boundThis be the value of F's [[BoundThis]] internal
                            //   property.
                            // 3. Let target be the value of F's [[TargetFunction]] internal
                            //   property.
                            // 4. Let args be a new list containing the same values as the
                            //   list boundArgs in the same order followed by the same
                            //   values as the list ExtraArgs in the same order.
                            // 5. Return the result of calling the [[Call]] internal method
                            //   of target providing boundThis as the this value and
                            //   providing args as the arguments.

                            // equiv: target.call(this, ...boundArgs, ...args)
                            return target.apply(
                              that,
                              args.concat(array_slice.call(arguments))
                            )
                          }
                        }

                        // 15. If the [[Class]] internal property of Target is "Function", then
                        //     a. Let L be the length property of Target minus the length of A.
                        //     b. Set the length own property of F to either 0 or L, whichever is
                        //       larger.
                        // 16. Else set the length own property of F to 0.

                        var boundLength = Math.max(
                          0,
                          target.length - args.length
                        )

                        // 17. Set the attributes of the length own property of F to the values
                        //   specified in 15.3.5.1.
                        var boundArgs = []
                        for (var i = 0; i < boundLength; i++) {
                          boundArgs.push('$' + i)
                        }

                        // XXX Build a dynamic function with desired amount of arguments is the only
                        // way to set the length property of a function.
                        // In environments where Content Security Policies enabled (Chrome extensions,
                        // for ex.) all use of eval or Function costructor throws an exception.
                        // However in all of these environments Function.prototype.bind exists
                        // and so this code will never be executed.
                        var bound = Function(
                          'binder',
                          'return function (' +
                            boundArgs.join(',') +
                            '){ return binder.apply(this, arguments); }'
                        )(binder)

                        if (target.prototype) {
                          Empty.prototype = target.prototype
                          bound.prototype = new Empty()
                          // Clean up dangling references.
                          Empty.prototype = null
                        }

                        // TODO
                        // 18. Set the [[Extensible]] internal property of F to true.

                        // TODO
                        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
                        // 20. Call the [[DefineOwnProperty]] internal method of F with
                        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
                        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
                        //   false.
                        // 21. Call the [[DefineOwnProperty]] internal method of F with
                        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
                        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
                        //   and false.

                        // TODO
                        // NOTE Function objects created using Function.prototype.bind do not
                        // have a prototype property or the [[Code]], [[FormalParameters]], and
                        // [[Scope]] internal properties.
                        // XXX can't delete prototype in pure-js.

                        // 22. Return F.
                        return bound
                      }
                    })

                    //
                    // Array
                    // =====
                    //

                    // ES5 15.4.3.2
                    // http://es5.github.com/#x15.4.3.2
                    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
                    defineProperties(Array, { isArray: isArray })

                    var boxedString = Object('a')
                    var splitString =
                      boxedString[0] !== 'a' || !(0 in boxedString)

                    var properlyBoxesContext = function properlyBoxed(method) {
                      // Check node 0.6.21 bug where third parameter is not boxed
                      var properlyBoxesNonStrict = true
                      var properlyBoxesStrict = true
                      if (method) {
                        method.call('foo', function(_, __, context) {
                          if (typeof context !== 'object') {
                            properlyBoxesNonStrict = false
                          }
                        })

                        method.call(
                          [1],
                          function() {
                            'use strict'
                            properlyBoxesStrict = typeof this === 'string'
                          },
                          'x'
                        )
                      }
                      return (
                        !!method &&
                        properlyBoxesNonStrict &&
                        properlyBoxesStrict
                      )
                    }

                    defineProperties(
                      ArrayPrototype,
                      {
                        forEach: function forEach(fun /*, thisp*/) {
                          var object = toObject(this),
                            self =
                              splitString && isString(this)
                                ? this.split('')
                                : object,
                            thisp = arguments[1],
                            i = -1,
                            length = self.length >>> 0

                          // If no callback function or if callback is not a callable function
                          if (!isFunction(fun)) {
                            throw new TypeError() // TODO message
                          }

                          while (++i < length) {
                            if (i in self) {
                              // Invoke the callback function with call, passing arguments:
                              // context, property value, property key, thisArg object
                              // context
                              fun.call(thisp, self[i], i, object)
                            }
                          }
                        }
                      },
                      !properlyBoxesContext(ArrayPrototype.forEach)
                    )

                    // ES5 15.4.4.14
                    // http://es5.github.com/#x15.4.4.14
                    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
                    var hasFirefox2IndexOfBug =
                      Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1
                    defineProperties(
                      ArrayPrototype,
                      {
                        indexOf: function indexOf(sought /*, fromIndex */) {
                          var self =
                              splitString && isString(this)
                                ? this.split('')
                                : toObject(this),
                            length = self.length >>> 0

                          if (!length) {
                            return -1
                          }

                          var i = 0
                          if (arguments.length > 1) {
                            i = toInteger(arguments[1])
                          }

                          // handle negative indices
                          i = i >= 0 ? i : Math.max(0, length + i)
                          for (; i < length; i++) {
                            if (i in self && self[i] === sought) {
                              return i
                            }
                          }
                          return -1
                        }
                      },
                      hasFirefox2IndexOfBug
                    )

                    //
                    // String
                    // ======
                    //

                    // ES5 15.5.4.14
                    // http://es5.github.com/#x15.5.4.14

                    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
                    // Many browsers do not split properly with regular expressions or they
                    // do not perform the split correctly under obscure conditions.
                    // See http://blog.stevenlevithan.com/archives/cross-browser-split
                    // I've tested in many browsers and this seems to cover the deviant ones:
                    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
                    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
                    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
                    //       [undefined, "t", undefined, "e", ...]
                    //    ''.split(/.?/) should be [], not [""]
                    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

                    var string_split = StringPrototype.split
                    if (
                      'ab'.split(/(?:ab)*/).length !== 2 ||
                      '.'.split(/(.?)(.?)/).length !== 4 ||
                      'tesst'.split(/(s)*/)[1] === 't' ||
                      'test'.split(/(?:)/, -1).length !== 4 ||
                      ''.split(/.?/).length ||
                      '.'.split(/()()/).length > 1
                    ) {
                      ;(function() {
                        var compliantExecNpcg = /()??/.exec('')[1] === void 0 // NPCG: nonparticipating capturing group

                        StringPrototype.split = function(separator, limit) {
                          var string = this
                          if (separator === void 0 && limit === 0) {
                            return []
                          }

                          // If `separator` is not a regex, use native split
                          if (_toString.call(separator) !== '[object RegExp]') {
                            return string_split.call(this, separator, limit)
                          }

                          var output = [],
                            flags =
                              (separator.ignoreCase ? 'i' : '') +
                              (separator.multiline ? 'm' : '') +
                              (separator.extended ? 'x' : '') + // Proposed for ES6
                              (separator.sticky ? 'y' : ''), // Firefox 3+
                            lastLastIndex = 0,
                            // Make `global` and avoid `lastIndex` issues by working with a copy
                            separator2,
                            match,
                            lastIndex,
                            lastLength
                          separator = new RegExp(separator.source, flags + 'g')
                          string += '' // Type-convert
                          if (!compliantExecNpcg) {
                            // Doesn't need flags gy, but they don't hurt
                            separator2 = new RegExp(
                              '^' + separator.source + '$(?!\\s)',
                              flags
                            )
                          }
                          /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
                          limit =
                            limit === void 0
                              ? -1 >>> 0 // Math.pow(2, 32) - 1
                              : ToUint32(limit)
                          while ((match = separator.exec(string))) {
                            // `separator.lastIndex` is not reliable cross-browser
                            lastIndex = match.index + match[0].length
                            if (lastIndex > lastLastIndex) {
                              output.push(
                                string.slice(lastLastIndex, match.index)
                              )
                              // Fix browsers whose `exec` methods don't consistently return `undefined` for
                              // nonparticipating capturing groups
                              if (!compliantExecNpcg && match.length > 1) {
                                match[0].replace(separator2, function() {
                                  for (
                                    var i = 1;
                                    i < arguments.length - 2;
                                    i++
                                  ) {
                                    if (arguments[i] === void 0) {
                                      match[i] = void 0
                                    }
                                  }
                                })
                              }
                              if (
                                match.length > 1 &&
                                match.index < string.length
                              ) {
                                ArrayPrototype.push.apply(
                                  output,
                                  match.slice(1)
                                )
                              }
                              lastLength = match[0].length
                              lastLastIndex = lastIndex
                              if (output.length >= limit) {
                                break
                              }
                            }
                            if (separator.lastIndex === match.index) {
                              separator.lastIndex++ // Avoid an infinite loop
                            }
                          }
                          if (lastLastIndex === string.length) {
                            if (lastLength || !separator.test('')) {
                              output.push('')
                            }
                          } else {
                            output.push(string.slice(lastLastIndex))
                          }
                          return output.length > limit
                            ? output.slice(0, limit)
                            : output
                        }
                      })()

                      // [bugfix, chrome]
                      // If separator is undefined, then the result array contains just one String,
                      // which is the this value (converted to a String). If limit is not undefined,
                      // then the output array is truncated so that it contains no more than limit
                      // elements.
                      // "0".split(undefined, 0) -> []
                    } else if ('0'.split(void 0, 0).length) {
                      StringPrototype.split = function split(separator, limit) {
                        if (separator === void 0 && limit === 0) {
                          return []
                        }
                        return string_split.call(this, separator, limit)
                      }
                    }

                    // ECMA-262, 3rd B.2.3
                    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
                    // non-normative section suggesting uniform semantics and it should be
                    // normalized across all browsers
                    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
                    var string_substr = StringPrototype.substr
                    var hasNegativeSubstrBug =
                      ''.substr && '0b'.substr(-1) !== 'b'
                    defineProperties(
                      StringPrototype,
                      {
                        substr: function substr(start, length) {
                          return string_substr.call(
                            this,
                            start < 0
                              ? (start = this.length + start) < 0
                                ? 0
                                : start
                              : start,
                            length
                          )
                        }
                      },
                      hasNegativeSubstrBug
                    )
                  },
                  {}
                ],
                16: [
                  function(require, module, exports) {
                    'use strict'

                    module.exports = [
                      // streaming transports
                      require('./transport/websocket'),
                      require('./transport/xhr-streaming'),
                      require('./transport/xdr-streaming'),
                      require('./transport/eventsource'),
                      require('./transport/lib/iframe-wrap')(
                        require('./transport/eventsource')
                      ),

                      // polling transports
                      require('./transport/htmlfile'),
                      require('./transport/lib/iframe-wrap')(
                        require('./transport/htmlfile')
                      ),
                      require('./transport/xhr-polling'),
                      require('./transport/xdr-polling'),
                      require('./transport/lib/iframe-wrap')(
                        require('./transport/xhr-polling')
                      ),
                      require('./transport/jsonp-polling')
                    ]
                  },
                  {
                    './transport/eventsource': 20,
                    './transport/htmlfile': 21,
                    './transport/jsonp-polling': 23,
                    './transport/lib/iframe-wrap': 26,
                    './transport/websocket': 38,
                    './transport/xdr-polling': 39,
                    './transport/xdr-streaming': 40,
                    './transport/xhr-polling': 41,
                    './transport/xhr-streaming': 42
                  }
                ],
                17: [
                  function(require, module, exports) {
                    ;(function(process, global) {
                      'use strict'

                      var EventEmitter = require('events').EventEmitter,
                        inherits = require('inherits'),
                        utils = require('../../utils/event'),
                        urlUtils = require('../../utils/url'),
                        XHR = global.XMLHttpRequest

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:browser:xhr')
                      }

                      function AbstractXHRObject(method, url, payload, opts) {
                        debug(method, url)
                        var self = this
                        EventEmitter.call(this)

                        setTimeout(function() {
                          self._start(method, url, payload, opts)
                        }, 0)
                      }

                      inherits(AbstractXHRObject, EventEmitter)

                      AbstractXHRObject.prototype._start = function(
                        method,
                        url,
                        payload,
                        opts
                      ) {
                        var self = this

                        try {
                          this.xhr = new XHR()
                        } catch (x) {
                          // intentionally empty
                        }

                        if (!this.xhr) {
                          debug('no xhr')
                          this.emit('finish', 0, 'no xhr support')
                          this._cleanup()
                          return
                        }

                        // several browsers cache POSTs
                        url = urlUtils.addQuery(url, 't=' + +new Date())

                        // Explorer tends to keep connection open, even after the
                        // tab gets closed: http://bugs.jquery.com/ticket/5280
                        this.unloadRef = utils.unloadAdd(function() {
                          debug('unload cleanup')
                          self._cleanup(true)
                        })
                        try {
                          this.xhr.open(method, url, true)
                          if (this.timeout && 'timeout' in this.xhr) {
                            this.xhr.timeout = this.timeout
                            this.xhr.ontimeout = function() {
                              debug('xhr timeout')
                              self.emit('finish', 0, '')
                              self._cleanup(false)
                            }
                          }
                        } catch (e) {
                          debug('exception', e)
                          // IE raises an exception on wrong port.
                          this.emit('finish', 0, '')
                          this._cleanup(false)
                          return
                        }

                        if (
                          (!opts || !opts.noCredentials) &&
                          AbstractXHRObject.supportsCORS
                        ) {
                          debug('withCredentials')
                          // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
                          // "This never affects same-site requests."

                          this.xhr.withCredentials = true
                        }
                        if (opts && opts.headers) {
                          for (var key in opts.headers) {
                            this.xhr.setRequestHeader(key, opts.headers[key])
                          }
                        }

                        this.xhr.onreadystatechange = function() {
                          if (self.xhr) {
                            var x = self.xhr
                            var text, status
                            debug('readyState', x.readyState)
                            switch (x.readyState) {
                              case 3:
                                // IE doesn't like peeking into responseText or status
                                // on Microsoft.XMLHTTP and readystate=3
                                try {
                                  status = x.status
                                  text = x.responseText
                                } catch (e) {
                                  // intentionally empty
                                }
                                debug('status', status)
                                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                                if (status === 1223) {
                                  status = 204
                                }

                                // IE does return readystate == 3 for 404 answers.
                                if (status === 200 && text && text.length > 0) {
                                  debug('chunk')
                                  self.emit('chunk', status, text)
                                }
                                break
                              case 4:
                                status = x.status
                                debug('status', status)
                                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                                if (status === 1223) {
                                  status = 204
                                }
                                // IE returns this for a bad port
                                // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
                                if (status === 12005 || status === 12029) {
                                  status = 0
                                }

                                debug('finish', status, x.responseText)
                                self.emit('finish', status, x.responseText)
                                self._cleanup(false)
                                break
                            }
                          }
                        }

                        try {
                          self.xhr.send(payload)
                        } catch (e) {
                          self.emit('finish', 0, '')
                          self._cleanup(false)
                        }
                      }

                      AbstractXHRObject.prototype._cleanup = function(abort) {
                        debug('cleanup')
                        if (!this.xhr) {
                          return
                        }
                        this.removeAllListeners()
                        utils.unloadDel(this.unloadRef)

                        // IE needs this field to be a function
                        this.xhr.onreadystatechange = function() {}
                        if (this.xhr.ontimeout) {
                          this.xhr.ontimeout = null
                        }

                        if (abort) {
                          try {
                            this.xhr.abort()
                          } catch (x) {
                            // intentionally empty
                          }
                        }
                        this.unloadRef = this.xhr = null
                      }

                      AbstractXHRObject.prototype.close = function() {
                        debug('close')
                        this._cleanup(true)
                      }

                      AbstractXHRObject.enabled = !!XHR
                      // override XMLHttpRequest for IE6/7
                      // obfuscate to avoid firewalls
                      var axo = ['Active'].concat('Object').join('X')
                      if (!AbstractXHRObject.enabled && axo in global) {
                        debug('overriding xmlhttprequest')
                        XHR = function() {
                          try {
                            return new global[axo]('Microsoft.XMLHTTP')
                          } catch (e) {
                            return null
                          }
                        }
                        AbstractXHRObject.enabled = !!new XHR()
                      }

                      var cors = false
                      try {
                        cors = 'withCredentials' in new XHR()
                      } catch (ignored) {
                        // intentionally empty
                      }

                      AbstractXHRObject.supportsCORS = cors

                      module.exports = AbstractXHRObject
                    }.call(
                      this,
                      { env: {} },
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {
                    '../../utils/event': 46,
                    '../../utils/url': 52,
                    debug: 55,
                    events: 3,
                    inherits: 57
                  }
                ],
                18: [
                  function(require, module, exports) {
                    ;(function(global) {
                      module.exports = global.EventSource
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {}
                ],
                19: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      var Driver = global.WebSocket || global.MozWebSocket
                      if (Driver) {
                        module.exports = function WebSocketBrowserDriver(url) {
                          return new Driver(url)
                        }
                      } else {
                        module.exports = undefined
                      }
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {}
                ],
                20: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      AjaxBasedTransport = require('./lib/ajax-based'),
                      EventSourceReceiver = require('./receiver/eventsource'),
                      XHRCorsObject = require('./sender/xhr-cors'),
                      EventSourceDriver = require('eventsource')

                    function EventSourceTransport(transUrl) {
                      if (!EventSourceTransport.enabled()) {
                        throw new Error('Transport created when disabled')
                      }

                      AjaxBasedTransport.call(
                        this,
                        transUrl,
                        '/eventsource',
                        EventSourceReceiver,
                        XHRCorsObject
                      )
                    }

                    inherits(EventSourceTransport, AjaxBasedTransport)

                    EventSourceTransport.enabled = function() {
                      return !!EventSourceDriver
                    }

                    EventSourceTransport.transportName = 'eventsource'
                    EventSourceTransport.roundTrips = 2

                    module.exports = EventSourceTransport
                  },
                  {
                    './lib/ajax-based': 24,
                    './receiver/eventsource': 29,
                    './sender/xhr-cors': 35,
                    eventsource: 18,
                    inherits: 57
                  }
                ],
                21: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      HtmlfileReceiver = require('./receiver/htmlfile'),
                      XHRLocalObject = require('./sender/xhr-local'),
                      AjaxBasedTransport = require('./lib/ajax-based')

                    function HtmlFileTransport(transUrl) {
                      if (!HtmlfileReceiver.enabled) {
                        throw new Error('Transport created when disabled')
                      }
                      AjaxBasedTransport.call(
                        this,
                        transUrl,
                        '/htmlfile',
                        HtmlfileReceiver,
                        XHRLocalObject
                      )
                    }

                    inherits(HtmlFileTransport, AjaxBasedTransport)

                    HtmlFileTransport.enabled = function(info) {
                      return HtmlfileReceiver.enabled && info.sameOrigin
                    }

                    HtmlFileTransport.transportName = 'htmlfile'
                    HtmlFileTransport.roundTrips = 2

                    module.exports = HtmlFileTransport
                  },
                  {
                    './lib/ajax-based': 24,
                    './receiver/htmlfile': 30,
                    './sender/xhr-local': 37,
                    inherits: 57
                  }
                ],
                22: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      // Few cool transports do work only for same-origin. In order to make
                      // them work cross-domain we shall use iframe, served from the
                      // remote domain. New browsers have capabilities to communicate with
                      // cross domain iframe using postMessage(). In IE it was implemented
                      // from IE 8+, but of course, IE got some details wrong:
                      //    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
                      //    http://stevesouders.com/misc/test-postmessage.php

                      var inherits = require('inherits'),
                        JSON3 = require('json3'),
                        EventEmitter = require('events').EventEmitter,
                        version = require('../version'),
                        urlUtils = require('../utils/url'),
                        iframeUtils = require('../utils/iframe'),
                        eventUtils = require('../utils/event'),
                        random = require('../utils/random')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')(
                          'sockjs-client:transport:iframe'
                        )
                      }

                      function IframeTransport(transport, transUrl, baseUrl) {
                        if (!IframeTransport.enabled()) {
                          throw new Error('Transport created when disabled')
                        }
                        EventEmitter.call(this)

                        var self = this
                        this.origin = urlUtils.getOrigin(baseUrl)
                        this.baseUrl = baseUrl
                        this.transUrl = transUrl
                        this.transport = transport
                        this.windowId = random.string(8)

                        var iframeUrl =
                          urlUtils.addPath(baseUrl, '/iframe.html') +
                          '#' +
                          this.windowId
                        debug(transport, transUrl, iframeUrl)

                        this.iframeObj = iframeUtils.createIframe(
                          iframeUrl,
                          function(r) {
                            debug('err callback')
                            self.emit(
                              'close',
                              1006,
                              'Unable to load an iframe (' + r + ')'
                            )
                            self.close()
                          }
                        )

                        this.onmessageCallback = this._message.bind(this)
                        eventUtils.attachEvent(
                          'message',
                          this.onmessageCallback
                        )
                      }

                      inherits(IframeTransport, EventEmitter)

                      IframeTransport.prototype.close = function() {
                        debug('close')
                        this.removeAllListeners()
                        if (this.iframeObj) {
                          eventUtils.detachEvent(
                            'message',
                            this.onmessageCallback
                          )
                          try {
                            // When the iframe is not loaded, IE raises an exception
                            // on 'contentWindow'.
                            this.postMessage('c')
                          } catch (x) {
                            // intentionally empty
                          }
                          this.iframeObj.cleanup()
                          this.iframeObj = null
                          this.onmessageCallback = this.iframeObj = null
                        }
                      }

                      IframeTransport.prototype._message = function(e) {
                        debug('message', e.data)
                        if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
                          debug('not same origin', e.origin, this.origin)
                          return
                        }

                        var iframeMessage
                        try {
                          iframeMessage = JSON3.parse(e.data)
                        } catch (ignored) {
                          debug('bad json', e.data)
                          return
                        }

                        if (iframeMessage.windowId !== this.windowId) {
                          debug(
                            'mismatched window id',
                            iframeMessage.windowId,
                            this.windowId
                          )
                          return
                        }

                        switch (iframeMessage.type) {
                          case 's':
                            this.iframeObj.loaded()
                            // window global dependency
                            this.postMessage(
                              's',
                              JSON3.stringify([
                                version,
                                this.transport,
                                this.transUrl,
                                this.baseUrl
                              ])
                            )
                            break
                          case 't':
                            this.emit('message', iframeMessage.data)
                            break
                          case 'c':
                            var cdata
                            try {
                              cdata = JSON3.parse(iframeMessage.data)
                            } catch (ignored) {
                              debug('bad json', iframeMessage.data)
                              return
                            }
                            this.emit('close', cdata[0], cdata[1])
                            this.close()
                            break
                        }
                      }

                      IframeTransport.prototype.postMessage = function(
                        type,
                        data
                      ) {
                        debug('postMessage', type, data)
                        this.iframeObj.post(
                          JSON3.stringify({
                            windowId: this.windowId,
                            type: type,
                            data: data || ''
                          }),
                          this.origin
                        )
                      }

                      IframeTransport.prototype.send = function(message) {
                        debug('send', message)
                        this.postMessage('m', message)
                      }

                      IframeTransport.enabled = function() {
                        return iframeUtils.iframeEnabled
                      }

                      IframeTransport.transportName = 'iframe'
                      IframeTransport.roundTrips = 2

                      module.exports = IframeTransport
                    }.call(this, { env: {} }))
                  },
                  {
                    '../utils/event': 46,
                    '../utils/iframe': 47,
                    '../utils/random': 50,
                    '../utils/url': 52,
                    '../version': 53,
                    debug: 55,
                    events: 3,
                    inherits: 57,
                    json3: 58
                  }
                ],
                23: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      // The simplest and most robust transport, using the well-know cross
                      // domain hack - JSONP. This transport is quite inefficient - one
                      // message could use up to one http request. But at least it works almost
                      // everywhere.
                      // Known limitations:
                      //   o you will get a spinning cursor
                      //   o for Konqueror a dumb timer is needed to detect errors

                      var inherits = require('inherits'),
                        SenderReceiver = require('./lib/sender-receiver'),
                        JsonpReceiver = require('./receiver/jsonp'),
                        jsonpSender = require('./sender/jsonp')

                      function JsonPTransport(transUrl) {
                        if (!JsonPTransport.enabled()) {
                          throw new Error('Transport created when disabled')
                        }
                        SenderReceiver.call(
                          this,
                          transUrl,
                          '/jsonp',
                          jsonpSender,
                          JsonpReceiver
                        )
                      }

                      inherits(JsonPTransport, SenderReceiver)

                      JsonPTransport.enabled = function() {
                        return !!global.document
                      }

                      JsonPTransport.transportName = 'jsonp-polling'
                      JsonPTransport.roundTrips = 1
                      JsonPTransport.needBody = true

                      module.exports = JsonPTransport
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {
                    './lib/sender-receiver': 28,
                    './receiver/jsonp': 31,
                    './sender/jsonp': 33,
                    inherits: 57
                  }
                ],
                24: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var inherits = require('inherits'),
                        urlUtils = require('../../utils/url'),
                        SenderReceiver = require('./sender-receiver')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:ajax-based')
                      }

                      function createAjaxSender(AjaxObject) {
                        return function(url, payload, callback) {
                          debug('create ajax sender', url, payload)
                          var opt = {}
                          if (typeof payload === 'string') {
                            opt.headers = { 'Content-type': 'text/plain' }
                          }
                          var ajaxUrl = urlUtils.addPath(url, '/xhr_send')
                          var xo = new AjaxObject('POST', ajaxUrl, payload, opt)
                          xo.once('finish', function(status) {
                            debug('finish', status)
                            xo = null

                            if (status !== 200 && status !== 204) {
                              return callback(
                                new Error('http status ' + status)
                              )
                            }
                            callback()
                          })
                          return function() {
                            debug('abort')
                            xo.close()
                            xo = null

                            var err = new Error('Aborted')
                            err.code = 1000
                            callback(err)
                          }
                        }
                      }

                      function AjaxBasedTransport(
                        transUrl,
                        urlSuffix,
                        Receiver,
                        AjaxObject
                      ) {
                        SenderReceiver.call(
                          this,
                          transUrl,
                          urlSuffix,
                          createAjaxSender(AjaxObject),
                          Receiver,
                          AjaxObject
                        )
                      }

                      inherits(AjaxBasedTransport, SenderReceiver)

                      module.exports = AjaxBasedTransport
                    }.call(this, { env: {} }))
                  },
                  {
                    '../../utils/url': 52,
                    './sender-receiver': 28,
                    debug: 55,
                    inherits: 57
                  }
                ],
                25: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var inherits = require('inherits'),
                        EventEmitter = require('events').EventEmitter

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')(
                          'sockjs-client:buffered-sender'
                        )
                      }

                      function BufferedSender(url, sender) {
                        debug(url)
                        EventEmitter.call(this)
                        this.sendBuffer = []
                        this.sender = sender
                        this.url = url
                      }

                      inherits(BufferedSender, EventEmitter)

                      BufferedSender.prototype.send = function(message) {
                        debug('send', message)
                        this.sendBuffer.push(message)
                        if (!this.sendStop) {
                          this.sendSchedule()
                        }
                      }

                      // For polling transports in a situation when in the message callback,
                      // new message is being send. If the sending connection was started
                      // before receiving one, it is possible to saturate the network and
                      // timeout due to the lack of receiving socket. To avoid that we delay
                      // sending messages by some small time, in order to let receiving
                      // connection be started beforehand. This is only a halfmeasure and
                      // does not fix the big problem, but it does make the tests go more
                      // stable on slow networks.
                      BufferedSender.prototype.sendScheduleWait = function() {
                        debug('sendScheduleWait')
                        var self = this
                        var tref
                        this.sendStop = function() {
                          debug('sendStop')
                          self.sendStop = null
                          clearTimeout(tref)
                        }
                        tref = setTimeout(function() {
                          debug('timeout')
                          self.sendStop = null
                          self.sendSchedule()
                        }, 25)
                      }

                      BufferedSender.prototype.sendSchedule = function() {
                        debug('sendSchedule', this.sendBuffer.length)
                        var self = this
                        if (this.sendBuffer.length > 0) {
                          var payload = '[' + this.sendBuffer.join(',') + ']'
                          this.sendStop = this.sender(
                            this.url,
                            payload,
                            function(err) {
                              self.sendStop = null
                              if (err) {
                                debug('error', err)
                                self.emit(
                                  'close',
                                  err.code || 1006,
                                  'Sending error: ' + err
                                )
                                self.close()
                              } else {
                                self.sendScheduleWait()
                              }
                            }
                          )
                          this.sendBuffer = []
                        }
                      }

                      BufferedSender.prototype._cleanup = function() {
                        debug('_cleanup')
                        this.removeAllListeners()
                      }

                      BufferedSender.prototype.close = function() {
                        debug('close')
                        this._cleanup()
                        if (this.sendStop) {
                          this.sendStop()
                          this.sendStop = null
                        }
                      }

                      module.exports = BufferedSender
                    }.call(this, { env: {} }))
                  },
                  { debug: 55, events: 3, inherits: 57 }
                ],
                26: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      var inherits = require('inherits'),
                        IframeTransport = require('../iframe'),
                        objectUtils = require('../../utils/object')

                      module.exports = function(transport) {
                        function IframeWrapTransport(transUrl, baseUrl) {
                          IframeTransport.call(
                            this,
                            transport.transportName,
                            transUrl,
                            baseUrl
                          )
                        }

                        inherits(IframeWrapTransport, IframeTransport)

                        IframeWrapTransport.enabled = function(url, info) {
                          if (!global.document) {
                            return false
                          }

                          var iframeInfo = objectUtils.extend({}, info)
                          iframeInfo.sameOrigin = true
                          return (
                            transport.enabled(iframeInfo) &&
                            IframeTransport.enabled()
                          )
                        }

                        IframeWrapTransport.transportName =
                          'iframe-' + transport.transportName
                        IframeWrapTransport.needBody = true
                        IframeWrapTransport.roundTrips =
                          IframeTransport.roundTrips + transport.roundTrips - 1 // html, javascript (2) + transport - no CORS (1)

                        IframeWrapTransport.facadeTransport = transport

                        return IframeWrapTransport
                      }
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  { '../../utils/object': 49, '../iframe': 22, inherits: 57 }
                ],
                27: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var inherits = require('inherits'),
                        EventEmitter = require('events').EventEmitter

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:polling')
                      }

                      function Polling(Receiver, receiveUrl, AjaxObject) {
                        debug(receiveUrl)
                        EventEmitter.call(this)
                        this.Receiver = Receiver
                        this.receiveUrl = receiveUrl
                        this.AjaxObject = AjaxObject
                        this._scheduleReceiver()
                      }

                      inherits(Polling, EventEmitter)

                      Polling.prototype._scheduleReceiver = function() {
                        debug('_scheduleReceiver')
                        var self = this
                        var poll = (this.poll = new this.Receiver(
                          this.receiveUrl,
                          this.AjaxObject
                        ))

                        poll.on('message', function(msg) {
                          debug('message', msg)
                          self.emit('message', msg)
                        })

                        poll.once('close', function(code, reason) {
                          debug('close', code, reason, self.pollIsClosing)
                          self.poll = poll = null

                          if (!self.pollIsClosing) {
                            if (reason === 'network') {
                              self._scheduleReceiver()
                            } else {
                              self.emit('close', code || 1006, reason)
                              self.removeAllListeners()
                            }
                          }
                        })
                      }

                      Polling.prototype.abort = function() {
                        debug('abort')
                        this.removeAllListeners()
                        this.pollIsClosing = true
                        if (this.poll) {
                          this.poll.abort()
                        }
                      }

                      module.exports = Polling
                    }.call(this, { env: {} }))
                  },
                  { debug: 55, events: 3, inherits: 57 }
                ],
                28: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var inherits = require('inherits'),
                        urlUtils = require('../../utils/url'),
                        BufferedSender = require('./buffered-sender'),
                        Polling = require('./polling')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')(
                          'sockjs-client:sender-receiver'
                        )
                      }

                      function SenderReceiver(
                        transUrl,
                        urlSuffix,
                        senderFunc,
                        Receiver,
                        AjaxObject
                      ) {
                        var pollUrl = urlUtils.addPath(transUrl, urlSuffix)
                        debug(pollUrl)
                        var self = this
                        BufferedSender.call(this, transUrl, senderFunc)

                        this.poll = new Polling(Receiver, pollUrl, AjaxObject)
                        this.poll.on('message', function(msg) {
                          debug('poll message', msg)
                          self.emit('message', msg)
                        })
                        this.poll.once('close', function(code, reason) {
                          debug('poll close', code, reason)
                          self.poll = null
                          self.emit('close', code, reason)
                          self.close()
                        })
                      }

                      inherits(SenderReceiver, BufferedSender)

                      SenderReceiver.prototype.close = function() {
                        BufferedSender.prototype.close.call(this)
                        debug('close')
                        this.removeAllListeners()
                        if (this.poll) {
                          this.poll.abort()
                          this.poll = null
                        }
                      }

                      module.exports = SenderReceiver
                    }.call(this, { env: {} }))
                  },
                  {
                    '../../utils/url': 52,
                    './buffered-sender': 25,
                    './polling': 27,
                    debug: 55,
                    inherits: 57
                  }
                ],
                29: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var inherits = require('inherits'),
                        EventEmitter = require('events').EventEmitter,
                        EventSourceDriver = require('eventsource')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')(
                          'sockjs-client:receiver:eventsource'
                        )
                      }

                      function EventSourceReceiver(url) {
                        debug(url)
                        EventEmitter.call(this)

                        var self = this
                        var es = (this.es = new EventSourceDriver(url))
                        es.onmessage = function(e) {
                          debug('message', e.data)
                          self.emit('message', decodeURI(e.data))
                        }
                        es.onerror = function(e) {
                          debug('error', es.readyState, e)
                          // ES on reconnection has readyState = 0 or 1.
                          // on network error it's CLOSED = 2
                          var reason =
                            es.readyState !== 2 ? 'network' : 'permanent'
                          self._cleanup()
                          self._close(reason)
                        }
                      }

                      inherits(EventSourceReceiver, EventEmitter)

                      EventSourceReceiver.prototype.abort = function() {
                        debug('abort')
                        this._cleanup()
                        this._close('user')
                      }

                      EventSourceReceiver.prototype._cleanup = function() {
                        debug('cleanup')
                        var es = this.es
                        if (es) {
                          es.onmessage = es.onerror = null
                          es.close()
                          this.es = null
                        }
                      }

                      EventSourceReceiver.prototype._close = function(reason) {
                        debug('close', reason)
                        var self = this
                        // Safari and chrome < 15 crash if we close window before
                        // waiting for ES cleanup. See:
                        // https://code.google.com/p/chromium/issues/detail?id=89155
                        setTimeout(function() {
                          self.emit('close', null, reason)
                          self.removeAllListeners()
                        }, 200)
                      }

                      module.exports = EventSourceReceiver
                    }.call(this, { env: {} }))
                  },
                  { debug: 55, events: 3, eventsource: 18, inherits: 57 }
                ],
                30: [
                  function(require, module, exports) {
                    ;(function(process, global) {
                      'use strict'

                      var inherits = require('inherits'),
                        iframeUtils = require('../../utils/iframe'),
                        urlUtils = require('../../utils/url'),
                        EventEmitter = require('events').EventEmitter,
                        random = require('../../utils/random')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')(
                          'sockjs-client:receiver:htmlfile'
                        )
                      }

                      function HtmlfileReceiver(url) {
                        debug(url)
                        EventEmitter.call(this)
                        var self = this
                        iframeUtils.polluteGlobalNamespace()

                        this.id = 'a' + random.string(6)
                        url = urlUtils.addQuery(
                          url,
                          'c=' +
                            decodeURIComponent(
                              iframeUtils.WPrefix + '.' + this.id
                            )
                        )

                        debug(
                          'using htmlfile',
                          HtmlfileReceiver.htmlfileEnabled
                        )
                        var constructFunc = HtmlfileReceiver.htmlfileEnabled
                          ? iframeUtils.createHtmlfile
                          : iframeUtils.createIframe

                        global[iframeUtils.WPrefix][this.id] = {
                          start: function() {
                            debug('start')
                            self.iframeObj.loaded()
                          },
                          message: function(data) {
                            debug('message', data)
                            self.emit('message', data)
                          },
                          stop: function() {
                            debug('stop')
                            self._cleanup()
                            self._close('network')
                          }
                        }
                        this.iframeObj = constructFunc(url, function() {
                          debug('callback')
                          self._cleanup()
                          self._close('permanent')
                        })
                      }

                      inherits(HtmlfileReceiver, EventEmitter)

                      HtmlfileReceiver.prototype.abort = function() {
                        debug('abort')
                        this._cleanup()
                        this._close('user')
                      }

                      HtmlfileReceiver.prototype._cleanup = function() {
                        debug('_cleanup')
                        if (this.iframeObj) {
                          this.iframeObj.cleanup()
                          this.iframeObj = null
                        }
                        delete global[iframeUtils.WPrefix][this.id]
                      }

                      HtmlfileReceiver.prototype._close = function(reason) {
                        debug('_close', reason)
                        this.emit('close', null, reason)
                        this.removeAllListeners()
                      }

                      HtmlfileReceiver.htmlfileEnabled = false

                      // obfuscate to avoid firewalls
                      var axo = ['Active'].concat('Object').join('X')
                      if (axo in global) {
                        try {
                          HtmlfileReceiver.htmlfileEnabled = !!new global[axo](
                            'htmlfile'
                          )
                        } catch (x) {
                          // intentionally empty
                        }
                      }

                      HtmlfileReceiver.enabled =
                        HtmlfileReceiver.htmlfileEnabled ||
                        iframeUtils.iframeEnabled

                      module.exports = HtmlfileReceiver
                    }.call(
                      this,
                      { env: {} },
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {
                    '../../utils/iframe': 47,
                    '../../utils/random': 50,
                    '../../utils/url': 52,
                    debug: 55,
                    events: 3,
                    inherits: 57
                  }
                ],
                31: [
                  function(require, module, exports) {
                    ;(function(process, global) {
                      'use strict'

                      var utils = require('../../utils/iframe'),
                        random = require('../../utils/random'),
                        browser = require('../../utils/browser'),
                        urlUtils = require('../../utils/url'),
                        inherits = require('inherits'),
                        EventEmitter = require('events').EventEmitter

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:receiver:jsonp')
                      }

                      function JsonpReceiver(url) {
                        debug(url)
                        var self = this
                        EventEmitter.call(this)

                        utils.polluteGlobalNamespace()

                        this.id = 'a' + random.string(6)
                        var urlWithId = urlUtils.addQuery(
                          url,
                          'c=' +
                            encodeURIComponent(utils.WPrefix + '.' + this.id)
                        )

                        global[utils.WPrefix][this.id] = this._callback.bind(
                          this
                        )
                        this._createScript(urlWithId)

                        // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
                        this.timeoutId = setTimeout(function() {
                          debug('timeout')
                          self._abort(
                            new Error(
                              'JSONP script loaded abnormally (timeout)'
                            )
                          )
                        }, JsonpReceiver.timeout)
                      }

                      inherits(JsonpReceiver, EventEmitter)

                      JsonpReceiver.prototype.abort = function() {
                        debug('abort')
                        if (global[utils.WPrefix][this.id]) {
                          var err = new Error('JSONP user aborted read')
                          err.code = 1000
                          this._abort(err)
                        }
                      }

                      JsonpReceiver.timeout = 35000
                      JsonpReceiver.scriptErrorTimeout = 1000

                      JsonpReceiver.prototype._callback = function(data) {
                        debug('_callback', data)
                        this._cleanup()

                        if (this.aborting) {
                          return
                        }

                        if (data) {
                          debug('message', data)
                          this.emit('message', data)
                        }
                        this.emit('close', null, 'network')
                        this.removeAllListeners()
                      }

                      JsonpReceiver.prototype._abort = function(err) {
                        debug('_abort', err)
                        this._cleanup()
                        this.aborting = true
                        this.emit('close', err.code, err.message)
                        this.removeAllListeners()
                      }

                      JsonpReceiver.prototype._cleanup = function() {
                        debug('_cleanup')
                        clearTimeout(this.timeoutId)
                        if (this.script2) {
                          this.script2.parentNode.removeChild(this.script2)
                          this.script2 = null
                        }
                        if (this.script) {
                          var script = this.script
                          // Unfortunately, you can't really abort script loading of
                          // the script.
                          script.parentNode.removeChild(script)
                          script.onreadystatechange = script.onerror = script.onload = script.onclick = null
                          this.script = null
                        }
                        delete global[utils.WPrefix][this.id]
                      }

                      JsonpReceiver.prototype._scriptError = function() {
                        debug('_scriptError')
                        var self = this
                        if (this.errorTimer) {
                          return
                        }

                        this.errorTimer = setTimeout(function() {
                          if (!self.loadedOkay) {
                            self._abort(
                              new Error(
                                'JSONP script loaded abnormally (onerror)'
                              )
                            )
                          }
                        }, JsonpReceiver.scriptErrorTimeout)
                      }

                      JsonpReceiver.prototype._createScript = function(url) {
                        debug('_createScript', url)
                        var self = this
                        var script = (this.script = global.document.createElement(
                          'script'
                        ))
                        var script2 // Opera synchronous load trick.

                        script.id = 'a' + random.string(8)
                        script.src = url
                        script.type = 'text/javascript'
                        script.charset = 'UTF-8'
                        script.onerror = this._scriptError.bind(this)
                        script.onload = function() {
                          debug('onload')
                          self._abort(
                            new Error('JSONP script loaded abnormally (onload)')
                          )
                        }

                        // IE9 fires 'error' event after onreadystatechange or before, in random order.
                        // Use loadedOkay to determine if actually errored
                        script.onreadystatechange = function() {
                          debug('onreadystatechange', script.readyState)
                          if (/loaded|closed/.test(script.readyState)) {
                            if (script && script.htmlFor && script.onclick) {
                              self.loadedOkay = true
                              try {
                                // In IE, actually execute the script.
                                script.onclick()
                              } catch (x) {
                                // intentionally empty
                              }
                            }
                            if (script) {
                              self._abort(
                                new Error(
                                  'JSONP script loaded abnormally (onreadystatechange)'
                                )
                              )
                            }
                          }
                        }
                        // IE: event/htmlFor/onclick trick.
                        // One can't rely on proper order for onreadystatechange. In order to
                        // make sure, set a 'htmlFor' and 'event' properties, so that
                        // script code will be installed as 'onclick' handler for the
                        // script object. Later, onreadystatechange, manually execute this
                        // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
                        // set. For reference see:
                        //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
                        // Also, read on that about script ordering:
                        //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
                        if (
                          typeof script.async === 'undefined' &&
                          global.document.attachEvent
                        ) {
                          // According to mozilla docs, in recent browsers script.async defaults
                          // to 'true', so we may use it to detect a good browser:
                          // https://developer.mozilla.org/en/HTML/Element/script
                          if (!browser.isOpera()) {
                            // Naively assume we're in IE
                            try {
                              script.htmlFor = script.id
                              script.event = 'onclick'
                            } catch (x) {
                              // intentionally empty
                            }
                            script.async = true
                          } else {
                            // Opera, second sync script hack
                            script2 = this.script2 = global.document.createElement(
                              'script'
                            )
                            script2.text =
                              "try{var a = document.getElementById('" +
                              script.id +
                              "'); if(a)a.onerror();}catch(x){};"
                            script.async = script2.async = false
                          }
                        }
                        if (typeof script.async !== 'undefined') {
                          script.async = true
                        }

                        var head = global.document.getElementsByTagName(
                          'head'
                        )[0]
                        head.insertBefore(script, head.firstChild)
                        if (script2) {
                          head.insertBefore(script2, head.firstChild)
                        }
                      }

                      module.exports = JsonpReceiver
                    }.call(
                      this,
                      { env: {} },
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {
                    '../../utils/browser': 44,
                    '../../utils/iframe': 47,
                    '../../utils/random': 50,
                    '../../utils/url': 52,
                    debug: 55,
                    events: 3,
                    inherits: 57
                  }
                ],
                32: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var inherits = require('inherits'),
                        EventEmitter = require('events').EventEmitter

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:receiver:xhr')
                      }

                      function XhrReceiver(url, AjaxObject) {
                        debug(url)
                        EventEmitter.call(this)
                        var self = this

                        this.bufferPosition = 0

                        this.xo = new AjaxObject('POST', url, null)
                        this.xo.on('chunk', this._chunkHandler.bind(this))
                        this.xo.once('finish', function(status, text) {
                          debug('finish', status, text)
                          self._chunkHandler(status, text)
                          self.xo = null
                          var reason = status === 200 ? 'network' : 'permanent'
                          debug('close', reason)
                          self.emit('close', null, reason)
                          self._cleanup()
                        })
                      }

                      inherits(XhrReceiver, EventEmitter)

                      XhrReceiver.prototype._chunkHandler = function(
                        status,
                        text
                      ) {
                        debug('_chunkHandler', status)
                        if (status !== 200 || !text) {
                          return
                        }

                        for (var idx = -1; ; this.bufferPosition += idx + 1) {
                          var buf = text.slice(this.bufferPosition)
                          idx = buf.indexOf('\n')
                          if (idx === -1) {
                            break
                          }
                          var msg = buf.slice(0, idx)
                          if (msg) {
                            debug('message', msg)
                            this.emit('message', msg)
                          }
                        }
                      }

                      XhrReceiver.prototype._cleanup = function() {
                        debug('_cleanup')
                        this.removeAllListeners()
                      }

                      XhrReceiver.prototype.abort = function() {
                        debug('abort')
                        if (this.xo) {
                          this.xo.close()
                          debug('close')
                          this.emit('close', null, 'user')
                          this.xo = null
                        }
                        this._cleanup()
                      }

                      module.exports = XhrReceiver
                    }.call(this, { env: {} }))
                  },
                  { debug: 55, events: 3, inherits: 57 }
                ],
                33: [
                  function(require, module, exports) {
                    ;(function(process, global) {
                      'use strict'

                      var random = require('../../utils/random'),
                        urlUtils = require('../../utils/url')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:sender:jsonp')
                      }

                      var form, area

                      function createIframe(id) {
                        debug('createIframe', id)
                        try {
                          // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
                          return global.document.createElement(
                            '<iframe name="' + id + '">'
                          )
                        } catch (x) {
                          var iframe = global.document.createElement('iframe')
                          iframe.name = id
                          return iframe
                        }
                      }

                      function createForm() {
                        debug('createForm')
                        form = global.document.createElement('form')
                        form.style.display = 'none'
                        form.style.position = 'absolute'
                        form.method = 'POST'
                        form.enctype = 'application/x-www-form-urlencoded'
                        form.acceptCharset = 'UTF-8'

                        area = global.document.createElement('textarea')
                        area.name = 'd'
                        form.appendChild(area)

                        global.document.body.appendChild(form)
                      }

                      module.exports = function(url, payload, callback) {
                        debug(url, payload)
                        if (!form) {
                          createForm()
                        }
                        var id = 'a' + random.string(8)
                        form.target = id
                        form.action = urlUtils.addQuery(
                          urlUtils.addPath(url, '/jsonp_send'),
                          'i=' + id
                        )

                        var iframe = createIframe(id)
                        iframe.id = id
                        iframe.style.display = 'none'
                        form.appendChild(iframe)

                        try {
                          area.value = payload
                        } catch (e) {
                          // seriously broken browsers get here
                        }
                        form.submit()

                        var completed = function(err) {
                          debug('completed', id, err)
                          if (!iframe.onerror) {
                            return
                          }
                          iframe.onreadystatechange = iframe.onerror = iframe.onload = null
                          // Opera mini doesn't like if we GC iframe
                          // immediately, thus this timeout.
                          setTimeout(function() {
                            debug('cleaning up', id)
                            iframe.parentNode.removeChild(iframe)
                            iframe = null
                          }, 500)
                          area.value = ''
                          // It is not possible to detect if the iframe succeeded or
                          // failed to submit our form.
                          callback(err)
                        }
                        iframe.onerror = function() {
                          debug('onerror', id)
                          completed()
                        }
                        iframe.onload = function() {
                          debug('onload', id)
                          completed()
                        }
                        iframe.onreadystatechange = function(e) {
                          debug('onreadystatechange', id, iframe.readyState, e)
                          if (iframe.readyState === 'complete') {
                            completed()
                          }
                        }
                        return function() {
                          debug('aborted', id)
                          completed(new Error('Aborted'))
                        }
                      }
                    }.call(
                      this,
                      { env: {} },
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  { '../../utils/random': 50, '../../utils/url': 52, debug: 55 }
                ],
                34: [
                  function(require, module, exports) {
                    ;(function(process, global) {
                      'use strict'

                      var EventEmitter = require('events').EventEmitter,
                        inherits = require('inherits'),
                        eventUtils = require('../../utils/event'),
                        browser = require('../../utils/browser'),
                        urlUtils = require('../../utils/url')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:sender:xdr')
                      }

                      // References:
                      //   http://ajaxian.com/archives/100-line-ajax-wrapper
                      //   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

                      function XDRObject(method, url, payload) {
                        debug(method, url)
                        var self = this
                        EventEmitter.call(this)

                        setTimeout(function() {
                          self._start(method, url, payload)
                        }, 0)
                      }

                      inherits(XDRObject, EventEmitter)

                      XDRObject.prototype._start = function(
                        method,
                        url,
                        payload
                      ) {
                        debug('_start')
                        var self = this
                        var xdr = new global.XDomainRequest()
                        // IE caches even POSTs
                        url = urlUtils.addQuery(url, 't=' + +new Date())

                        xdr.onerror = function() {
                          debug('onerror')
                          self._error()
                        }
                        xdr.ontimeout = function() {
                          debug('ontimeout')
                          self._error()
                        }
                        xdr.onprogress = function() {
                          debug('progress', xdr.responseText)
                          self.emit('chunk', 200, xdr.responseText)
                        }
                        xdr.onload = function() {
                          debug('load')
                          self.emit('finish', 200, xdr.responseText)
                          self._cleanup(false)
                        }
                        this.xdr = xdr
                        this.unloadRef = eventUtils.unloadAdd(function() {
                          self._cleanup(true)
                        })
                        try {
                          // Fails with AccessDenied if port number is bogus
                          this.xdr.open(method, url)
                          if (this.timeout) {
                            this.xdr.timeout = this.timeout
                          }
                          this.xdr.send(payload)
                        } catch (x) {
                          this._error()
                        }
                      }

                      XDRObject.prototype._error = function() {
                        this.emit('finish', 0, '')
                        this._cleanup(false)
                      }

                      XDRObject.prototype._cleanup = function(abort) {
                        debug('cleanup', abort)
                        if (!this.xdr) {
                          return
                        }
                        this.removeAllListeners()
                        eventUtils.unloadDel(this.unloadRef)

                        this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null
                        if (abort) {
                          try {
                            this.xdr.abort()
                          } catch (x) {
                            // intentionally empty
                          }
                        }
                        this.unloadRef = this.xdr = null
                      }

                      XDRObject.prototype.close = function() {
                        debug('close')
                        this._cleanup(true)
                      }

                      // IE 8/9 if the request target uses the same scheme - #79
                      XDRObject.enabled = !!(
                        global.XDomainRequest && browser.hasDomain()
                      )

                      module.exports = XDRObject
                    }.call(
                      this,
                      { env: {} },
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {
                    '../../utils/browser': 44,
                    '../../utils/event': 46,
                    '../../utils/url': 52,
                    debug: 55,
                    events: 3,
                    inherits: 57
                  }
                ],
                35: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      XhrDriver = require('../driver/xhr')

                    function XHRCorsObject(method, url, payload, opts) {
                      XhrDriver.call(this, method, url, payload, opts)
                    }

                    inherits(XHRCorsObject, XhrDriver)

                    XHRCorsObject.enabled =
                      XhrDriver.enabled && XhrDriver.supportsCORS

                    module.exports = XHRCorsObject
                  },
                  { '../driver/xhr': 17, inherits: 57 }
                ],
                36: [
                  function(require, module, exports) {
                    'use strict'

                    var EventEmitter = require('events').EventEmitter,
                      inherits = require('inherits')

                    function XHRFake(/* method, url, payload, opts */) {
                      var self = this
                      EventEmitter.call(this)

                      this.to = setTimeout(function() {
                        self.emit('finish', 200, '{}')
                      }, XHRFake.timeout)
                    }

                    inherits(XHRFake, EventEmitter)

                    XHRFake.prototype.close = function() {
                      clearTimeout(this.to)
                    }

                    XHRFake.timeout = 2000

                    module.exports = XHRFake
                  },
                  { events: 3, inherits: 57 }
                ],
                37: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      XhrDriver = require('../driver/xhr')

                    function XHRLocalObject(method, url, payload /*, opts */) {
                      XhrDriver.call(this, method, url, payload, {
                        noCredentials: true
                      })
                    }

                    inherits(XHRLocalObject, XhrDriver)

                    XHRLocalObject.enabled = XhrDriver.enabled

                    module.exports = XHRLocalObject
                  },
                  { '../driver/xhr': 17, inherits: 57 }
                ],
                38: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var utils = require('../utils/event'),
                        urlUtils = require('../utils/url'),
                        inherits = require('inherits'),
                        EventEmitter = require('events').EventEmitter,
                        WebsocketDriver = require('./driver/websocket')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:websocket')
                      }

                      function WebSocketTransport(transUrl, ignore, options) {
                        if (!WebSocketTransport.enabled()) {
                          throw new Error('Transport created when disabled')
                        }

                        EventEmitter.call(this)
                        debug('constructor', transUrl)

                        var self = this
                        var url = urlUtils.addPath(transUrl, '/websocket')
                        if (url.slice(0, 5) === 'https') {
                          url = 'wss' + url.slice(5)
                        } else {
                          url = 'ws' + url.slice(4)
                        }
                        this.url = url

                        this.ws = new WebsocketDriver(this.url, [], options)
                        this.ws.onmessage = function(e) {
                          debug('message event', e.data)
                          self.emit('message', e.data)
                        }
                        // Firefox has an interesting bug. If a websocket connection is
                        // created after onunload, it stays alive even when user
                        // navigates away from the page. In such situation let's lie -
                        // let's not open the ws connection at all. See:
                        // https://github.com/sockjs/sockjs-client/issues/28
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
                        this.unloadRef = utils.unloadAdd(function() {
                          debug('unload')
                          self.ws.close()
                        })
                        this.ws.onclose = function(e) {
                          debug('close event', e.code, e.reason)
                          self.emit('close', e.code, e.reason)
                          self._cleanup()
                        }
                        this.ws.onerror = function(e) {
                          debug('error event', e)
                          self.emit(
                            'close',
                            1006,
                            'WebSocket connection broken'
                          )
                          self._cleanup()
                        }
                      }

                      inherits(WebSocketTransport, EventEmitter)

                      WebSocketTransport.prototype.send = function(data) {
                        var msg = '[' + data + ']'
                        debug('send', msg)
                        this.ws.send(msg)
                      }

                      WebSocketTransport.prototype.close = function() {
                        debug('close')
                        var ws = this.ws
                        this._cleanup()
                        if (ws) {
                          ws.close()
                        }
                      }

                      WebSocketTransport.prototype._cleanup = function() {
                        debug('_cleanup')
                        var ws = this.ws
                        if (ws) {
                          ws.onmessage = ws.onclose = ws.onerror = null
                        }
                        utils.unloadDel(this.unloadRef)
                        this.unloadRef = this.ws = null
                        this.removeAllListeners()
                      }

                      WebSocketTransport.enabled = function() {
                        debug('enabled')
                        return !!WebsocketDriver
                      }
                      WebSocketTransport.transportName = 'websocket'

                      // In theory, ws should require 1 round trip. But in chrome, this is
                      // not very stable over SSL. Most likely a ws connection requires a
                      // separate SSL connection, in which case 2 round trips are an
                      // absolute minumum.
                      WebSocketTransport.roundTrips = 2

                      module.exports = WebSocketTransport
                    }.call(this, { env: {} }))
                  },
                  {
                    '../utils/event': 46,
                    '../utils/url': 52,
                    './driver/websocket': 19,
                    debug: 55,
                    events: 3,
                    inherits: 57
                  }
                ],
                39: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      AjaxBasedTransport = require('./lib/ajax-based'),
                      XdrStreamingTransport = require('./xdr-streaming'),
                      XhrReceiver = require('./receiver/xhr'),
                      XDRObject = require('./sender/xdr')

                    function XdrPollingTransport(transUrl) {
                      if (!XDRObject.enabled) {
                        throw new Error('Transport created when disabled')
                      }
                      AjaxBasedTransport.call(
                        this,
                        transUrl,
                        '/xhr',
                        XhrReceiver,
                        XDRObject
                      )
                    }

                    inherits(XdrPollingTransport, AjaxBasedTransport)

                    XdrPollingTransport.enabled = XdrStreamingTransport.enabled
                    XdrPollingTransport.transportName = 'xdr-polling'
                    XdrPollingTransport.roundTrips = 2 // preflight, ajax

                    module.exports = XdrPollingTransport
                  },
                  {
                    './lib/ajax-based': 24,
                    './receiver/xhr': 32,
                    './sender/xdr': 34,
                    './xdr-streaming': 40,
                    inherits: 57
                  }
                ],
                40: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      AjaxBasedTransport = require('./lib/ajax-based'),
                      XhrReceiver = require('./receiver/xhr'),
                      XDRObject = require('./sender/xdr')

                    // According to:
                    //   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
                    //   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

                    function XdrStreamingTransport(transUrl) {
                      if (!XDRObject.enabled) {
                        throw new Error('Transport created when disabled')
                      }
                      AjaxBasedTransport.call(
                        this,
                        transUrl,
                        '/xhr_streaming',
                        XhrReceiver,
                        XDRObject
                      )
                    }

                    inherits(XdrStreamingTransport, AjaxBasedTransport)

                    XdrStreamingTransport.enabled = function(info) {
                      if (info.cookie_needed || info.nullOrigin) {
                        return false
                      }
                      return XDRObject.enabled && info.sameScheme
                    }

                    XdrStreamingTransport.transportName = 'xdr-streaming'
                    XdrStreamingTransport.roundTrips = 2 // preflight, ajax

                    module.exports = XdrStreamingTransport
                  },
                  {
                    './lib/ajax-based': 24,
                    './receiver/xhr': 32,
                    './sender/xdr': 34,
                    inherits: 57
                  }
                ],
                41: [
                  function(require, module, exports) {
                    'use strict'

                    var inherits = require('inherits'),
                      AjaxBasedTransport = require('./lib/ajax-based'),
                      XhrReceiver = require('./receiver/xhr'),
                      XHRCorsObject = require('./sender/xhr-cors'),
                      XHRLocalObject = require('./sender/xhr-local')

                    function XhrPollingTransport(transUrl) {
                      if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
                        throw new Error('Transport created when disabled')
                      }
                      AjaxBasedTransport.call(
                        this,
                        transUrl,
                        '/xhr',
                        XhrReceiver,
                        XHRCorsObject
                      )
                    }

                    inherits(XhrPollingTransport, AjaxBasedTransport)

                    XhrPollingTransport.enabled = function(info) {
                      if (info.nullOrigin) {
                        return false
                      }

                      if (XHRLocalObject.enabled && info.sameOrigin) {
                        return true
                      }
                      return XHRCorsObject.enabled
                    }

                    XhrPollingTransport.transportName = 'xhr-polling'
                    XhrPollingTransport.roundTrips = 2 // preflight, ajax

                    module.exports = XhrPollingTransport
                  },
                  {
                    './lib/ajax-based': 24,
                    './receiver/xhr': 32,
                    './sender/xhr-cors': 35,
                    './sender/xhr-local': 37,
                    inherits: 57
                  }
                ],
                42: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      var inherits = require('inherits'),
                        AjaxBasedTransport = require('./lib/ajax-based'),
                        XhrReceiver = require('./receiver/xhr'),
                        XHRCorsObject = require('./sender/xhr-cors'),
                        XHRLocalObject = require('./sender/xhr-local'),
                        browser = require('../utils/browser')

                      function XhrStreamingTransport(transUrl) {
                        if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
                          throw new Error('Transport created when disabled')
                        }
                        AjaxBasedTransport.call(
                          this,
                          transUrl,
                          '/xhr_streaming',
                          XhrReceiver,
                          XHRCorsObject
                        )
                      }

                      inherits(XhrStreamingTransport, AjaxBasedTransport)

                      XhrStreamingTransport.enabled = function(info) {
                        if (info.nullOrigin) {
                          return false
                        }
                        // Opera doesn't support xhr-streaming #60
                        // But it might be able to #92
                        if (browser.isOpera()) {
                          return false
                        }

                        return XHRCorsObject.enabled
                      }

                      XhrStreamingTransport.transportName = 'xhr-streaming'
                      XhrStreamingTransport.roundTrips = 2 // preflight, ajax

                      // Safari gets confused when a streaming ajax request is started
                      // before onload. This causes the load indicator to spin indefinetely.
                      // Only require body when used in a browser
                      XhrStreamingTransport.needBody = !!global.document

                      module.exports = XhrStreamingTransport
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {
                    '../utils/browser': 44,
                    './lib/ajax-based': 24,
                    './receiver/xhr': 32,
                    './sender/xhr-cors': 35,
                    './sender/xhr-local': 37,
                    inherits: 57
                  }
                ],
                43: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      if (global.crypto && global.crypto.getRandomValues) {
                        module.exports.randomBytes = function(length) {
                          var bytes = new Uint8Array(length)
                          global.crypto.getRandomValues(bytes)
                          return bytes
                        }
                      } else {
                        module.exports.randomBytes = function(length) {
                          var bytes = new Array(length)
                          for (var i = 0; i < length; i++) {
                            bytes[i] = Math.floor(Math.random() * 256)
                          }
                          return bytes
                        }
                      }
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {}
                ],
                44: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      module.exports = {
                        isOpera: function() {
                          return (
                            global.navigator &&
                            /opera/i.test(global.navigator.userAgent)
                          )
                        },

                        isKonqueror: function() {
                          return (
                            global.navigator &&
                            /konqueror/i.test(global.navigator.userAgent)
                          )
                        },

                        // #187 wrap document.domain in try/catch because of WP8 from file:///
                        hasDomain: function() {
                          // non-browser client always has a domain
                          if (!global.document) {
                            return true
                          }

                          try {
                            return !!global.document.domain
                          } catch (e) {
                            return false
                          }
                        }
                      }
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {}
                ],
                45: [
                  function(require, module, exports) {
                    'use strict'

                    var JSON3 = require('json3')

                    // Some extra characters that Chrome gets wrong, and substitutes with
                    // something else on the wire.
                    // eslint-disable-next-line no-control-regex, no-misleading-character-class
                    var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
                      extraLookup

                    // This may be quite slow, so let's delay until user actually uses bad
                    // characters.
                    var unrollLookup = function(escapable) {
                      var i
                      var unrolled = {}
                      var c = []
                      for (i = 0; i < 65536; i++) {
                        c.push(String.fromCharCode(i))
                      }
                      escapable.lastIndex = 0
                      c.join('').replace(escapable, function(a) {
                        unrolled[a] =
                          '\\u' +
                          ('0000' + a.charCodeAt(0).toString(16)).slice(-4)
                        return ''
                      })
                      escapable.lastIndex = 0
                      return unrolled
                    }

                    // Quote string, also taking care of unicode characters that browsers
                    // often break. Especially, take care of unicode surrogates:
                    // http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
                    module.exports = {
                      quote: function(string) {
                        var quoted = JSON3.stringify(string)

                        // In most cases this should be very fast and good enough.
                        extraEscapable.lastIndex = 0
                        if (!extraEscapable.test(quoted)) {
                          return quoted
                        }

                        if (!extraLookup) {
                          extraLookup = unrollLookup(extraEscapable)
                        }

                        return quoted.replace(extraEscapable, function(a) {
                          return extraLookup[a]
                        })
                      }
                    }
                  },
                  { json3: 58 }
                ],
                46: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      var random = require('./random')

                      var onUnload = {},
                        afterUnload = false,
                        // detect google chrome packaged apps because they don't allow the 'unload' event
                        isChromePackagedApp =
                          global.chrome &&
                          global.chrome.app &&
                          global.chrome.app.runtime

                      module.exports = {
                        attachEvent: function(event, listener) {
                          if (typeof global.addEventListener !== 'undefined') {
                            global.addEventListener(event, listener, false)
                          } else if (global.document && global.attachEvent) {
                            // IE quirks.
                            // According to: http://stevesouders.com/misc/test-postmessage.php
                            // the message gets delivered only to 'document', not 'window'.
                            global.document.attachEvent('on' + event, listener)
                            // I get 'window' for ie8.
                            global.attachEvent('on' + event, listener)
                          }
                        },

                        detachEvent: function(event, listener) {
                          if (typeof global.addEventListener !== 'undefined') {
                            global.removeEventListener(event, listener, false)
                          } else if (global.document && global.detachEvent) {
                            global.document.detachEvent('on' + event, listener)
                            global.detachEvent('on' + event, listener)
                          }
                        },

                        unloadAdd: function(listener) {
                          if (isChromePackagedApp) {
                            return null
                          }

                          var ref = random.string(8)
                          onUnload[ref] = listener
                          if (afterUnload) {
                            setTimeout(this.triggerUnloadCallbacks, 0)
                          }
                          return ref
                        },

                        unloadDel: function(ref) {
                          if (ref in onUnload) {
                            delete onUnload[ref]
                          }
                        },

                        triggerUnloadCallbacks: function() {
                          for (var ref in onUnload) {
                            onUnload[ref]()
                            delete onUnload[ref]
                          }
                        }
                      }

                      var unloadTriggered = function() {
                        if (afterUnload) {
                          return
                        }
                        afterUnload = true
                        module.exports.triggerUnloadCallbacks()
                      }

                      // 'unload' alone is not reliable in opera within an iframe, but we
                      // can't use `beforeunload` as IE fires it on javascript: links.
                      if (!isChromePackagedApp) {
                        module.exports.attachEvent('unload', unloadTriggered)
                      }
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  { './random': 50 }
                ],
                47: [
                  function(require, module, exports) {
                    ;(function(process, global) {
                      'use strict'

                      var eventUtils = require('./event'),
                        JSON3 = require('json3'),
                        browser = require('./browser')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:utils:iframe')
                      }

                      module.exports = {
                        WPrefix: '_jp',
                        currentWindowId: null,

                        polluteGlobalNamespace: function() {
                          if (!(module.exports.WPrefix in global)) {
                            global[module.exports.WPrefix] = {}
                          }
                        },

                        postMessage: function(type, data) {
                          if (global.parent !== global) {
                            global.parent.postMessage(
                              JSON3.stringify({
                                windowId: module.exports.currentWindowId,
                                type: type,
                                data: data || ''
                              }),
                              '*'
                            )
                          } else {
                            debug(
                              'Cannot postMessage, no parent window.',
                              type,
                              data
                            )
                          }
                        },

                        createIframe: function(iframeUrl, errorCallback) {
                          var iframe = global.document.createElement('iframe')
                          var tref, unloadRef
                          var unattach = function() {
                            debug('unattach')
                            clearTimeout(tref)
                            // Explorer had problems with that.
                            try {
                              iframe.onload = null
                            } catch (x) {
                              // intentionally empty
                            }
                            iframe.onerror = null
                          }
                          var cleanup = function() {
                            debug('cleanup')
                            if (iframe) {
                              unattach()
                              // This timeout makes chrome fire onbeforeunload event
                              // within iframe. Without the timeout it goes straight to
                              // onunload.
                              setTimeout(function() {
                                if (iframe) {
                                  iframe.parentNode.removeChild(iframe)
                                }
                                iframe = null
                              }, 0)
                              eventUtils.unloadDel(unloadRef)
                            }
                          }
                          var onerror = function(err) {
                            debug('onerror', err)
                            if (iframe) {
                              cleanup()
                              errorCallback(err)
                            }
                          }
                          var post = function(msg, origin) {
                            debug('post', msg, origin)
                            setTimeout(function() {
                              try {
                                // When the iframe is not loaded, IE raises an exception
                                // on 'contentWindow'.
                                if (iframe && iframe.contentWindow) {
                                  iframe.contentWindow.postMessage(msg, origin)
                                }
                              } catch (x) {
                                // intentionally empty
                              }
                            }, 0)
                          }

                          iframe.src = iframeUrl
                          iframe.style.display = 'none'
                          iframe.style.position = 'absolute'
                          iframe.onerror = function() {
                            onerror('onerror')
                          }
                          iframe.onload = function() {
                            debug('onload')
                            // `onload` is triggered before scripts on the iframe are
                            // executed. Give it few seconds to actually load stuff.
                            clearTimeout(tref)
                            tref = setTimeout(function() {
                              onerror('onload timeout')
                            }, 2000)
                          }
                          global.document.body.appendChild(iframe)
                          tref = setTimeout(function() {
                            onerror('timeout')
                          }, 15000)
                          unloadRef = eventUtils.unloadAdd(cleanup)
                          return {
                            post: post,
                            cleanup: cleanup,
                            loaded: unattach
                          }
                        },

                        /* eslint no-undef: "off", new-cap: "off" */
                        createHtmlfile: function(iframeUrl, errorCallback) {
                          var axo = ['Active'].concat('Object').join('X')
                          var doc = new global[axo]('htmlfile')
                          var tref, unloadRef
                          var iframe
                          var unattach = function() {
                            clearTimeout(tref)
                            iframe.onerror = null
                          }
                          var cleanup = function() {
                            if (doc) {
                              unattach()
                              eventUtils.unloadDel(unloadRef)
                              iframe.parentNode.removeChild(iframe)
                              iframe = doc = null
                              CollectGarbage()
                            }
                          }
                          var onerror = function(r) {
                            debug('onerror', r)
                            if (doc) {
                              cleanup()
                              errorCallback(r)
                            }
                          }
                          var post = function(msg, origin) {
                            try {
                              // When the iframe is not loaded, IE raises an exception
                              // on 'contentWindow'.
                              setTimeout(function() {
                                if (iframe && iframe.contentWindow) {
                                  iframe.contentWindow.postMessage(msg, origin)
                                }
                              }, 0)
                            } catch (x) {
                              // intentionally empty
                            }
                          }

                          doc.open()
                          doc.write(
                            '<html><s' +
                              'cript>' +
                              'document.domain="' +
                              global.document.domain +
                              '";' +
                              '</s' +
                              'cript></html>'
                          )
                          doc.close()
                          doc.parentWindow[module.exports.WPrefix] =
                            global[module.exports.WPrefix]
                          var c = doc.createElement('div')
                          doc.body.appendChild(c)
                          iframe = doc.createElement('iframe')
                          c.appendChild(iframe)
                          iframe.src = iframeUrl
                          iframe.onerror = function() {
                            onerror('onerror')
                          }
                          tref = setTimeout(function() {
                            onerror('timeout')
                          }, 15000)
                          unloadRef = eventUtils.unloadAdd(cleanup)
                          return {
                            post: post,
                            cleanup: cleanup,
                            loaded: unattach
                          }
                        }
                      }

                      module.exports.iframeEnabled = false
                      if (global.document) {
                        // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
                        // huge delay, or not at all.
                        module.exports.iframeEnabled =
                          (typeof global.postMessage === 'function' ||
                            typeof global.postMessage === 'object') &&
                          !browser.isKonqueror()
                      }
                    }.call(
                      this,
                      { env: {} },
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  { './browser': 44, './event': 46, debug: 55, json3: 58 }
                ],
                48: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      var logObject = {}
                      ;['log', 'debug', 'warn'].forEach(function(level) {
                        var levelExists

                        try {
                          levelExists =
                            global.console &&
                            global.console[level] &&
                            global.console[level].apply
                        } catch (e) {
                          // do nothing
                        }

                        logObject[level] = levelExists
                          ? function() {
                              return global.console[level].apply(
                                global.console,
                                arguments
                              )
                            }
                          : level === 'log'
                            ? function() {}
                            : logObject.log
                      })

                      module.exports = logObject
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {}
                ],
                49: [
                  function(require, module, exports) {
                    'use strict'

                    module.exports = {
                      isObject: function(obj) {
                        var type = typeof obj
                        return (
                          type === 'function' || (type === 'object' && !!obj)
                        )
                      },

                      extend: function(obj) {
                        if (!this.isObject(obj)) {
                          return obj
                        }
                        var source, prop
                        for (
                          var i = 1, length = arguments.length;
                          i < length;
                          i++
                        ) {
                          source = arguments[i]
                          for (prop in source) {
                            if (
                              Object.prototype.hasOwnProperty.call(source, prop)
                            ) {
                              obj[prop] = source[prop]
                            }
                          }
                        }
                        return obj
                      }
                    }
                  },
                  {}
                ],
                50: [
                  function(require, module, exports) {
                    'use strict'

                    var crypto = require('crypto')

                    // This string has length 32, a power of 2, so the modulus doesn't introduce a
                    // bias.
                    var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345'
                    module.exports = {
                      string: function(length) {
                        var max = _randomStringChars.length
                        var bytes = crypto.randomBytes(length)
                        var ret = []
                        for (var i = 0; i < length; i++) {
                          ret.push(_randomStringChars.substr(bytes[i] % max, 1))
                        }
                        return ret.join('')
                      },

                      number: function(max) {
                        return Math.floor(Math.random() * max)
                      },

                      numberString: function(max) {
                        var t = ('' + (max - 1)).length
                        var p = new Array(t + 1).join('0')
                        return (p + this.number(max)).slice(-t)
                      }
                    }
                  },
                  { crypto: 43 }
                ],
                51: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')(
                          'sockjs-client:utils:transport'
                        )
                      }

                      module.exports = function(availableTransports) {
                        return {
                          filterToEnabled: function(transportsWhitelist, info) {
                            var transports = {
                              main: [],
                              facade: []
                            }
                            if (!transportsWhitelist) {
                              transportsWhitelist = []
                            } else if (
                              typeof transportsWhitelist === 'string'
                            ) {
                              transportsWhitelist = [transportsWhitelist]
                            }

                            availableTransports.forEach(function(trans) {
                              if (!trans) {
                                return
                              }

                              if (
                                trans.transportName === 'websocket' &&
                                info.websocket === false
                              ) {
                                debug('disabled from server', 'websocket')
                                return
                              }

                              if (
                                transportsWhitelist.length &&
                                transportsWhitelist.indexOf(
                                  trans.transportName
                                ) === -1
                              ) {
                                debug('not in whitelist', trans.transportName)
                                return
                              }

                              if (trans.enabled(info)) {
                                debug('enabled', trans.transportName)
                                transports.main.push(trans)
                                if (trans.facadeTransport) {
                                  transports.facade.push(trans.facadeTransport)
                                }
                              } else {
                                debug('disabled', trans.transportName)
                              }
                            })
                            return transports
                          }
                        }
                      }
                    }.call(this, { env: {} }))
                  },
                  { debug: 55 }
                ],
                52: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      var URL = require('url-parse')

                      var debug = function() {}
                      if (process.env.NODE_ENV !== 'production') {
                        debug = require('debug')('sockjs-client:utils:url')
                      }

                      module.exports = {
                        getOrigin: function(url) {
                          if (!url) {
                            return null
                          }

                          var p = new URL(url)
                          if (p.protocol === 'file:') {
                            return null
                          }

                          var port = p.port
                          if (!port) {
                            port = p.protocol === 'https:' ? '443' : '80'
                          }

                          return p.protocol + '//' + p.hostname + ':' + port
                        },

                        isOriginEqual: function(a, b) {
                          var res = this.getOrigin(a) === this.getOrigin(b)
                          debug('same', a, b, res)
                          return res
                        },

                        isSchemeEqual: function(a, b) {
                          return a.split(':')[0] === b.split(':')[0]
                        },

                        addPath: function(url, path) {
                          var qs = url.split('?')
                          return qs[0] + path + (qs[1] ? '?' + qs[1] : '')
                        },

                        addQuery: function(url, q) {
                          return (
                            url + (url.indexOf('?') === -1 ? '?' + q : '&' + q)
                          )
                        },

                        isLoopbackAddr: function(addr) {
                          return (
                            /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(
                              addr
                            ) || /^\[::1\]$/.test(addr)
                          )
                        }
                      }
                    }.call(this, { env: {} }))
                  },
                  { debug: 55, 'url-parse': 61 }
                ],
                53: [
                  function(require, module, exports) {
                    module.exports = '1.5.0'
                  },
                  {}
                ],
                54: [
                  function(require, module, exports) {
                    /**
                     * Helpers.
                     */

                    var s = 1000
                    var m = s * 60
                    var h = m * 60
                    var d = h * 24
                    var w = d * 7
                    var y = d * 365.25

                    /**
                     * Parse or format the given `val`.
                     *
                     * Options:
                     *
                     *  - `long` verbose formatting [false]
                     *
                     * @param {String|Number} val
                     * @param {Object} [options]
                     * @throws {Error} throw an error if val is not a non-empty string or a number
                     * @return {String|Number}
                     * @api public
                     */

                    module.exports = function(val, options) {
                      options = options || {}
                      var type = typeof val
                      if (type === 'string' && val.length > 0) {
                        return parse(val)
                      } else if (type === 'number' && isFinite(val)) {
                        return options.long ? fmtLong(val) : fmtShort(val)
                      }
                      throw new Error(
                        'val is not a non-empty string or a valid number. val=' +
                          JSON.stringify(val)
                      )
                    }

                    /**
                     * Parse the given `str` and return milliseconds.
                     *
                     * @param {String} str
                     * @return {Number}
                     * @api private
                     */

                    function parse(str) {
                      str = String(str)
                      if (str.length > 100) {
                        return
                      }
                      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                        str
                      )
                      if (!match) {
                        return
                      }
                      var n = parseFloat(match[1])
                      var type = (match[2] || 'ms').toLowerCase()
                      switch (type) {
                        case 'years':
                        case 'year':
                        case 'yrs':
                        case 'yr':
                        case 'y':
                          return n * y
                        case 'weeks':
                        case 'week':
                        case 'w':
                          return n * w
                        case 'days':
                        case 'day':
                        case 'd':
                          return n * d
                        case 'hours':
                        case 'hour':
                        case 'hrs':
                        case 'hr':
                        case 'h':
                          return n * h
                        case 'minutes':
                        case 'minute':
                        case 'mins':
                        case 'min':
                        case 'm':
                          return n * m
                        case 'seconds':
                        case 'second':
                        case 'secs':
                        case 'sec':
                        case 's':
                          return n * s
                        case 'milliseconds':
                        case 'millisecond':
                        case 'msecs':
                        case 'msec':
                        case 'ms':
                          return n
                        default:
                          return undefined
                      }
                    }

                    /**
                     * Short format for `ms`.
                     *
                     * @param {Number} ms
                     * @return {String}
                     * @api private
                     */

                    function fmtShort(ms) {
                      var msAbs = Math.abs(ms)
                      if (msAbs >= d) {
                        return Math.round(ms / d) + 'd'
                      }
                      if (msAbs >= h) {
                        return Math.round(ms / h) + 'h'
                      }
                      if (msAbs >= m) {
                        return Math.round(ms / m) + 'm'
                      }
                      if (msAbs >= s) {
                        return Math.round(ms / s) + 's'
                      }
                      return ms + 'ms'
                    }

                    /**
                     * Long format for `ms`.
                     *
                     * @param {Number} ms
                     * @return {String}
                     * @api private
                     */

                    function fmtLong(ms) {
                      var msAbs = Math.abs(ms)
                      if (msAbs >= d) {
                        return plural(ms, msAbs, d, 'day')
                      }
                      if (msAbs >= h) {
                        return plural(ms, msAbs, h, 'hour')
                      }
                      if (msAbs >= m) {
                        return plural(ms, msAbs, m, 'minute')
                      }
                      if (msAbs >= s) {
                        return plural(ms, msAbs, s, 'second')
                      }
                      return ms + ' ms'
                    }

                    /**
                     * Pluralization helper.
                     */

                    function plural(ms, msAbs, n, name) {
                      var isPlural = msAbs >= n * 1.5
                      return (
                        Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '')
                      )
                    }
                  },
                  {}
                ],
                55: [
                  function(require, module, exports) {
                    ;(function(process) {
                      'use strict'

                      function _typeof(obj) {
                        if (
                          typeof Symbol === 'function' &&
                          typeof Symbol.iterator === 'symbol'
                        ) {
                          _typeof = function _typeof(obj) {
                            return typeof obj
                          }
                        } else {
                          _typeof = function _typeof(obj) {
                            return obj &&
                              typeof Symbol === 'function' &&
                              obj.constructor === Symbol &&
                              obj !== Symbol.prototype
                              ? 'symbol'
                              : typeof obj
                          }
                        }
                        return _typeof(obj)
                      }

                      /* eslint-env browser */

                      /**
                       * This is the web browser implementation of `debug()`.
                       */
                      exports.log = log
                      exports.formatArgs = formatArgs
                      exports.save = save
                      exports.load = load
                      exports.useColors = useColors
                      exports.storage = localstorage()
                      /**
                       * Colors.
                       */

                      exports.colors = [
                        '#0000CC',
                        '#0000FF',
                        '#0033CC',
                        '#0033FF',
                        '#0066CC',
                        '#0066FF',
                        '#0099CC',
                        '#0099FF',
                        '#00CC00',
                        '#00CC33',
                        '#00CC66',
                        '#00CC99',
                        '#00CCCC',
                        '#00CCFF',
                        '#3300CC',
                        '#3300FF',
                        '#3333CC',
                        '#3333FF',
                        '#3366CC',
                        '#3366FF',
                        '#3399CC',
                        '#3399FF',
                        '#33CC00',
                        '#33CC33',
                        '#33CC66',
                        '#33CC99',
                        '#33CCCC',
                        '#33CCFF',
                        '#6600CC',
                        '#6600FF',
                        '#6633CC',
                        '#6633FF',
                        '#66CC00',
                        '#66CC33',
                        '#9900CC',
                        '#9900FF',
                        '#9933CC',
                        '#9933FF',
                        '#99CC00',
                        '#99CC33',
                        '#CC0000',
                        '#CC0033',
                        '#CC0066',
                        '#CC0099',
                        '#CC00CC',
                        '#CC00FF',
                        '#CC3300',
                        '#CC3333',
                        '#CC3366',
                        '#CC3399',
                        '#CC33CC',
                        '#CC33FF',
                        '#CC6600',
                        '#CC6633',
                        '#CC9900',
                        '#CC9933',
                        '#CCCC00',
                        '#CCCC33',
                        '#FF0000',
                        '#FF0033',
                        '#FF0066',
                        '#FF0099',
                        '#FF00CC',
                        '#FF00FF',
                        '#FF3300',
                        '#FF3333',
                        '#FF3366',
                        '#FF3399',
                        '#FF33CC',
                        '#FF33FF',
                        '#FF6600',
                        '#FF6633',
                        '#FF9900',
                        '#FF9933',
                        '#FFCC00',
                        '#FFCC33'
                      ]
                      /**
                       * Currently only WebKit-based Web Inspectors, Firefox >= v31,
                       * and the Firebug extension (any Firefox version) are known
                       * to support "%c" CSS customizations.
                       *
                       * TODO: add a `localStorage` variable to explicitly enable/disable colors
                       */
                      // eslint-disable-next-line complexity

                      function useColors() {
                        // NB: In an Electron preload script, document will be defined but not fully
                        // initialized. Since we know we're in Chrome, we'll just detect this case
                        // explicitly
                        if (
                          typeof window !== 'undefined' &&
                          window.process &&
                          (window.process.type === 'renderer' ||
                            window.process.__nwjs)
                        ) {
                          return true
                        } // Internet Explorer and Edge do not support colors.

                        if (
                          typeof navigator !== 'undefined' &&
                          navigator.userAgent &&
                          navigator.userAgent
                            .toLowerCase()
                            .match(/(edge|trident)\/(\d+)/)
                        ) {
                          return false
                        } // Is webkit? http://stackoverflow.com/a/16459606/376773
                        // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632

                        return (
                          (typeof document !== 'undefined' &&
                            document.documentElement &&
                            document.documentElement.style &&
                            document.documentElement.style.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
                          (typeof window !== 'undefined' &&
                            window.console &&
                            (window.console.firebug ||
                              (window.console.exception &&
                                window.console.table))) || // Is firefox >= v31?
                          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                          (typeof navigator !== 'undefined' &&
                            navigator.userAgent &&
                            navigator.userAgent
                              .toLowerCase()
                              .match(/firefox\/(\d+)/) &&
                            parseInt(RegExp.$1, 10) >= 31) || // Double check webkit in userAgent just in case we are in a worker
                          (typeof navigator !== 'undefined' &&
                            navigator.userAgent &&
                            navigator.userAgent
                              .toLowerCase()
                              .match(/applewebkit\/(\d+)/))
                        )
                      }
                      /**
                       * Colorize log arguments if enabled.
                       *
                       * @api public
                       */

                      function formatArgs(args) {
                        args[0] =
                          (this.useColors ? '%c' : '') +
                          this.namespace +
                          (this.useColors ? ' %c' : ' ') +
                          args[0] +
                          (this.useColors ? '%c ' : ' ') +
                          '+' +
                          module.exports.humanize(this.diff)

                        if (!this.useColors) {
                          return
                        }

                        var c = 'color: ' + this.color
                        args.splice(1, 0, c, 'color: inherit') // The final "%c" is somewhat tricky, because there could be other
                        // arguments passed either before or after the %c, so we need to
                        // figure out the correct index to insert the CSS into

                        var index = 0
                        var lastC = 0
                        args[0].replace(/%[a-zA-Z%]/g, function(match) {
                          if (match === '%%') {
                            return
                          }

                          index++

                          if (match === '%c') {
                            // We only are interested in the *last* %c
                            // (the user may have provided their own)
                            lastC = index
                          }
                        })
                        args.splice(lastC, 0, c)
                      }
                      /**
                       * Invokes `console.log()` when available.
                       * No-op when `console.log` is not a "function".
                       *
                       * @api public
                       */

                      function log() {
                        var _console

                        // This hackery is required for IE8/9, where
                        // the `console.log` function doesn't have 'apply'
                        return (
                          (typeof console === 'undefined'
                            ? 'undefined'
                            : _typeof(console)) === 'object' &&
                          console.log &&
                          (_console = console).log.apply(_console, arguments)
                        )
                      }
                      /**
                       * Save `namespaces`.
                       *
                       * @param {String} namespaces
                       * @api private
                       */

                      function save(namespaces) {
                        try {
                          if (namespaces) {
                            exports.storage.setItem('debug', namespaces)
                          } else {
                            exports.storage.removeItem('debug')
                          }
                        } catch (error) {
                          // Swallow
                          // XXX (@Qix-) should we be logging these?
                        }
                      }
                      /**
                       * Load `namespaces`.
                       *
                       * @return {String} returns the previously persisted debug modes
                       * @api private
                       */

                      function load() {
                        var r

                        try {
                          r = exports.storage.getItem('debug')
                        } catch (error) {} // Swallow
                        // XXX (@Qix-) should we be logging these?
                        // If debug isn't set in LS, and we're in Electron, try to load $DEBUG

                        if (
                          !r &&
                          typeof process !== 'undefined' &&
                          'env' in process
                        ) {
                          r = process.env.DEBUG
                        }

                        return r
                      }
                      /**
                       * Localstorage attempts to return the localstorage.
                       *
                       * This is necessary because safari throws
                       * when a user disables cookies/localstorage
                       * and you attempt to access it.
                       *
                       * @return {LocalStorage}
                       * @api private
                       */

                      function localstorage() {
                        try {
                          // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
                          // The Browser also has localStorage in the global context.
                          return localStorage
                        } catch (error) {
                          // Swallow
                          // XXX (@Qix-) should we be logging these?
                        }
                      }

                      module.exports = require('./common')(exports)
                      var formatters = module.exports.formatters
                      /**
                       * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
                       */

                      formatters.j = function(v) {
                        try {
                          return JSON.stringify(v)
                        } catch (error) {
                          return '[UnexpectedJSONParseError]: ' + error.message
                        }
                      }
                    }.call(this, { env: {} }))
                  },
                  { './common': 56 }
                ],
                56: [
                  function(require, module, exports) {
                    'use strict'

                    /**
                     * This is the common logic for both the Node.js and web browser
                     * implementations of `debug()`.
                     */
                    function setup(env) {
                      createDebug.debug = createDebug
                      createDebug.default = createDebug
                      createDebug.coerce = coerce
                      createDebug.disable = disable
                      createDebug.enable = enable
                      createDebug.enabled = enabled
                      createDebug.humanize = require('ms')
                      Object.keys(env).forEach(function(key) {
                        createDebug[key] = env[key]
                      })
                      /**
                       * Active `debug` instances.
                       */

                      createDebug.instances = []
                      /**
                       * The currently active debug mode names, and names to skip.
                       */

                      createDebug.names = []
                      createDebug.skips = []
                      /**
                       * Map of special "%n" handling functions, for the debug "format" argument.
                       *
                       * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
                       */

                      createDebug.formatters = {}
                      /**
                       * Selects a color for a debug namespace
                       * @param {String} namespace The namespace string for the for the debug instance to be colored
                       * @return {Number|String} An ANSI color code for the given namespace
                       * @api private
                       */

                      function selectColor(namespace) {
                        var hash = 0

                        for (var i = 0; i < namespace.length; i++) {
                          hash = (hash << 5) - hash + namespace.charCodeAt(i)
                          hash |= 0 // Convert to 32bit integer
                        }

                        return createDebug.colors[
                          Math.abs(hash) % createDebug.colors.length
                        ]
                      }

                      createDebug.selectColor = selectColor
                      /**
                       * Create a debugger with the given `namespace`.
                       *
                       * @param {String} namespace
                       * @return {Function}
                       * @api public
                       */

                      function createDebug(namespace) {
                        var prevTime

                        function debug() {
                          // Disabled?
                          if (!debug.enabled) {
                            return
                          }

                          for (
                            var _len = arguments.length,
                              args = new Array(_len),
                              _key = 0;
                            _key < _len;
                            _key++
                          ) {
                            args[_key] = arguments[_key]
                          }

                          var self = debug // Set `diff` timestamp

                          var curr = Number(new Date())
                          var ms = curr - (prevTime || curr)
                          self.diff = ms
                          self.prev = prevTime
                          self.curr = curr
                          prevTime = curr
                          args[0] = createDebug.coerce(args[0])

                          if (typeof args[0] !== 'string') {
                            // Anything else let's inspect with %O
                            args.unshift('%O')
                          } // Apply any `formatters` transformations

                          var index = 0
                          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(
                            match,
                            format
                          ) {
                            // If we encounter an escaped % then don't increase the array index
                            if (match === '%%') {
                              return match
                            }

                            index++
                            var formatter = createDebug.formatters[format]

                            if (typeof formatter === 'function') {
                              var val = args[index]
                              match = formatter.call(self, val) // Now we need to remove `args[index]` since it's inlined in the `format`

                              args.splice(index, 1)
                              index--
                            }

                            return match
                          }) // Apply env-specific formatting (colors, etc.)

                          createDebug.formatArgs.call(self, args)
                          var logFn = self.log || createDebug.log
                          logFn.apply(self, args)
                        }

                        debug.namespace = namespace
                        debug.enabled = createDebug.enabled(namespace)
                        debug.useColors = createDebug.useColors()
                        debug.color = selectColor(namespace)
                        debug.destroy = destroy
                        debug.extend = extend // Debug.formatArgs = formatArgs;
                        // debug.rawLog = rawLog;
                        // env-specific initialization logic for debug instances

                        if (typeof createDebug.init === 'function') {
                          createDebug.init(debug)
                        }

                        createDebug.instances.push(debug)
                        return debug
                      }

                      function destroy() {
                        var index = createDebug.instances.indexOf(this)

                        if (index !== -1) {
                          createDebug.instances.splice(index, 1)
                          return true
                        }

                        return false
                      }

                      function extend(namespace, delimiter) {
                        return createDebug(
                          this.namespace +
                            (typeof delimiter === 'undefined'
                              ? ':'
                              : delimiter) +
                            namespace
                        )
                      }
                      /**
                       * Enables a debug mode by namespaces. This can include modes
                       * separated by a colon and wildcards.
                       *
                       * @param {String} namespaces
                       * @api public
                       */

                      function enable(namespaces) {
                        createDebug.save(namespaces)
                        createDebug.names = []
                        createDebug.skips = []
                        var i
                        var split = (typeof namespaces === 'string'
                          ? namespaces
                          : ''
                        ).split(/[\s,]+/)
                        var len = split.length

                        for (i = 0; i < len; i++) {
                          if (!split[i]) {
                            // ignore empty strings
                            continue
                          }

                          namespaces = split[i].replace(/\*/g, '.*?')

                          if (namespaces[0] === '-') {
                            createDebug.skips.push(
                              new RegExp('^' + namespaces.substr(1) + '$')
                            )
                          } else {
                            createDebug.names.push(
                              new RegExp('^' + namespaces + '$')
                            )
                          }
                        }

                        for (i = 0; i < createDebug.instances.length; i++) {
                          var instance = createDebug.instances[i]
                          instance.enabled = createDebug.enabled(
                            instance.namespace
                          )
                        }
                      }
                      /**
                       * Disable debug output.
                       *
                       * @api public
                       */

                      function disable() {
                        createDebug.enable('')
                      }
                      /**
                       * Returns true if the given mode name is enabled, false otherwise.
                       *
                       * @param {String} name
                       * @return {Boolean}
                       * @api public
                       */

                      function enabled(name) {
                        if (name[name.length - 1] === '*') {
                          return true
                        }

                        var i
                        var len

                        for (
                          i = 0, len = createDebug.skips.length;
                          i < len;
                          i++
                        ) {
                          if (createDebug.skips[i].test(name)) {
                            return false
                          }
                        }

                        for (
                          i = 0, len = createDebug.names.length;
                          i < len;
                          i++
                        ) {
                          if (createDebug.names[i].test(name)) {
                            return true
                          }
                        }

                        return false
                      }
                      /**
                       * Coerce `val`.
                       *
                       * @param {Mixed} val
                       * @return {Mixed}
                       * @api private
                       */

                      function coerce(val) {
                        if (val instanceof Error) {
                          return val.stack || val.message
                        }

                        return val
                      }

                      createDebug.enable(createDebug.load())
                      return createDebug
                    }

                    module.exports = setup
                  },
                  { ms: 54 }
                ],
                57: [
                  function(require, module, exports) {
                    if (typeof Object.create === 'function') {
                      // implementation from standard node.js 'util' module
                      module.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                          ctor.super_ = superCtor
                          ctor.prototype = Object.create(superCtor.prototype, {
                            constructor: {
                              value: ctor,
                              enumerable: false,
                              writable: true,
                              configurable: true
                            }
                          })
                        }
                      }
                    } else {
                      // old school shim for old browsers
                      module.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                          ctor.super_ = superCtor
                          var TempCtor = function() {}
                          TempCtor.prototype = superCtor.prototype
                          ctor.prototype = new TempCtor()
                          ctor.prototype.constructor = ctor
                        }
                      }
                    }
                  },
                  {}
                ],
                58: [
                  function(require, module, exports) {
                    ;(function(global) {
                      /*! JSON v3.3.2 | https://bestiejs.github.io/json3 | Copyright 2012-2015, Kit Cambridge, Benjamin Tan | http://kit.mit-license.org */
                      ;(function() {
                        // Detect the `define` function exposed by asynchronous module loaders. The
                        // strict `define` check is necessary for compatibility with `r.js`.
                        var isLoader =
                          typeof define === 'function' && define.amd

                        // A set of types used to distinguish objects from primitives.
                        var objectTypes = {
                          function: true,
                          object: true
                        }

                        // Detect the `exports` object exposed by CommonJS implementations.
                        var freeExports =
                          objectTypes[typeof exports] &&
                          exports &&
                          !exports.nodeType &&
                          exports

                        // Use the `global` object exposed by Node (including Browserify via
                        // `insert-module-globals`), Narwhal, and Ringo as the default context,
                        // and the `window` object in browsers. Rhino exports a `global` function
                        // instead.
                        var root =
                            (objectTypes[typeof window] && window) || this,
                          freeGlobal =
                            freeExports &&
                            objectTypes[typeof module] &&
                            module &&
                            !module.nodeType &&
                            typeof global == 'object' &&
                            global

                        if (
                          freeGlobal &&
                          (freeGlobal.global === freeGlobal ||
                            freeGlobal.window === freeGlobal ||
                            freeGlobal.self === freeGlobal)
                        ) {
                          root = freeGlobal
                        }

                        // Public: Initializes JSON 3 using the given `context` object, attaching the
                        // `stringify` and `parse` functions to the specified `exports` object.
                        function runInContext(context, exports) {
                          context || (context = root.Object())
                          exports || (exports = root.Object())

                          // Native constructor aliases.
                          var Number = context.Number || root.Number,
                            String = context.String || root.String,
                            Object = context.Object || root.Object,
                            Date = context.Date || root.Date,
                            SyntaxError =
                              context.SyntaxError || root.SyntaxError,
                            TypeError = context.TypeError || root.TypeError,
                            Math = context.Math || root.Math,
                            nativeJSON = context.JSON || root.JSON

                          // Delegate to the native `stringify` and `parse` implementations.
                          if (typeof nativeJSON == 'object' && nativeJSON) {
                            exports.stringify = nativeJSON.stringify
                            exports.parse = nativeJSON.parse
                          }

                          // Convenience aliases.
                          var objectProto = Object.prototype,
                            getClass = objectProto.toString,
                            isProperty = objectProto.hasOwnProperty,
                            undefined

                          // Internal: Contains `try...catch` logic used by other functions.
                          // This prevents other functions from being deoptimized.
                          function attempt(func, errorFunc) {
                            try {
                              func()
                            } catch (exception) {
                              if (errorFunc) {
                                errorFunc()
                              }
                            }
                          }

                          // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
                          var isExtended = new Date(-3509827334573292)
                          attempt(function() {
                            // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
                            // results for certain dates in Opera >= 10.53.
                            isExtended =
                              isExtended.getUTCFullYear() == -109252 &&
                              isExtended.getUTCMonth() === 0 &&
                              isExtended.getUTCDate() === 1 &&
                              isExtended.getUTCHours() == 10 &&
                              isExtended.getUTCMinutes() == 37 &&
                              isExtended.getUTCSeconds() == 6 &&
                              isExtended.getUTCMilliseconds() == 708
                          })

                          // Internal: Determines whether the native `JSON.stringify` and `parse`
                          // implementations are spec-compliant. Based on work by Ken Snyder.
                          function has(name) {
                            if (has[name] != null) {
                              // Return cached feature test result.
                              return has[name]
                            }
                            var isSupported
                            if (name == 'bug-string-char-index') {
                              // IE <= 7 doesn't support accessing string characters using square
                              // bracket notation. IE 8 only supports this for primitives.
                              isSupported = 'a'[0] != 'a'
                            } else if (name == 'json') {
                              // Indicates whether both `JSON.stringify` and `JSON.parse` are
                              // supported.
                              isSupported =
                                has('json-stringify') &&
                                has('date-serialization') &&
                                has('json-parse')
                            } else if (name == 'date-serialization') {
                              // Indicates whether `Date`s can be serialized accurately by `JSON.stringify`.
                              isSupported = has('json-stringify') && isExtended
                              if (isSupported) {
                                var stringify = exports.stringify
                                attempt(function() {
                                  isSupported =
                                    // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                                    // serialize extended years.
                                    stringify(new Date(-8.64e15)) ==
                                      '"-271821-04-20T00:00:00.000Z"' &&
                                    // The milliseconds are optional in ES 5, but required in 5.1.
                                    stringify(new Date(8.64e15)) ==
                                      '"+275760-09-13T00:00:00.000Z"' &&
                                    // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                                    // four-digit years instead of six-digit years. Credits: @Yaffle.
                                    stringify(new Date(-621987552e5)) ==
                                      '"-000001-01-01T00:00:00.000Z"' &&
                                    // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                                    // values less than 1000. Credits: @Yaffle.
                                    stringify(new Date(-1)) ==
                                      '"1969-12-31T23:59:59.999Z"'
                                })
                              }
                            } else {
                              var value,
                                serialized =
                                  '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}'
                              // Test `JSON.stringify`.
                              if (name == 'json-stringify') {
                                var stringify = exports.stringify,
                                  stringifySupported =
                                    typeof stringify == 'function'
                                if (stringifySupported) {
                                  // A test function object with a custom `toJSON` method.
                                  ;(value = function() {
                                    return 1
                                  }).toJSON = value
                                  attempt(
                                    function() {
                                      stringifySupported =
                                        // Firefox 3.1b1 and b2 serialize string, number, and boolean
                                        // primitives as object literals.
                                        stringify(0) === '0' &&
                                        // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                                        // literals.
                                        stringify(new Number()) === '0' &&
                                        stringify(new String()) == '""' &&
                                        // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                                        // does not define a canonical JSON representation (this applies to
                                        // objects with `toJSON` properties as well, *unless* they are nested
                                        // within an object or array).
                                        stringify(getClass) === undefined &&
                                        // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                                        // FF 3.1b3 pass this test.
                                        stringify(undefined) === undefined &&
                                        // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                                        // respectively, if the value is omitted entirely.
                                        stringify() === undefined &&
                                        // FF 3.1b1, 2 throw an error if the given value is not a number,
                                        // string, array, object, Boolean, or `null` literal. This applies to
                                        // objects with custom `toJSON` methods as well, unless they are nested
                                        // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                                        // methods entirely.
                                        stringify(value) === '1' &&
                                        stringify([value]) == '[1]' &&
                                        // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                                        // `"[null]"`.
                                        stringify([undefined]) == '[null]' &&
                                        // YUI 3.0.0b1 fails to serialize `null` literals.
                                        stringify(null) == 'null' &&
                                        // FF 3.1b1, 2 halts serialization if an array contains a function:
                                        // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                                        // elides non-JSON values from objects and arrays, unless they
                                        // define custom `toJSON` methods.
                                        stringify([
                                          undefined,
                                          getClass,
                                          null
                                        ]) == '[null,null,null]' &&
                                        // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                                        // where character escape codes are expected (e.g., `\b` => `\u0008`).
                                        stringify({
                                          a: [
                                            value,
                                            true,
                                            false,
                                            null,
                                            '\x00\b\n\f\r\t'
                                          ]
                                        }) == serialized &&
                                        // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                                        stringify(null, value) === '1' &&
                                        stringify([1, 2], null, 1) ==
                                          '[\n 1,\n 2\n]'
                                    },
                                    function() {
                                      stringifySupported = false
                                    }
                                  )
                                }
                                isSupported = stringifySupported
                              }
                              // Test `JSON.parse`.
                              if (name == 'json-parse') {
                                var parse = exports.parse,
                                  parseSupported
                                if (typeof parse == 'function') {
                                  attempt(
                                    function() {
                                      // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                                      // Conforming implementations should also coerce the initial argument to
                                      // a string prior to parsing.
                                      if (parse('0') === 0 && !parse(false)) {
                                        // Simple parsing test.
                                        value = parse(serialized)
                                        parseSupported =
                                          value['a'].length == 5 &&
                                          value['a'][0] === 1
                                        if (parseSupported) {
                                          attempt(function() {
                                            // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                                            parseSupported = !parse('"\t"')
                                          })
                                          if (parseSupported) {
                                            attempt(function() {
                                              // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                                              // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                                              // certain octal literals.
                                              parseSupported = parse('01') !== 1
                                            })
                                          }
                                          if (parseSupported) {
                                            attempt(function() {
                                              // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                                              // points. These environments, along with FF 3.1b1 and 2,
                                              // also allow trailing commas in JSON objects and arrays.
                                              parseSupported = parse('1.') !== 1
                                            })
                                          }
                                        }
                                      }
                                    },
                                    function() {
                                      parseSupported = false
                                    }
                                  )
                                }
                                isSupported = parseSupported
                              }
                            }
                            return (has[name] = !!isSupported)
                          }
                          has['bug-string-char-index'] = has[
                            'date-serialization'
                          ] = has['json'] = has['json-stringify'] = has[
                            'json-parse'
                          ] = null

                          if (!has('json')) {
                            // Common `[[Class]]` name aliases.
                            var functionClass = '[object Function]',
                              dateClass = '[object Date]',
                              numberClass = '[object Number]',
                              stringClass = '[object String]',
                              arrayClass = '[object Array]',
                              booleanClass = '[object Boolean]'

                            // Detect incomplete support for accessing string characters by index.
                            var charIndexBuggy = has('bug-string-char-index')

                            // Internal: Normalizes the `for...in` iteration algorithm across
                            // environments. Each enumerated key is yielded to a `callback` function.
                            var forOwn = function(object, callback) {
                              var size = 0,
                                Properties,
                                dontEnums,
                                property

                              // Tests for bugs in the current environment's `for...in` algorithm. The
                              // `valueOf` property inherits the non-enumerable flag from
                              // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
                              ;(Properties = function() {
                                this.valueOf = 0
                              }).prototype.valueOf = 0

                              // Iterate over a new instance of the `Properties` class.
                              dontEnums = new Properties()
                              for (property in dontEnums) {
                                // Ignore all properties inherited from `Object.prototype`.
                                if (isProperty.call(dontEnums, property)) {
                                  size++
                                }
                              }
                              Properties = dontEnums = null

                              // Normalize the iteration algorithm.
                              if (!size) {
                                // A list of non-enumerable properties inherited from `Object.prototype`.
                                dontEnums = [
                                  'valueOf',
                                  'toString',
                                  'toLocaleString',
                                  'propertyIsEnumerable',
                                  'isPrototypeOf',
                                  'hasOwnProperty',
                                  'constructor'
                                ]
                                // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
                                // properties.
                                forOwn = function(object, callback) {
                                  var isFunction =
                                      getClass.call(object) == functionClass,
                                    property,
                                    length
                                  var hasProperty =
                                    (!isFunction &&
                                      typeof object.constructor != 'function' &&
                                      objectTypes[
                                        typeof object.hasOwnProperty
                                      ] &&
                                      object.hasOwnProperty) ||
                                    isProperty
                                  for (property in object) {
                                    // Gecko <= 1.0 enumerates the `prototype` property of functions under
                                    // certain conditions; IE does not.
                                    if (
                                      !(
                                        isFunction && property == 'prototype'
                                      ) &&
                                      hasProperty.call(object, property)
                                    ) {
                                      callback(property)
                                    }
                                  }
                                  // Manually invoke the callback for each non-enumerable property.
                                  for (
                                    length = dontEnums.length;
                                    (property = dontEnums[--length]);

                                  ) {
                                    if (hasProperty.call(object, property)) {
                                      callback(property)
                                    }
                                  }
                                }
                              } else {
                                // No bugs detected; use the standard `for...in` algorithm.
                                forOwn = function(object, callback) {
                                  var isFunction =
                                      getClass.call(object) == functionClass,
                                    property,
                                    isConstructor
                                  for (property in object) {
                                    if (
                                      !(
                                        isFunction && property == 'prototype'
                                      ) &&
                                      isProperty.call(object, property) &&
                                      !(isConstructor =
                                        property === 'constructor')
                                    ) {
                                      callback(property)
                                    }
                                  }
                                  // Manually invoke the callback for the `constructor` property due to
                                  // cross-environment inconsistencies.
                                  if (
                                    isConstructor ||
                                    isProperty.call(
                                      object,
                                      (property = 'constructor')
                                    )
                                  ) {
                                    callback(property)
                                  }
                                }
                              }
                              return forOwn(object, callback)
                            }

                            // Public: Serializes a JavaScript `value` as a JSON string. The optional
                            // `filter` argument may specify either a function that alters how object and
                            // array members are serialized, or an array of strings and numbers that
                            // indicates which properties should be serialized. The optional `width`
                            // argument may be either a string or number that specifies the indentation
                            // level of the output.
                            if (
                              !has('json-stringify') &&
                              !has('date-serialization')
                            ) {
                              // Internal: A map of control characters and their escaped equivalents.
                              var Escapes = {
                                92: '\\\\',
                                34: '\\"',
                                8: '\\b',
                                12: '\\f',
                                10: '\\n',
                                13: '\\r',
                                9: '\\t'
                              }

                              // Internal: Converts `value` into a zero-padded string such that its
                              // length is at least equal to `width`. The `width` must be <= 6.
                              var leadingZeroes = '000000'
                              var toPaddedString = function(width, value) {
                                // The `|| 0` expression is necessary to work around a bug in
                                // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
                                return (leadingZeroes + (value || 0)).slice(
                                  -width
                                )
                              }

                              // Internal: Serializes a date object.
                              var serializeDate = function(value) {
                                var getData,
                                  year,
                                  month,
                                  date,
                                  time,
                                  hours,
                                  minutes,
                                  seconds,
                                  milliseconds
                                // Define additional utility methods if the `Date` methods are buggy.
                                if (!isExtended) {
                                  var floor = Math.floor
                                  // A mapping between the months of the year and the number of days between
                                  // January 1st and the first of the respective month.
                                  var Months = [
                                    0,
                                    31,
                                    59,
                                    90,
                                    120,
                                    151,
                                    181,
                                    212,
                                    243,
                                    273,
                                    304,
                                    334
                                  ]
                                  // Internal: Calculates the number of days between the Unix epoch and the
                                  // first day of the given month.
                                  var getDay = function(year, month) {
                                    return (
                                      Months[month] +
                                      365 * (year - 1970) +
                                      floor(
                                        (year - 1969 + (month = +(month > 1))) /
                                          4
                                      ) -
                                      floor((year - 1901 + month) / 100) +
                                      floor((year - 1601 + month) / 400)
                                    )
                                  }
                                  getData = function(value) {
                                    // Manually compute the year, month, date, hours, minutes,
                                    // seconds, and milliseconds if the `getUTC*` methods are
                                    // buggy. Adapted from @Yaffle's `date-shim` project.
                                    date = floor(value / 864e5)
                                    for (
                                      year = floor(date / 365.2425) + 1970 - 1;
                                      getDay(year + 1, 0) <= date;
                                      year++
                                    );
                                    for (
                                      month = floor(
                                        (date - getDay(year, 0)) / 30.42
                                      );
                                      getDay(year, month + 1) <= date;
                                      month++
                                    );
                                    date = 1 + date - getDay(year, month)
                                    // The `time` value specifies the time within the day (see ES
                                    // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                                    // to compute `A modulo B`, as the `%` operator does not
                                    // correspond to the `modulo` operation for negative numbers.
                                    time = ((value % 864e5) + 864e5) % 864e5
                                    // The hours, minutes, seconds, and milliseconds are obtained by
                                    // decomposing the time within the day. See section 15.9.1.10.
                                    hours = floor(time / 36e5) % 24
                                    minutes = floor(time / 6e4) % 60
                                    seconds = floor(time / 1e3) % 60
                                    milliseconds = time % 1e3
                                  }
                                } else {
                                  getData = function(value) {
                                    year = value.getUTCFullYear()
                                    month = value.getUTCMonth()
                                    date = value.getUTCDate()
                                    hours = value.getUTCHours()
                                    minutes = value.getUTCMinutes()
                                    seconds = value.getUTCSeconds()
                                    milliseconds = value.getUTCMilliseconds()
                                  }
                                }
                                serializeDate = function(value) {
                                  if (value > -1 / 0 && value < 1 / 0) {
                                    // Dates are serialized according to the `Date#toJSON` method
                                    // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                                    // for the ISO 8601 date time string format.
                                    getData(value)
                                    // Serialize extended years correctly.
                                    value =
                                      (year <= 0 || year >= 1e4
                                        ? (year < 0 ? '-' : '+') +
                                          toPaddedString(
                                            6,
                                            year < 0 ? -year : year
                                          )
                                        : toPaddedString(4, year)) +
                                      '-' +
                                      toPaddedString(2, month + 1) +
                                      '-' +
                                      toPaddedString(2, date) +
                                      // Months, dates, hours, minutes, and seconds should have two
                                      // digits; milliseconds should have three.
                                      'T' +
                                      toPaddedString(2, hours) +
                                      ':' +
                                      toPaddedString(2, minutes) +
                                      ':' +
                                      toPaddedString(2, seconds) +
                                      // Milliseconds are optional in ES 5.0, but required in 5.1.
                                      '.' +
                                      toPaddedString(3, milliseconds) +
                                      'Z'
                                    year = month = date = hours = minutes = seconds = milliseconds = null
                                  } else {
                                    value = null
                                  }
                                  return value
                                }
                                return serializeDate(value)
                              }

                              // For environments with `JSON.stringify` but buggy date serialization,
                              // we override the native `Date#toJSON` implementation with a
                              // spec-compliant one.
                              if (
                                has('json-stringify') &&
                                !has('date-serialization')
                              ) {
                                // Internal: the `Date#toJSON` implementation used to override the native one.
                                function dateToJSON(key) {
                                  return serializeDate(this)
                                }

                                // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
                                var nativeStringify = exports.stringify
                                exports.stringify = function(
                                  source,
                                  filter,
                                  width
                                ) {
                                  var nativeToJSON = Date.prototype.toJSON
                                  Date.prototype.toJSON = dateToJSON
                                  var result = nativeStringify(
                                    source,
                                    filter,
                                    width
                                  )
                                  Date.prototype.toJSON = nativeToJSON
                                  return result
                                }
                              } else {
                                // Internal: Double-quotes a string `value`, replacing all ASCII control
                                // characters (characters with code unit values between 0 and 31) with
                                // their escaped equivalents. This is an implementation of the
                                // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
                                var unicodePrefix = '\\u00'
                                var escapeChar = function(character) {
                                  var charCode = character.charCodeAt(0),
                                    escaped = Escapes[charCode]
                                  if (escaped) {
                                    return escaped
                                  }
                                  return (
                                    unicodePrefix +
                                    toPaddedString(2, charCode.toString(16))
                                  )
                                }
                                var reEscape = /[\x00-\x1f\x22\x5c]/g
                                var quote = function(value) {
                                  reEscape.lastIndex = 0
                                  return (
                                    '"' +
                                    (reEscape.test(value)
                                      ? value.replace(reEscape, escapeChar)
                                      : value) +
                                    '"'
                                  )
                                }

                                // Internal: Recursively serializes an object. Implements the
                                // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
                                var serialize = function(
                                  property,
                                  object,
                                  callback,
                                  properties,
                                  whitespace,
                                  indentation,
                                  stack
                                ) {
                                  var value,
                                    type,
                                    className,
                                    results,
                                    element,
                                    index,
                                    length,
                                    prefix,
                                    result
                                  attempt(function() {
                                    // Necessary for host object support.
                                    value = object[property]
                                  })
                                  if (typeof value == 'object' && value) {
                                    if (
                                      value.getUTCFullYear &&
                                      getClass.call(value) == dateClass &&
                                      value.toJSON === Date.prototype.toJSON
                                    ) {
                                      value = serializeDate(value)
                                    } else if (
                                      typeof value.toJSON == 'function'
                                    ) {
                                      value = value.toJSON(property)
                                    }
                                  }
                                  if (callback) {
                                    // If a replacement function was provided, call it to obtain the value
                                    // for serialization.
                                    value = callback.call(
                                      object,
                                      property,
                                      value
                                    )
                                  }
                                  // Exit early if value is `undefined` or `null`.
                                  if (value == undefined) {
                                    return value === undefined ? value : 'null'
                                  }
                                  type = typeof value
                                  // Only call `getClass` if the value is an object.
                                  if (type == 'object') {
                                    className = getClass.call(value)
                                  }
                                  switch (className || type) {
                                    case 'boolean':
                                    case booleanClass:
                                      // Booleans are represented literally.
                                      return '' + value
                                    case 'number':
                                    case numberClass:
                                      // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                                      // `"null"`.
                                      return value > -1 / 0 && value < 1 / 0
                                        ? '' + value
                                        : 'null'
                                    case 'string':
                                    case stringClass:
                                      // Strings are double-quoted and escaped.
                                      return quote('' + value)
                                  }
                                  // Recursively serialize objects and arrays.
                                  if (typeof value == 'object') {
                                    // Check for cyclic structures. This is a linear search; performance
                                    // is inversely proportional to the number of unique nested objects.
                                    for (length = stack.length; length--; ) {
                                      if (stack[length] === value) {
                                        // Cyclic structures cannot be serialized by `JSON.stringify`.
                                        throw TypeError()
                                      }
                                    }
                                    // Add the object to the stack of traversed objects.
                                    stack.push(value)
                                    results = []
                                    // Save the current indentation level and indent one additional level.
                                    prefix = indentation
                                    indentation += whitespace
                                    if (className == arrayClass) {
                                      // Recursively serialize array elements.
                                      for (
                                        index = 0, length = value.length;
                                        index < length;
                                        index++
                                      ) {
                                        element = serialize(
                                          index,
                                          value,
                                          callback,
                                          properties,
                                          whitespace,
                                          indentation,
                                          stack
                                        )
                                        results.push(
                                          element === undefined
                                            ? 'null'
                                            : element
                                        )
                                      }
                                      result = results.length
                                        ? whitespace
                                          ? '[\n' +
                                            indentation +
                                            results.join(',\n' + indentation) +
                                            '\n' +
                                            prefix +
                                            ']'
                                          : '[' + results.join(',') + ']'
                                        : '[]'
                                    } else {
                                      // Recursively serialize object members. Members are selected from
                                      // either a user-specified list of property names, or the object
                                      // itself.
                                      forOwn(properties || value, function(
                                        property
                                      ) {
                                        var element = serialize(
                                          property,
                                          value,
                                          callback,
                                          properties,
                                          whitespace,
                                          indentation,
                                          stack
                                        )
                                        if (element !== undefined) {
                                          // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                                          // is not the empty string, let `member` {quote(property) + ":"}
                                          // be the concatenation of `member` and the `space` character."
                                          // The "`space` character" refers to the literal space
                                          // character, not the `space` {width} argument provided to
                                          // `JSON.stringify`.
                                          results.push(
                                            quote(property) +
                                              ':' +
                                              (whitespace ? ' ' : '') +
                                              element
                                          )
                                        }
                                      })
                                      result = results.length
                                        ? whitespace
                                          ? '{\n' +
                                            indentation +
                                            results.join(',\n' + indentation) +
                                            '\n' +
                                            prefix +
                                            '}'
                                          : '{' + results.join(',') + '}'
                                        : '{}'
                                    }
                                    // Remove the object from the traversed object stack.
                                    stack.pop()
                                    return result
                                  }
                                }

                                // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
                                exports.stringify = function(
                                  source,
                                  filter,
                                  width
                                ) {
                                  var whitespace,
                                    callback,
                                    properties,
                                    className
                                  if (objectTypes[typeof filter] && filter) {
                                    className = getClass.call(filter)
                                    if (className == functionClass) {
                                      callback = filter
                                    } else if (className == arrayClass) {
                                      // Convert the property names array into a makeshift set.
                                      properties = {}
                                      for (
                                        var index = 0,
                                          length = filter.length,
                                          value;
                                        index < length;

                                      ) {
                                        value = filter[index++]
                                        className = getClass.call(value)
                                        if (
                                          className == '[object String]' ||
                                          className == '[object Number]'
                                        ) {
                                          properties[value] = 1
                                        }
                                      }
                                    }
                                  }
                                  if (width) {
                                    className = getClass.call(width)
                                    if (className == numberClass) {
                                      // Convert the `width` to an integer and create a string containing
                                      // `width` number of space characters.
                                      if ((width -= width % 1) > 0) {
                                        if (width > 10) {
                                          width = 10
                                        }
                                        for (
                                          whitespace = '';
                                          whitespace.length < width;

                                        ) {
                                          whitespace += ' '
                                        }
                                      }
                                    } else if (className == stringClass) {
                                      whitespace =
                                        width.length <= 10
                                          ? width
                                          : width.slice(0, 10)
                                    }
                                  }
                                  // Opera <= 7.54u2 discards the values associated with empty string keys
                                  // (`""`) only if they are used directly within an object member list
                                  // (e.g., `!("" in { "": 1})`).
                                  return serialize(
                                    '',
                                    ((value = {}), (value[''] = source), value),
                                    callback,
                                    properties,
                                    whitespace,
                                    '',
                                    []
                                  )
                                }
                              }
                            }

                            // Public: Parses a JSON source string.
                            if (!has('json-parse')) {
                              var fromCharCode = String.fromCharCode

                              // Internal: A map of escaped control characters and their unescaped
                              // equivalents.
                              var Unescapes = {
                                92: '\\',
                                34: '"',
                                47: '/',
                                98: '\b',
                                116: '\t',
                                110: '\n',
                                102: '\f',
                                114: '\r'
                              }

                              // Internal: Stores the parser state.
                              var Index, Source

                              // Internal: Resets the parser state and throws a `SyntaxError`.
                              var abort = function() {
                                Index = Source = null
                                throw SyntaxError()
                              }

                              // Internal: Returns the next token, or `"$"` if the parser has reached
                              // the end of the source string. A token may be a string, number, `null`
                              // literal, or Boolean literal.
                              var lex = function() {
                                var source = Source,
                                  length = source.length,
                                  value,
                                  begin,
                                  position,
                                  isSigned,
                                  charCode
                                while (Index < length) {
                                  charCode = source.charCodeAt(Index)
                                  switch (charCode) {
                                    case 9:
                                    case 10:
                                    case 13:
                                    case 32:
                                      // Skip whitespace tokens, including tabs, carriage returns, line
                                      // feeds, and space characters.
                                      Index++
                                      break
                                    case 123:
                                    case 125:
                                    case 91:
                                    case 93:
                                    case 58:
                                    case 44:
                                      // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                                      // the current position.
                                      value = charIndexBuggy
                                        ? source.charAt(Index)
                                        : source[Index]
                                      Index++
                                      return value
                                    case 34:
                                      // `"` delimits a JSON string; advance to the next character and
                                      // begin parsing the string. String tokens are prefixed with the
                                      // sentinel `@` character to distinguish them from punctuators and
                                      // end-of-string tokens.
                                      for (
                                        value = '@', Index++;
                                        Index < length;

                                      ) {
                                        charCode = source.charCodeAt(Index)
                                        if (charCode < 32) {
                                          // Unescaped ASCII control characters (those with a code unit
                                          // less than the space character) are not permitted.
                                          abort()
                                        } else if (charCode == 92) {
                                          // A reverse solidus (`\`) marks the beginning of an escaped
                                          // control character (including `"`, `\`, and `/`) or Unicode
                                          // escape sequence.
                                          charCode = source.charCodeAt(++Index)
                                          switch (charCode) {
                                            case 92:
                                            case 34:
                                            case 47:
                                            case 98:
                                            case 116:
                                            case 110:
                                            case 102:
                                            case 114:
                                              // Revive escaped control characters.
                                              value += Unescapes[charCode]
                                              Index++
                                              break
                                            case 117:
                                              // `\u` marks the beginning of a Unicode escape sequence.
                                              // Advance to the first character and validate the
                                              // four-digit code point.
                                              begin = ++Index
                                              for (
                                                position = Index + 4;
                                                Index < position;
                                                Index++
                                              ) {
                                                charCode = source.charCodeAt(
                                                  Index
                                                )
                                                // A valid sequence comprises four hexdigits (case-
                                                // insensitive) that form a single hexadecimal value.
                                                if (
                                                  !(
                                                    (charCode >= 48 &&
                                                      charCode <= 57) ||
                                                    (charCode >= 97 &&
                                                      charCode <= 102) ||
                                                    (charCode >= 65 &&
                                                      charCode <= 70)
                                                  )
                                                ) {
                                                  // Invalid Unicode escape sequence.
                                                  abort()
                                                }
                                              }
                                              // Revive the escaped character.
                                              value += fromCharCode(
                                                '0x' +
                                                  source.slice(begin, Index)
                                              )
                                              break
                                            default:
                                              // Invalid escape sequence.
                                              abort()
                                          }
                                        } else {
                                          if (charCode == 34) {
                                            // An unescaped double-quote character marks the end of the
                                            // string.
                                            break
                                          }
                                          charCode = source.charCodeAt(Index)
                                          begin = Index
                                          // Optimize for the common case where a string is valid.
                                          while (
                                            charCode >= 32 &&
                                            charCode != 92 &&
                                            charCode != 34
                                          ) {
                                            charCode = source.charCodeAt(
                                              ++Index
                                            )
                                          }
                                          // Append the string as-is.
                                          value += source.slice(begin, Index)
                                        }
                                      }
                                      if (source.charCodeAt(Index) == 34) {
                                        // Advance to the next character and return the revived string.
                                        Index++
                                        return value
                                      }
                                      // Unterminated string.
                                      abort()
                                    default:
                                      // Parse numbers and literals.
                                      begin = Index
                                      // Advance past the negative sign, if one is specified.
                                      if (charCode == 45) {
                                        isSigned = true
                                        charCode = source.charCodeAt(++Index)
                                      }
                                      // Parse an integer or floating-point value.
                                      if (charCode >= 48 && charCode <= 57) {
                                        // Leading zeroes are interpreted as octal literals.
                                        if (
                                          charCode == 48 &&
                                          ((charCode = source.charCodeAt(
                                            Index + 1
                                          )),
                                          charCode >= 48 && charCode <= 57)
                                        ) {
                                          // Illegal octal literal.
                                          abort()
                                        }
                                        isSigned = false
                                        // Parse the integer component.
                                        for (
                                          ;
                                          Index < length &&
                                          ((charCode = source.charCodeAt(
                                            Index
                                          )),
                                          charCode >= 48 && charCode <= 57);
                                          Index++
                                        );
                                        // Floats cannot contain a leading decimal point; however, this
                                        // case is already accounted for by the parser.
                                        if (source.charCodeAt(Index) == 46) {
                                          position = ++Index
                                          // Parse the decimal component.
                                          for (
                                            ;
                                            position < length;
                                            position++
                                          ) {
                                            charCode = source.charCodeAt(
                                              position
                                            )
                                            if (
                                              charCode < 48 ||
                                              charCode > 57
                                            ) {
                                              break
                                            }
                                          }
                                          if (position == Index) {
                                            // Illegal trailing decimal.
                                            abort()
                                          }
                                          Index = position
                                        }
                                        // Parse exponents. The `e` denoting the exponent is
                                        // case-insensitive.
                                        charCode = source.charCodeAt(Index)
                                        if (charCode == 101 || charCode == 69) {
                                          charCode = source.charCodeAt(++Index)
                                          // Skip past the sign following the exponent, if one is
                                          // specified.
                                          if (
                                            charCode == 43 ||
                                            charCode == 45
                                          ) {
                                            Index++
                                          }
                                          // Parse the exponential component.
                                          for (
                                            position = Index;
                                            position < length;
                                            position++
                                          ) {
                                            charCode = source.charCodeAt(
                                              position
                                            )
                                            if (
                                              charCode < 48 ||
                                              charCode > 57
                                            ) {
                                              break
                                            }
                                          }
                                          if (position == Index) {
                                            // Illegal empty exponent.
                                            abort()
                                          }
                                          Index = position
                                        }
                                        // Coerce the parsed value to a JavaScript number.
                                        return +source.slice(begin, Index)
                                      }
                                      // A negative sign may only precede numbers.
                                      if (isSigned) {
                                        abort()
                                      }
                                      // `true`, `false`, and `null` literals.
                                      var temp = source.slice(Index, Index + 4)
                                      if (temp == 'true') {
                                        Index += 4
                                        return true
                                      } else if (
                                        temp == 'fals' &&
                                        source.charCodeAt(Index + 4) == 101
                                      ) {
                                        Index += 5
                                        return false
                                      } else if (temp == 'null') {
                                        Index += 4
                                        return null
                                      }
                                      // Unrecognized token.
                                      abort()
                                  }
                                }
                                // Return the sentinel `$` character if the parser has reached the end
                                // of the source string.
                                return '$'
                              }

                              // Internal: Parses a JSON `value` token.
                              var get = function(value) {
                                var results, hasMembers
                                if (value == '$') {
                                  // Unexpected end of input.
                                  abort()
                                }
                                if (typeof value == 'string') {
                                  if (
                                    (charIndexBuggy
                                      ? value.charAt(0)
                                      : value[0]) == '@'
                                  ) {
                                    // Remove the sentinel `@` character.
                                    return value.slice(1)
                                  }
                                  // Parse object and array literals.
                                  if (value == '[') {
                                    // Parses a JSON array, returning a new JavaScript array.
                                    results = []
                                    for (;;) {
                                      value = lex()
                                      // A closing square bracket marks the end of the array literal.
                                      if (value == ']') {
                                        break
                                      }
                                      // If the array literal contains elements, the current token
                                      // should be a comma separating the previous element from the
                                      // next.
                                      if (hasMembers) {
                                        if (value == ',') {
                                          value = lex()
                                          if (value == ']') {
                                            // Unexpected trailing `,` in array literal.
                                            abort()
                                          }
                                        } else {
                                          // A `,` must separate each array element.
                                          abort()
                                        }
                                      } else {
                                        hasMembers = true
                                      }
                                      // Elisions and leading commas are not permitted.
                                      if (value == ',') {
                                        abort()
                                      }
                                      results.push(get(value))
                                    }
                                    return results
                                  } else if (value == '{') {
                                    // Parses a JSON object, returning a new JavaScript object.
                                    results = {}
                                    for (;;) {
                                      value = lex()
                                      // A closing curly brace marks the end of the object literal.
                                      if (value == '}') {
                                        break
                                      }
                                      // If the object literal contains members, the current token
                                      // should be a comma separator.
                                      if (hasMembers) {
                                        if (value == ',') {
                                          value = lex()
                                          if (value == '}') {
                                            // Unexpected trailing `,` in object literal.
                                            abort()
                                          }
                                        } else {
                                          // A `,` must separate each object member.
                                          abort()
                                        }
                                      } else {
                                        hasMembers = true
                                      }
                                      // Leading commas are not permitted, object property names must be
                                      // double-quoted strings, and a `:` must separate each property
                                      // name and value.
                                      if (
                                        value == ',' ||
                                        typeof value != 'string' ||
                                        (charIndexBuggy
                                          ? value.charAt(0)
                                          : value[0]) != '@' ||
                                        lex() != ':'
                                      ) {
                                        abort()
                                      }
                                      results[value.slice(1)] = get(lex())
                                    }
                                    return results
                                  }
                                  // Unexpected token encountered.
                                  abort()
                                }
                                return value
                              }

                              // Internal: Updates a traversed object member.
                              var update = function(
                                source,
                                property,
                                callback
                              ) {
                                var element = walk(source, property, callback)
                                if (element === undefined) {
                                  delete source[property]
                                } else {
                                  source[property] = element
                                }
                              }

                              // Internal: Recursively traverses a parsed JSON object, invoking the
                              // `callback` function for each value. This is an implementation of the
                              // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
                              var walk = function(source, property, callback) {
                                var value = source[property],
                                  length
                                if (typeof value == 'object' && value) {
                                  // `forOwn` can't be used to traverse an array in Opera <= 8.54
                                  // because its `Object#hasOwnProperty` implementation returns `false`
                                  // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                                  if (getClass.call(value) == arrayClass) {
                                    for (length = value.length; length--; ) {
                                      update(
                                        getClass,
                                        forOwn,
                                        value,
                                        length,
                                        callback
                                      )
                                    }
                                  } else {
                                    forOwn(value, function(property) {
                                      update(value, property, callback)
                                    })
                                  }
                                }
                                return callback.call(source, property, value)
                              }

                              // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
                              exports.parse = function(source, callback) {
                                var result, value
                                Index = 0
                                Source = '' + source
                                result = get(lex())
                                // If a JSON string contains multiple tokens, it is invalid.
                                if (lex() != '$') {
                                  abort()
                                }
                                // Reset the parser state.
                                Index = Source = null
                                return callback &&
                                  getClass.call(callback) == functionClass
                                  ? walk(
                                      ((value = {}),
                                      (value[''] = result),
                                      value),
                                      '',
                                      callback
                                    )
                                  : result
                              }
                            }
                          }

                          exports.runInContext = runInContext
                          return exports
                        }

                        if (freeExports && !isLoader) {
                          // Export for CommonJS environments.
                          runInContext(root, freeExports)
                        } else {
                          // Export for web browsers and JavaScript engines.
                          var nativeJSON = root.JSON,
                            previousJSON = root.JSON3,
                            isRestored = false

                          var JSON3 = runInContext(
                            root,
                            (root.JSON3 = {
                              // Public: Restores the original value of the global `JSON` object and
                              // returns a reference to the `JSON3` object.
                              noConflict: function() {
                                if (!isRestored) {
                                  isRestored = true
                                  root.JSON = nativeJSON
                                  root.JSON3 = previousJSON
                                  nativeJSON = previousJSON = null
                                }
                                return JSON3
                              }
                            })
                          )

                          root.JSON = {
                            parse: JSON3.parse,
                            stringify: JSON3.stringify
                          }
                        }

                        // Export for asynchronous module loaders.
                        if (isLoader) {
                          define(function() {
                            return JSON3
                          })
                        }
                      }.call(this))
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  {}
                ],
                59: [
                  function(require, module, exports) {
                    'use strict'

                    var has = Object.prototype.hasOwnProperty,
                      undef

                    /**
                     * Decode a URI encoded string.
                     *
                     * @param {String} input The URI encoded string.
                     * @returns {String|Null} The decoded string.
                     * @api private
                     */
                    function decode(input) {
                      try {
                        return decodeURIComponent(input.replace(/\+/g, ' '))
                      } catch (e) {
                        return null
                      }
                    }

                    /**
                     * Attempts to encode a given input.
                     *
                     * @param {String} input The string that needs to be encoded.
                     * @returns {String|Null} The encoded string.
                     * @api private
                     */
                    function encode(input) {
                      try {
                        return encodeURIComponent(input)
                      } catch (e) {
                        return null
                      }
                    }

                    /**
                     * Simple query string parser.
                     *
                     * @param {String} query The query string that needs to be parsed.
                     * @returns {Object}
                     * @api public
                     */
                    function querystring(query) {
                      var parser = /([^=?&]+)=?([^&]*)/g,
                        result = {},
                        part

                      while ((part = parser.exec(query))) {
                        var key = decode(part[1]),
                          value = decode(part[2])

                        //
                        // Prevent overriding of existing properties. This ensures that build-in
                        // methods like `toString` or __proto__ are not overriden by malicious
                        // querystrings.
                        //
                        // In the case if failed decoding, we want to omit the key/value pairs
                        // from the result.
                        //
                        if (key === null || value === null || key in result)
                          continue
                        result[key] = value
                      }

                      return result
                    }

                    /**
                     * Transform a query string to an object.
                     *
                     * @param {Object} obj Object that should be transformed.
                     * @param {String} prefix Optional prefix.
                     * @returns {String}
                     * @api public
                     */
                    function querystringify(obj, prefix) {
                      prefix = prefix || ''

                      var pairs = [],
                        value,
                        key

                      //
                      // Optionally prefix with a '?' if needed
                      //
                      if ('string' !== typeof prefix) prefix = '?'

                      for (key in obj) {
                        if (has.call(obj, key)) {
                          value = obj[key]

                          //
                          // Edge cases where we actually want to encode the value to an empty
                          // string instead of the stringified value.
                          //
                          if (
                            !value &&
                            (value === null || value === undef || isNaN(value))
                          ) {
                            value = ''
                          }

                          key = encodeURIComponent(key)
                          value = encodeURIComponent(value)

                          //
                          // If we failed to encode the strings, we should bail out as we don't
                          // want to add invalid strings to the query.
                          //
                          if (key === null || value === null) continue
                          pairs.push(key + '=' + value)
                        }
                      }

                      return pairs.length ? prefix + pairs.join('&') : ''
                    }

                    //
                    // Expose the module.
                    //
                    exports.stringify = querystringify
                    exports.parse = querystring
                  },
                  {}
                ],
                60: [
                  function(require, module, exports) {
                    'use strict'

                    /**
                     * Check if we're required to add a port number.
                     *
                     * @see https://url.spec.whatwg.org/#default-port
                     * @param {Number|String} port Port number we need to check
                     * @param {String} protocol Protocol we need to check against.
                     * @returns {Boolean} Is it a default port for the given protocol
                     * @api private
                     */
                    module.exports = function required(port, protocol) {
                      protocol = protocol.split(':')[0]
                      port = +port

                      if (!port) return false

                      switch (protocol) {
                        case 'http':
                        case 'ws':
                          return port !== 80

                        case 'https':
                        case 'wss':
                          return port !== 443

                        case 'ftp':
                          return port !== 21

                        case 'gopher':
                          return port !== 70

                        case 'file':
                          return false
                      }

                      return port !== 0
                    }
                  },
                  {}
                ],
                61: [
                  function(require, module, exports) {
                    ;(function(global) {
                      'use strict'

                      var required = require('requires-port'),
                        qs = require('querystringify'),
                        slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
                        protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i,
                        whitespace =
                          '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]',
                        left = new RegExp('^' + whitespace + '+')

                      /**
                       * Trim a given string.
                       *
                       * @param {String} str String to trim.
                       * @public
                       */
                      function trimLeft(str) {
                        return (str ? str : '').toString().replace(left, '')
                      }

                      /**
                       * These are the parse rules for the URL parser, it informs the parser
                       * about:
                       *
                       * 0. The char it Needs to parse, if it's a string it should be done using
                       *    indexOf, RegExp using exec and NaN means set as current value.
                       * 1. The property we should set when parsing this value.
                       * 2. Indication if it's backwards or forward parsing, when set as number it's
                       *    the value of extra chars that should be split off.
                       * 3. Inherit from location if non existing in the parser.
                       * 4. `toLowerCase` the resulting value.
                       */
                      var rules = [
                        ['#', 'hash'], // Extract from the back.
                        ['?', 'query'], // Extract from the back.
                        function sanitize(address) {
                          // Sanitize what is left of the address
                          return address.replace('\\', '/')
                        },
                        ['/', 'pathname'], // Extract from the back.
                        ['@', 'auth', 1], // Extract from the front.
                        [NaN, 'host', undefined, 1, 1], // Set left over value.
                        [/:(\d+)$/, 'port', undefined, 1], // RegExp the back.
                        [NaN, 'hostname', undefined, 1, 1] // Set left over.
                      ]

                      /**
                       * These properties should not be copied or inherited from. This is only needed
                       * for all non blob URL's as a blob URL does not include a hash, only the
                       * origin.
                       *
                       * @type {Object}
                       * @private
                       */
                      var ignore = { hash: 1, query: 1 }

                      /**
                       * The location object differs when your code is loaded through a normal page,
                       * Worker or through a worker using a blob. And with the blobble begins the
                       * trouble as the location object will contain the URL of the blob, not the
                       * location of the page where our code is loaded in. The actual origin is
                       * encoded in the `pathname` so we can thankfully generate a good "default"
                       * location from it so we can generate proper relative URL's again.
                       *
                       * @param {Object|String} loc Optional default location object.
                       * @returns {Object} lolcation object.
                       * @public
                       */
                      function lolcation(loc) {
                        var globalVar

                        if (typeof window !== 'undefined') globalVar = window
                        else if (typeof global !== 'undefined')
                          globalVar = global
                        else if (typeof self !== 'undefined') globalVar = self
                        else globalVar = {}

                        var location = globalVar.location || {}
                        loc = loc || location

                        var finaldestination = {},
                          type = typeof loc,
                          key

                        if ('blob:' === loc.protocol) {
                          finaldestination = new Url(unescape(loc.pathname), {})
                        } else if ('string' === type) {
                          finaldestination = new Url(loc, {})
                          for (key in ignore) delete finaldestination[key]
                        } else if ('object' === type) {
                          for (key in loc) {
                            if (key in ignore) continue
                            finaldestination[key] = loc[key]
                          }

                          if (finaldestination.slashes === undefined) {
                            finaldestination.slashes = slashes.test(loc.href)
                          }
                        }

                        return finaldestination
                      }

                      /**
                       * @typedef ProtocolExtract
                       * @type Object
                       * @property {String} protocol Protocol matched in the URL, in lowercase.
                       * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
                       * @property {String} rest Rest of the URL that is not part of the protocol.
                       */

                      /**
                       * Extract protocol information from a URL with/without double slash ("//").
                       *
                       * @param {String} address URL we want to extract from.
                       * @return {ProtocolExtract} Extracted information.
                       * @private
                       */
                      function extractProtocol(address) {
                        address = trimLeft(address)
                        var match = protocolre.exec(address)

                        return {
                          protocol: match[1] ? match[1].toLowerCase() : '',
                          slashes: !!match[2],
                          rest: match[3]
                        }
                      }

                      /**
                       * Resolve a relative URL pathname against a base URL pathname.
                       *
                       * @param {String} relative Pathname of the relative URL.
                       * @param {String} base Pathname of the base URL.
                       * @return {String} Resolved pathname.
                       * @private
                       */
                      function resolve(relative, base) {
                        if (relative === '') return base

                        var path = (base || '/')
                            .split('/')
                            .slice(0, -1)
                            .concat(relative.split('/')),
                          i = path.length,
                          last = path[i - 1],
                          unshift = false,
                          up = 0

                        while (i--) {
                          if (path[i] === '.') {
                            path.splice(i, 1)
                          } else if (path[i] === '..') {
                            path.splice(i, 1)
                            up++
                          } else if (up) {
                            if (i === 0) unshift = true
                            path.splice(i, 1)
                            up--
                          }
                        }

                        if (unshift) path.unshift('')
                        if (last === '.' || last === '..') path.push('')

                        return path.join('/')
                      }

                      /**
                       * The actual URL instance. Instead of returning an object we've opted-in to
                       * create an actual constructor as it's much more memory efficient and
                       * faster and it pleases my OCD.
                       *
                       * It is worth noting that we should not use `URL` as class name to prevent
                       * clashes with the global URL instance that got introduced in browsers.
                       *
                       * @constructor
                       * @param {String} address URL we want to parse.
                       * @param {Object|String} [location] Location defaults for relative paths.
                       * @param {Boolean|Function} [parser] Parser for the query string.
                       * @private
                       */
                      function Url(address, location, parser) {
                        address = trimLeft(address)

                        if (!(this instanceof Url)) {
                          return new Url(address, location, parser)
                        }

                        var relative,
                          extracted,
                          parse,
                          instruction,
                          index,
                          key,
                          instructions = rules.slice(),
                          type = typeof location,
                          url = this,
                          i = 0

                        //
                        // The following if statements allows this module two have compatibility with
                        // 2 different API:
                        //
                        // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
                        //    where the boolean indicates that the query string should also be parsed.
                        //
                        // 2. The `URL` interface of the browser which accepts a URL, object as
                        //    arguments. The supplied object will be used as default values / fall-back
                        //    for relative paths.
                        //
                        if ('object' !== type && 'string' !== type) {
                          parser = location
                          location = null
                        }

                        if (parser && 'function' !== typeof parser)
                          parser = qs.parse

                        location = lolcation(location)

                        //
                        // Extract protocol information before running the instructions.
                        //
                        extracted = extractProtocol(address || '')
                        relative = !extracted.protocol && !extracted.slashes
                        url.slashes =
                          extracted.slashes || (relative && location.slashes)
                        url.protocol =
                          extracted.protocol || location.protocol || ''
                        address = extracted.rest

                        //
                        // When the authority component is absent the URL starts with a path
                        // component.
                        //
                        if (!extracted.slashes)
                          instructions[3] = [/(.*)/, 'pathname']

                        for (; i < instructions.length; i++) {
                          instruction = instructions[i]

                          if (typeof instruction === 'function') {
                            address = instruction(address)
                            continue
                          }

                          parse = instruction[0]
                          key = instruction[1]

                          if (parse !== parse) {
                            url[key] = address
                          } else if ('string' === typeof parse) {
                            if (~(index = address.indexOf(parse))) {
                              if ('number' === typeof instruction[2]) {
                                url[key] = address.slice(0, index)
                                address = address.slice(index + instruction[2])
                              } else {
                                url[key] = address.slice(index)
                                address = address.slice(0, index)
                              }
                            }
                          } else if ((index = parse.exec(address))) {
                            url[key] = index[1]
                            address = address.slice(0, index.index)
                          }

                          url[key] =
                            url[key] ||
                            (relative && instruction[3]
                              ? location[key] || ''
                              : '')

                          //
                          // Hostname, host and protocol should be lowercased so they can be used to
                          // create a proper `origin`.
                          //
                          if (instruction[4]) url[key] = url[key].toLowerCase()
                        }

                        //
                        // Also parse the supplied query string in to an object. If we're supplied
                        // with a custom parser as function use that instead of the default build-in
                        // parser.
                        //
                        if (parser) url.query = parser(url.query)

                        //
                        // If the URL is relative, resolve the pathname against the base URL.
                        //
                        if (
                          relative &&
                          location.slashes &&
                          url.pathname.charAt(0) !== '/' &&
                          (url.pathname !== '' || location.pathname !== '')
                        ) {
                          url.pathname = resolve(
                            url.pathname,
                            location.pathname
                          )
                        }

                        //
                        // We should not add port numbers if they are already the default port number
                        // for a given protocol. As the host also contains the port number we're going
                        // override it with the hostname which contains no port number.
                        //
                        if (!required(url.port, url.protocol)) {
                          url.host = url.hostname
                          url.port = ''
                        }

                        //
                        // Parse down the `auth` for the username and password.
                        //
                        url.username = url.password = ''
                        if (url.auth) {
                          instruction = url.auth.split(':')
                          url.username = instruction[0] || ''
                          url.password = instruction[1] || ''
                        }

                        url.origin =
                          url.protocol && url.host && url.protocol !== 'file:'
                            ? url.protocol + '//' + url.host
                            : 'null'

                        //
                        // The href is just the compiled result.
                        //
                        url.href = url.toString()
                      }

                      /**
                       * This is convenience method for changing properties in the URL instance to
                       * insure that they all propagate correctly.
                       *
                       * @param {String} part          Property we need to adjust.
                       * @param {Mixed} value          The newly assigned value.
                       * @param {Boolean|Function} fn  When setting the query, it will be the function
                       *                               used to parse the query.
                       *                               When setting the protocol, double slash will be
                       *                               removed from the final url if it is true.
                       * @returns {URL} URL instance for chaining.
                       * @public
                       */
                      function set(part, value, fn) {
                        var url = this

                        switch (part) {
                          case 'query':
                            if ('string' === typeof value && value.length) {
                              value = (fn || qs.parse)(value)
                            }

                            url[part] = value
                            break

                          case 'port':
                            url[part] = value

                            if (!required(value, url.protocol)) {
                              url.host = url.hostname
                              url[part] = ''
                            } else if (value) {
                              url.host = url.hostname + ':' + value
                            }

                            break

                          case 'hostname':
                            url[part] = value

                            if (url.port) value += ':' + url.port
                            url.host = value
                            break

                          case 'host':
                            url[part] = value

                            if (/:\d+$/.test(value)) {
                              value = value.split(':')
                              url.port = value.pop()
                              url.hostname = value.join(':')
                            } else {
                              url.hostname = value
                              url.port = ''
                            }

                            break

                          case 'protocol':
                            url.protocol = value.toLowerCase()
                            url.slashes = !fn
                            break

                          case 'pathname':
                          case 'hash':
                            if (value) {
                              var char = part === 'pathname' ? '/' : '#'
                              url[part] =
                                value.charAt(0) !== char ? char + value : value
                            } else {
                              url[part] = value
                            }
                            break

                          default:
                            url[part] = value
                        }

                        for (var i = 0; i < rules.length; i++) {
                          var ins = rules[i]

                          if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase()
                        }

                        url.origin =
                          url.protocol && url.host && url.protocol !== 'file:'
                            ? url.protocol + '//' + url.host
                            : 'null'

                        url.href = url.toString()

                        return url
                      }

                      /**
                       * Transform the properties back in to a valid and full URL string.
                       *
                       * @param {Function} stringify Optional query stringify function.
                       * @returns {String} Compiled version of the URL.
                       * @public
                       */
                      function toString(stringify) {
                        if (!stringify || 'function' !== typeof stringify)
                          stringify = qs.stringify

                        var query,
                          url = this,
                          protocol = url.protocol

                        if (
                          protocol &&
                          protocol.charAt(protocol.length - 1) !== ':'
                        )
                          protocol += ':'

                        var result = protocol + (url.slashes ? '//' : '')

                        if (url.username) {
                          result += url.username
                          if (url.password) result += ':' + url.password
                          result += '@'
                        }

                        result += url.host + url.pathname

                        query =
                          'object' === typeof url.query
                            ? stringify(url.query)
                            : url.query
                        if (query)
                          result +=
                            '?' !== query.charAt(0) ? '?' + query : query

                        if (url.hash) result += url.hash

                        return result
                      }

                      Url.prototype = { set: set, toString: toString }

                      //
                      // Expose the URL parser and some additional properties that might be useful for
                      // others or testing.
                      //
                      Url.extractProtocol = extractProtocol
                      Url.location = lolcation
                      Url.trimLeft = trimLeft
                      Url.qs = qs

                      module.exports = Url
                    }.call(
                      this,
                      typeof global !== 'undefined'
                        ? global
                        : typeof self !== 'undefined'
                          ? self
                          : typeof window !== 'undefined'
                            ? window
                            : {}
                    ))
                  },
                  { querystringify: 59, 'requires-port': 60 }
                ]
              },
              {},
              [1]
            )(1)
          })

          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../_webpack@4.46.0@webpack/buildin/global.js */ './node_modules/_webpack@4.46.0@webpack/buildin/global.js'
          )
        ))

        /***/
      },

    /***/ './node_modules/_strip-ansi@3.0.1@strip-ansi/index.js':
      /*!************************************************************!*\
  !*** ./node_modules/_strip-ansi@3.0.1@strip-ansi/index.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        var ansiRegex = __webpack_require__(
          /*! ansi-regex */ './node_modules/_ansi-regex@2.1.1@ansi-regex/index.js'
        )()

        module.exports = function(str) {
          return typeof str === 'string' ? str.replace(ansiRegex, '') : str
        }

        /***/
      },

    /***/ './node_modules/_url@0.11.0@url/url.js':
      /*!*********************************************!*\
  !*** ./node_modules/_url@0.11.0@url/url.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var punycode = __webpack_require__(
          /*! punycode */ './node_modules/_punycode@1.4.1@punycode/punycode.js'
        )
        var util = __webpack_require__(
          /*! ./util */ './node_modules/_url@0.11.0@url/util.js'
        )

        exports.parse = urlParse
        exports.resolve = urlResolve
        exports.resolveObject = urlResolveObject
        exports.format = urlFormat

        exports.Url = Url

        function Url() {
          this.protocol = null
          this.slashes = null
          this.auth = null
          this.host = null
          this.port = null
          this.hostname = null
          this.hash = null
          this.search = null
          this.query = null
          this.pathname = null
          this.path = null
          this.href = null
        }

        // Reference: RFC 3986, RFC 1808, RFC 2396

        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i,
          portPattern = /:[0-9]*$/,
          // Special case for a simple path URL
          simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
          // RFC 2396: characters reserved for delimiting URLs.
          // We actually just auto-escape these.
          delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
          // RFC 2396: characters not allowed for various reasons.
          unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
          // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
          autoEscape = ["'"].concat(unwise),
          // Characters that are never ever allowed in a hostname.
          // Note that any invalid chars are also handled, but these
          // are the ones that are *expected* to be seen, so we fast-path
          // them.
          nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
          hostEndingChars = ['/', '?', '#'],
          hostnameMaxLen = 255,
          hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
          hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
          // protocols that can allow "unsafe" and "unwise" chars.
          unsafeProtocol = {
            javascript: true,
            'javascript:': true
          },
          // protocols that never have a hostname.
          hostlessProtocol = {
            javascript: true,
            'javascript:': true
          },
          // protocols that always contain a // bit.
          slashedProtocol = {
            http: true,
            https: true,
            ftp: true,
            gopher: true,
            file: true,
            'http:': true,
            'https:': true,
            'ftp:': true,
            'gopher:': true,
            'file:': true
          },
          querystring = __webpack_require__(
            /*! querystring */ './node_modules/_querystring-es3@0.2.1@querystring-es3/index.js'
          )

        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util.isObject(url) && url instanceof Url) return url

          var u = new Url()
          u.parse(url, parseQueryString, slashesDenoteHost)
          return u
        }

        Url.prototype.parse = function(
          url,
          parseQueryString,
          slashesDenoteHost
        ) {
          if (!util.isString(url)) {
            throw new TypeError(
              "Parameter 'url' must be a string, not " + typeof url
            )
          }

          // Copy chrome, IE, opera backslash-handling behavior.
          // Back slashes before the query string get converted to forward slashes
          // See: https://code.google.com/p/chromium/issues/detail?id=25916
          var queryIndex = url.indexOf('?'),
            splitter =
              queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
            uSplit = url.split(splitter),
            slashRegex = /\\/g
          uSplit[0] = uSplit[0].replace(slashRegex, '/')
          url = uSplit.join(splitter)

          var rest = url

          // trim before proceeding.
          // This is to support parse stuff like "  http://foo.com  \n"
          rest = rest.trim()

          if (!slashesDenoteHost && url.split('#').length === 1) {
            // Try fast path regexp
            var simplePath = simplePathPattern.exec(rest)
            if (simplePath) {
              this.path = rest
              this.href = rest
              this.pathname = simplePath[1]
              if (simplePath[2]) {
                this.search = simplePath[2]
                if (parseQueryString) {
                  this.query = querystring.parse(this.search.substr(1))
                } else {
                  this.query = this.search.substr(1)
                }
              } else if (parseQueryString) {
                this.search = ''
                this.query = {}
              }
              return this
            }
          }

          var proto = protocolPattern.exec(rest)
          if (proto) {
            proto = proto[0]
            var lowerProto = proto.toLowerCase()
            this.protocol = lowerProto
            rest = rest.substr(proto.length)
          }

          // figure out if it's got a host
          // user@server is *always* interpreted as a hostname, and url
          // resolution will treat //foo/bar as host=foo,path=bar because that's
          // how the browser resolves relative URLs.
          if (
            slashesDenoteHost ||
            proto ||
            rest.match(/^\/\/[^@\/]+@[^@\/]+/)
          ) {
            var slashes = rest.substr(0, 2) === '//'
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2)
              this.slashes = true
            }
          }

          if (
            !hostlessProtocol[proto] &&
            (slashes || (proto && !slashedProtocol[proto]))
          ) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c

            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.

            // find the first instance of any hostEndingChars
            var hostEnd = -1
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i])
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec
            }

            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign
            if (hostEnd === -1) {
              // atSign can be anywhere.
              atSign = rest.lastIndexOf('@')
            } else {
              // atSign must be in auth portion.
              // http://a@b/c@d => host:b auth:a path:/c@d
              atSign = rest.lastIndexOf('@', hostEnd)
            }

            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
              auth = rest.slice(0, atSign)
              rest = rest.slice(atSign + 1)
              this.auth = decodeURIComponent(auth)
            }

            // the host is the remaining to the left of the first non-host char
            hostEnd = -1
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i])
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) hostEnd = rest.length

            this.host = rest.slice(0, hostEnd)
            rest = rest.slice(hostEnd)

            // pull out port.
            this.parseHost()

            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || ''

            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname =
              this.hostname[0] === '[' &&
              this.hostname[this.hostname.length - 1] === ']'

            // validate a little.
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./)
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i]
                if (!part) continue
                if (!part.match(hostnamePartPattern)) {
                  var newpart = ''
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      // we replace non-ASCII char with a temporary placeholder
                      // we need this to make sure size of hostname is not
                      // broken by replacing non-ASCII by nothing
                      newpart += 'x'
                    } else {
                      newpart += part[j]
                    }
                  }
                  // we test again with ASCII char only
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i)
                    var notHost = hostparts.slice(i + 1)
                    var bit = part.match(hostnamePartStart)
                    if (bit) {
                      validParts.push(bit[1])
                      notHost.unshift(bit[2])
                    }
                    if (notHost.length) {
                      rest = '/' + notHost.join('.') + rest
                    }
                    this.hostname = validParts.join('.')
                    break
                  }
                }
              }
            }

            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = ''
            } else {
              // hostnames are always lower case.
              this.hostname = this.hostname.toLowerCase()
            }

            if (!ipv6Hostname) {
              // IDNA Support: Returns a punycoded representation of "domain".
              // It only converts parts of the domain name that
              // have non-ASCII characters, i.e. it doesn't matter if
              // you call it with a domain that already is ASCII-only.
              this.hostname = punycode.toASCII(this.hostname)
            }

            var p = this.port ? ':' + this.port : ''
            var h = this.hostname || ''
            this.host = h + p
            this.href += this.host

            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2)
              if (rest[0] !== '/') {
                rest = '/' + rest
              }
            }
          }

          // now rest is set to the post-host stuff.
          // chop off any delim chars.
          if (!unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i]
              if (rest.indexOf(ae) === -1) continue
              var esc = encodeURIComponent(ae)
              if (esc === ae) {
                esc = escape(ae)
              }
              rest = rest.split(ae).join(esc)
            }
          }

          // chop off from the tail first.
          var hash = rest.indexOf('#')
          if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash)
            rest = rest.slice(0, hash)
          }
          var qm = rest.indexOf('?')
          if (qm !== -1) {
            this.search = rest.substr(qm)
            this.query = rest.substr(qm + 1)
            if (parseQueryString) {
              this.query = querystring.parse(this.query)
            }
            rest = rest.slice(0, qm)
          } else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = ''
            this.query = {}
          }
          if (rest) this.pathname = rest
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = '/'
          }

          //to support http.request
          if (this.pathname || this.search) {
            var p = this.pathname || ''
            var s = this.search || ''
            this.path = p + s
          }

          // finally, reconstruct the href based on what has been validated.
          this.href = this.format()
          return this
        }

        // format a parsed object into a url string
        function urlFormat(obj) {
          // ensure it's an object, and not a string url.
          // If it's an obj, this is a no-op.
          // this way, you can call url_format() on strings
          // to clean up potentially wonky urls.
          if (util.isString(obj)) obj = urlParse(obj)
          if (!(obj instanceof Url)) return Url.prototype.format.call(obj)
          return obj.format()
        }

        Url.prototype.format = function() {
          var auth = this.auth || ''
          if (auth) {
            auth = encodeURIComponent(auth)
            auth = auth.replace(/%3A/i, ':')
            auth += '@'
          }

          var protocol = this.protocol || '',
            pathname = this.pathname || '',
            hash = this.hash || '',
            host = false,
            query = ''

          if (this.host) {
            host = auth + this.host
          } else if (this.hostname) {
            host =
              auth +
              (this.hostname.indexOf(':') === -1
                ? this.hostname
                : '[' + this.hostname + ']')
            if (this.port) {
              host += ':' + this.port
            }
          }

          if (
            this.query &&
            util.isObject(this.query) &&
            Object.keys(this.query).length
          ) {
            query = querystring.stringify(this.query)
          }

          var search = this.search || (query && '?' + query) || ''

          if (protocol && protocol.substr(-1) !== ':') protocol += ':'

          // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
          // unless they had them to begin with.
          if (
            this.slashes ||
            ((!protocol || slashedProtocol[protocol]) && host !== false)
          ) {
            host = '//' + (host || '')
            if (pathname && pathname.charAt(0) !== '/')
              pathname = '/' + pathname
          } else if (!host) {
            host = ''
          }

          if (hash && hash.charAt(0) !== '#') hash = '#' + hash
          if (search && search.charAt(0) !== '?') search = '?' + search

          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match)
          })
          search = search.replace('#', '%23')

          return protocol + host + pathname + search + hash
        }

        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative)
        }

        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format()
        }

        function urlResolveObject(source, relative) {
          if (!source) return relative
          return urlParse(source, false, true).resolveObject(relative)
        }

        Url.prototype.resolveObject = function(relative) {
          if (util.isString(relative)) {
            var rel = new Url()
            rel.parse(relative, false, true)
            relative = rel
          }

          var result = new Url()
          var tkeys = Object.keys(this)
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk]
            result[tkey] = this[tkey]
          }

          // hash is always overridden, no matter what.
          // even href="" will remove it.
          result.hash = relative.hash

          // if the relative url is empty, then there's nothing left to do here.
          if (relative.href === '') {
            result.href = result.format()
            return result
          }

          // hrefs like //foo/bar always cut to the protocol.
          if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative)
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk]
              if (rkey !== 'protocol') result[rkey] = relative[rkey]
            }

            //urlParse appends trailing / to urls like http://www.example.com
            if (
              slashedProtocol[result.protocol] &&
              result.hostname &&
              !result.pathname
            ) {
              result.path = result.pathname = '/'
            }

            result.href = result.format()
            return result
          }

          if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative)
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v]
                result[k] = relative[k]
              }
              result.href = result.format()
              return result
            }

            result.protocol = relative.protocol
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || '').split('/')
              while (relPath.length && !(relative.host = relPath.shift()));
              if (!relative.host) relative.host = ''
              if (!relative.hostname) relative.hostname = ''
              if (relPath[0] !== '') relPath.unshift('')
              if (relPath.length < 2) relPath.unshift('')
              result.pathname = relPath.join('/')
            } else {
              result.pathname = relative.pathname
            }
            result.search = relative.search
            result.query = relative.query
            result.host = relative.host || ''
            result.auth = relative.auth
            result.hostname = relative.hostname || relative.host
            result.port = relative.port
            // to support http.request
            if (result.pathname || result.search) {
              var p = result.pathname || ''
              var s = result.search || ''
              result.path = p + s
            }
            result.slashes = result.slashes || relative.slashes
            result.href = result.format()
            return result
          }

          var isSourceAbs =
              result.pathname && result.pathname.charAt(0) === '/',
            isRelAbs =
              relative.host ||
              (relative.pathname && relative.pathname.charAt(0) === '/'),
            mustEndAbs =
              isRelAbs || isSourceAbs || (result.host && relative.pathname),
            removeAllDots = mustEndAbs,
            srcPath = (result.pathname && result.pathname.split('/')) || [],
            relPath = (relative.pathname && relative.pathname.split('/')) || [],
            psychotic = result.protocol && !slashedProtocol[result.protocol]

          // if the url is a non-slashed url, then relative
          // links like ../.. should be able
          // to crawl up to the hostname, as well.  This is strange.
          // result.protocol has already been set by now.
          // Later on, put the first path part into the host field.
          if (psychotic) {
            result.hostname = ''
            result.port = null
            if (result.host) {
              if (srcPath[0] === '') srcPath[0] = result.host
              else srcPath.unshift(result.host)
            }
            result.host = ''
            if (relative.protocol) {
              relative.hostname = null
              relative.port = null
              if (relative.host) {
                if (relPath[0] === '') relPath[0] = relative.host
                else relPath.unshift(relative.host)
              }
              relative.host = null
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '')
          }

          if (isRelAbs) {
            // it's absolute.
            result.host =
              relative.host || relative.host === ''
                ? relative.host
                : result.host
            result.hostname =
              relative.hostname || relative.hostname === ''
                ? relative.hostname
                : result.hostname
            result.search = relative.search
            result.query = relative.query
            srcPath = relPath
            // fall through to the dot-handling below.
          } else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) srcPath = []
            srcPath.pop()
            srcPath = srcPath.concat(relPath)
            result.search = relative.search
            result.query = relative.query
          } else if (!util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
              result.hostname = result.host = srcPath.shift()
              //occationaly the auth can get stuck only in host
              //this especially happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost =
                result.host && result.host.indexOf('@') > 0
                  ? result.host.split('@')
                  : false
              if (authInHost) {
                result.auth = authInHost.shift()
                result.host = result.hostname = authInHost.shift()
              }
            }
            result.search = relative.search
            result.query = relative.query
            //to support http.request
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path =
                (result.pathname ? result.pathname : '') +
                (result.search ? result.search : '')
            }
            result.href = result.format()
            return result
          }

          if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null
            //to support http.request
            if (result.search) {
              result.path = '/' + result.search
            } else {
              result.path = null
            }
            result.href = result.format()
            return result
          }

          // if a url ENDs in . or .., then it must get a trailing slash.
          // however, if it ends in anything else non-slashy,
          // then it must NOT get a trailing slash.
          var last = srcPath.slice(-1)[0]
          var hasTrailingSlash =
            ((result.host || relative.host || srcPath.length > 1) &&
              (last === '.' || last === '..')) ||
            last === ''

          // strip single dots, resolve double dots to parent dir
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i]
            if (last === '.') {
              srcPath.splice(i, 1)
            } else if (last === '..') {
              srcPath.splice(i, 1)
              up++
            } else if (up) {
              srcPath.splice(i, 1)
              up--
            }
          }

          // if the path is allowed to go above the root, restore leading ..s
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift('..')
            }
          }

          if (
            mustEndAbs &&
            srcPath[0] !== '' &&
            (!srcPath[0] || srcPath[0].charAt(0) !== '/')
          ) {
            srcPath.unshift('')
          }

          if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
            srcPath.push('')
          }

          var isAbsolute =
            srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/')

          // put the host back
          if (psychotic) {
            result.hostname = result.host = isAbsolute
              ? ''
              : srcPath.length
                ? srcPath.shift()
                : ''
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost =
              result.host && result.host.indexOf('@') > 0
                ? result.host.split('@')
                : false
            if (authInHost) {
              result.auth = authInHost.shift()
              result.host = result.hostname = authInHost.shift()
            }
          }

          mustEndAbs = mustEndAbs || (result.host && srcPath.length)

          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('')
          }

          if (!srcPath.length) {
            result.pathname = null
            result.path = null
          } else {
            result.pathname = srcPath.join('/')
          }

          //to support request.http
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path =
              (result.pathname ? result.pathname : '') +
              (result.search ? result.search : '')
          }
          result.auth = relative.auth || result.auth
          result.slashes = result.slashes || relative.slashes
          result.href = result.format()
          return result
        }

        Url.prototype.parseHost = function() {
          var host = this.host
          var port = portPattern.exec(host)
          if (port) {
            port = port[0]
            if (port !== ':') {
              this.port = port.substr(1)
            }
            host = host.substr(0, host.length - port.length)
          }
          if (host) this.hostname = host
        }

        /***/
      },

    /***/ './node_modules/_url@0.11.0@url/util.js':
      /*!**********************************************!*\
  !*** ./node_modules/_url@0.11.0@url/util.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        module.exports = {
          isString: function(arg) {
            return typeof arg === 'string'
          },
          isObject: function(arg) {
            return typeof arg === 'object' && arg !== null
          },
          isNull: function(arg) {
            return arg === null
          },
          isNullOrUndefined: function(arg) {
            return arg == null
          }
        }

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/BaseClient.js':
      /*!*************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/BaseClient.js ***!
  \*************************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        /* eslint-disable
  no-unused-vars
*/

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function')
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i]
            descriptor.enumerable = descriptor.enumerable || false
            descriptor.configurable = true
            if ('value' in descriptor) descriptor.writable = true
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps)
          if (staticProps) _defineProperties(Constructor, staticProps)
          return Constructor
        }

        module.exports = /*#__PURE__*/ (function() {
          function BaseClient() {
            _classCallCheck(this, BaseClient)
          }

          _createClass(BaseClient, null, [
            {
              key: 'getClientPath',
              value: function getClientPath(options) {
                throw new Error('Client needs implementation')
              }
            }
          ])

          return BaseClient
        })()

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js':
      /*!***************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js ***!
  \***************************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        /* eslint-disable
  no-unused-vars
*/

        function _typeof(obj) {
          '@babel/helpers - typeof'
          if (
            typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj
            }
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === 'function' &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj
            }
          }
          return _typeof(obj)
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function')
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i]
            descriptor.enumerable = descriptor.enumerable || false
            descriptor.configurable = true
            if ('value' in descriptor) descriptor.writable = true
            Object.defineProperty(target, descriptor.key, descriptor)
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps)
          if (staticProps) _defineProperties(Constructor, staticProps)
          return Constructor
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== 'function' && superClass !== null) {
            throw new TypeError(
              'Super expression must either be null or a function'
            )
          }
          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                writable: true,
                configurable: true
              }
            }
          )
          if (superClass) _setPrototypeOf(subClass, superClass)
        }

        function _setPrototypeOf(o, p) {
          _setPrototypeOf =
            Object.setPrototypeOf ||
            function _setPrototypeOf(o, p) {
              o.__proto__ = p
              return o
            }
          return _setPrototypeOf(o, p)
        }

        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct()
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor
              result = Reflect.construct(Super, arguments, NewTarget)
            } else {
              result = Super.apply(this, arguments)
            }
            return _possibleConstructorReturn(this, result)
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (
            call &&
            (_typeof(call) === 'object' || typeof call === 'function')
          ) {
            return call
          }
          return _assertThisInitialized(self)
        }

        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            )
          }
          return self
        }

        function _isNativeReflectConstruct() {
          if (typeof Reflect === 'undefined' || !Reflect.construct) return false
          if (Reflect.construct.sham) return false
          if (typeof Proxy === 'function') return true
          try {
            Date.prototype.toString.call(
              Reflect.construct(Date, [], function() {})
            )
            return true
          } catch (e) {
            return false
          }
        }

        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
              }
          return _getPrototypeOf(o)
        }

        var SockJS = __webpack_require__(
          /*! sockjs-client/dist/sockjs */ './node_modules/_sockjs-client@1.5.0@sockjs-client/dist/sockjs.js'
        )

        var BaseClient = __webpack_require__(
          /*! ./BaseClient */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/BaseClient.js'
        )

        module.exports = /*#__PURE__*/ (function(_BaseClient) {
          _inherits(SockJSClient, _BaseClient)

          var _super = _createSuper(SockJSClient)

          function SockJSClient(url) {
            var _this

            _classCallCheck(this, SockJSClient)

            _this = _super.call(this)
            _this.sock = new SockJS(url)

            _this.sock.onerror = function(err) {
              // TODO: use logger to log the error event once client and client-src
              // are reorganized to have the same directory structure
            }

            return _this
          }

          _createClass(
            SockJSClient,
            [
              {
                key: 'onOpen',
                value: function onOpen(f) {
                  this.sock.onopen = f
                }
              },
              {
                key: 'onClose',
                value: function onClose(f) {
                  this.sock.onclose = f
                } // call f with the message string as the first argument
              },
              {
                key: 'onMessage',
                value: function onMessage(f) {
                  this.sock.onmessage = function(e) {
                    f(e.data)
                  }
                }
              }
            ],
            [
              {
                key: 'getClientPath',
                value: function getClientPath(options) {
                  return /*require.resolve*/ /*! ./SockJSClient */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js'
                }
              }
            ]
          )

          return SockJSClient
        })(BaseClient)

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/index.js?http://0.0.0.0:8989':
      /*!***********************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client?http://0.0.0.0:8989 ***!
  \***********************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'
        /* WEBPACK VAR INJECTION */ ;(function(__resourceQuery) {
          /* global __resourceQuery WorkerGlobalScope self */

          /* eslint prefer-destructuring: off */

          var stripAnsi = __webpack_require__(
            /*! strip-ansi */ './node_modules/_strip-ansi@3.0.1@strip-ansi/index.js'
          )

          var socket = __webpack_require__(
            /*! ./socket */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/socket.js'
          )

          var overlay = __webpack_require__(
            /*! ./overlay */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/overlay.js'
          )

          var _require = __webpack_require__(
              /*! ./utils/log */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/log.js'
            ),
            log = _require.log,
            setLogLevel = _require.setLogLevel

          var sendMessage = __webpack_require__(
            /*! ./utils/sendMessage */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/sendMessage.js'
          )

          var reloadApp = __webpack_require__(
            /*! ./utils/reloadApp */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/reloadApp.js'
          )

          var createSocketUrl = __webpack_require__(
            /*! ./utils/createSocketUrl */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/createSocketUrl.js'
          )

          var status = {
            isUnloading: false,
            currentHash: ''
          }
          var options = {
            hot: false,
            hotReload: true,
            liveReload: false,
            initial: true,
            useWarningOverlay: false,
            useErrorOverlay: false,
            useProgress: false
          }
          var socketUrl = createSocketUrl(__resourceQuery)
          self.addEventListener('beforeunload', function() {
            status.isUnloading = true
          })

          if (typeof window !== 'undefined') {
            var qs = window.location.search.toLowerCase()
            options.hotReload = qs.indexOf('hotreload=false') === -1
          }

          var onSocketMessage = {
            hot: function hot() {
              options.hot = true
              log.info('[WDS] Hot Module Replacement enabled.')
            },
            liveReload: function liveReload() {
              options.liveReload = true
              log.info('[WDS] Live Reloading enabled.')
            },
            invalid: function invalid() {
              log.info('[WDS] App updated. Recompiling...') // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

              if (options.useWarningOverlay || options.useErrorOverlay) {
                overlay.clear()
              }

              sendMessage('Invalid')
            },
            hash: function hash(_hash) {
              status.currentHash = _hash
            },
            'still-ok': function stillOk() {
              log.info('[WDS] Nothing changed.')

              if (options.useWarningOverlay || options.useErrorOverlay) {
                overlay.clear()
              }

              sendMessage('StillOk')
            },
            'log-level': function logLevel(level) {
              var hotCtx = __webpack_require__(
                './node_modules/webpack/hot sync ^\\.\\/log$'
              )

              if (hotCtx.keys().indexOf('./log') !== -1) {
                hotCtx('./log').setLogLevel(level)
              }

              setLogLevel(level)
            },
            overlay: function overlay(value) {
              if (typeof document !== 'undefined') {
                if (typeof value === 'boolean') {
                  options.useWarningOverlay = false
                  options.useErrorOverlay = value
                } else if (value) {
                  options.useWarningOverlay = value.warnings
                  options.useErrorOverlay = value.errors
                }
              }
            },
            progress: function progress(_progress) {
              if (typeof document !== 'undefined') {
                options.useProgress = _progress
              }
            },
            'progress-update': function progressUpdate(data) {
              if (options.useProgress) {
                log.info(
                  '[WDS] '.concat(data.percent, '% - ').concat(data.msg, '.')
                )
              }

              sendMessage('Progress', data)
            },
            ok: function ok() {
              sendMessage('Ok')

              if (options.useWarningOverlay || options.useErrorOverlay) {
                overlay.clear()
              }

              if (options.initial) {
                return (options.initial = false)
              } // eslint-disable-line no-return-assign

              reloadApp(options, status)
            },
            'content-changed': function contentChanged() {
              log.info('[WDS] Content base changed. Reloading...')
              self.location.reload()
            },
            warnings: function warnings(_warnings) {
              log.warn('[WDS] Warnings while compiling.')

              var strippedWarnings = _warnings.map(function(warning) {
                return stripAnsi(warning)
              })

              sendMessage('Warnings', strippedWarnings)

              for (var i = 0; i < strippedWarnings.length; i++) {
                log.warn(strippedWarnings[i])
              }

              if (options.useWarningOverlay) {
                overlay.showMessage(_warnings)
              }

              if (options.initial) {
                return (options.initial = false)
              } // eslint-disable-line no-return-assign

              reloadApp(options, status)
            },
            errors: function errors(_errors) {
              log.error('[WDS] Errors while compiling. Reload prevented.')

              var strippedErrors = _errors.map(function(error) {
                return stripAnsi(error)
              })

              sendMessage('Errors', strippedErrors)

              for (var i = 0; i < strippedErrors.length; i++) {
                log.error(strippedErrors[i])
              }

              if (options.useErrorOverlay) {
                overlay.showMessage(_errors)
              }

              options.initial = false
            },
            error: function error(_error) {
              log.error(_error)
            },
            close: function close() {
              log.error('[WDS] Disconnected!')
              sendMessage('Close')
            }
          }
          socket(socketUrl, onSocketMessage)
          /* WEBPACK VAR INJECTION */
        }.call(this, '?http://0.0.0.0:8989'))

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/overlay.js':
      /*!**************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/overlay.js ***!
  \**************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'
        // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
        // They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

        var ansiHTML = __webpack_require__(
          /*! ansi-html */ './node_modules/_ansi-html@0.0.7@ansi-html/index.js'
        )

        var _require = __webpack_require__(
            /*! html-entities */ './node_modules/_html-entities@1.4.0@html-entities/lib/index.js'
          ),
          AllHtmlEntities = _require.AllHtmlEntities

        var entities = new AllHtmlEntities()
        var colors = {
          reset: ['transparent', 'transparent'],
          black: '181818',
          red: 'E36049',
          green: 'B3CB74',
          yellow: 'FFD080',
          blue: '7CAFC2',
          magenta: '7FACCA',
          cyan: 'C3C2EF',
          lightgrey: 'EBE7E3',
          darkgrey: '6D7891'
        }
        var overlayIframe = null
        var overlayDiv = null
        var lastOnOverlayDivReady = null
        ansiHTML.setColors(colors)

        function createOverlayIframe(onIframeLoad) {
          var iframe = document.createElement('iframe')
          iframe.id = 'webpack-dev-server-client-overlay'
          iframe.src = 'about:blank'
          iframe.style.position = 'fixed'
          iframe.style.left = 0
          iframe.style.top = 0
          iframe.style.right = 0
          iframe.style.bottom = 0
          iframe.style.width = '100vw'
          iframe.style.height = '100vh'
          iframe.style.border = 'none'
          iframe.style.zIndex = 9999999999
          iframe.onload = onIframeLoad
          return iframe
        }

        function addOverlayDivTo(iframe) {
          var div = iframe.contentDocument.createElement('div')
          div.id = 'webpack-dev-server-client-overlay-div'
          div.style.position = 'fixed'
          div.style.boxSizing = 'border-box'
          div.style.left = 0
          div.style.top = 0
          div.style.right = 0
          div.style.bottom = 0
          div.style.width = '100vw'
          div.style.height = '100vh'
          div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)'
          div.style.color = '#E8E8E8'
          div.style.fontFamily = 'Menlo, Consolas, monospace'
          div.style.fontSize = 'large'
          div.style.padding = '2rem'
          div.style.lineHeight = '1.2'
          div.style.whiteSpace = 'pre-wrap'
          div.style.overflow = 'auto'
          iframe.contentDocument.body.appendChild(div)
          return div
        }

        function ensureOverlayDivExists(onOverlayDivReady) {
          if (overlayDiv) {
            // Everything is ready, call the callback right away.
            onOverlayDivReady(overlayDiv)
            return
          } // Creating an iframe may be asynchronous so we'll schedule the callback.
          // In case of multiple calls, last callback wins.

          lastOnOverlayDivReady = onOverlayDivReady

          if (overlayIframe) {
            // We've already created it.
            return
          } // Create iframe and, when it is ready, a div inside it.

          overlayIframe = createOverlayIframe(function() {
            overlayDiv = addOverlayDivTo(overlayIframe) // Now we can talk!

            lastOnOverlayDivReady(overlayDiv)
          }) // Zalgo alert: onIframeLoad() will be called either synchronously
          // or asynchronously depending on the browser.
          // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

          document.body.appendChild(overlayIframe)
        } // Successful compilation.

        function clear() {
          if (!overlayDiv) {
            // It is not there in the first place.
            return
          } // Clean up and reset internal state.

          document.body.removeChild(overlayIframe)
          overlayDiv = null
          overlayIframe = null
          lastOnOverlayDivReady = null
        } // Compilation with errors (e.g. syntax error or missing modules).

        function showMessage(messages) {
          ensureOverlayDivExists(function(div) {
            // Make it look similar to our terminal.
            div.innerHTML = '<span style="color: #'
              .concat(colors.red, '">Failed to compile.</span><br><br>')
              .concat(ansiHTML(entities.encode(messages[0])))
          })
        }

        module.exports = {
          clear: clear,
          showMessage: showMessage
        }

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/socket.js':
      /*!*************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/socket.js ***!
  \*************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'
        /* WEBPACK VAR INJECTION */ ;(function(__webpack_dev_server_client__) {
          /* global __webpack_dev_server_client__ */

          /* eslint-disable
  camelcase
*/
          // this SockJSClient is here as a default fallback, in case inline mode
          // is off or the client is not injected. This will be switched to
          // WebsocketClient when it becomes the default
          // important: the path to SockJSClient here is made to work in the 'client'
          // directory, but is updated via the webpack compilation when compiled from
          // the 'client-src' directory

          var Client =
            typeof __webpack_dev_server_client__ !== 'undefined'
              ? __webpack_dev_server_client__ // eslint-disable-next-line import/no-unresolved
              : __webpack_require__(
                  /*! ./clients/SockJSClient */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js'
                )
          var retries = 0
          var client = null

          var socket = function initSocket(url, handlers) {
            client = new Client(url)
            client.onOpen(function() {
              retries = 0
            })
            client.onClose(function() {
              if (retries === 0) {
                handlers.close()
              } // Try to reconnect.

              client = null // After 10 retries stop trying, to prevent logspam.

              if (retries <= 10) {
                // Exponentially increase timeout to reconnect.
                // Respectfully copied from the package `got`.
                // eslint-disable-next-line no-mixed-operators, no-restricted-properties
                var retryInMs =
                  1000 * Math.pow(2, retries) + Math.random() * 100
                retries += 1
                setTimeout(function() {
                  socket(url, handlers)
                }, retryInMs)
              }
            })
            client.onMessage(function(data) {
              var msg = JSON.parse(data)

              if (handlers[msg.type]) {
                handlers[msg.type](msg.data)
              }
            })
          }

          module.exports = socket
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/clients/SockJSClient.js'
          )
        ))

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/createSocketUrl.js':
      /*!****************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/createSocketUrl.js ***!
  \****************************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        /* global self */

        var url = __webpack_require__(
          /*! url */ './node_modules/_url@0.11.0@url/url.js'
        )

        var getCurrentScriptSource = __webpack_require__(
          /*! ./getCurrentScriptSource */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/getCurrentScriptSource.js'
        )

        function createSocketUrl(resourceQuery, currentLocation) {
          var urlParts

          if (typeof resourceQuery === 'string' && resourceQuery !== '') {
            // If this bundle is inlined, use the resource query to get the correct url.
            // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
            urlParts = url.parse(
              resourceQuery // strip leading `?` from query string to get a valid URL
                .substr(1) // replace first `&` with `?` to have a valid query string
                .replace('&', '?'),
              true
            )
          } else {
            // Else, get the url from the <script> this file was called with.
            var scriptHost = getCurrentScriptSource()
            urlParts = url.parse(scriptHost || '/', true, true)
          } // Use parameter to allow passing location in unit tests

          if (typeof currentLocation === 'string' && currentLocation !== '') {
            currentLocation = url.parse(currentLocation)
          } else {
            currentLocation = self.location
          }

          return getSocketUrl(urlParts, currentLocation)
        }
        /*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */

        function getSocketUrl(urlParts, loc) {
          var auth = urlParts.auth,
            query = urlParts.query
          var hostname = urlParts.hostname,
            protocol = urlParts.protocol,
            port = urlParts.port

          if (!port || port === '0') {
            port = loc.port
          } // check ipv4 and ipv6 `all hostname`
          // why do we need this check?
          // hostname n/a for file protocol (example, when using electron, ionic)
          // see: https://github.com/webpack/webpack-dev-server/pull/384

          if (
            (hostname === '0.0.0.0' || hostname === '::') &&
            loc.hostname &&
            loc.protocol.indexOf('http') === 0
          ) {
            hostname = loc.hostname
          } // `hostname` can be empty when the script path is relative. In that case, specifying
          // a protocol would result in an invalid URL.
          // When https is used in the app, secure websockets are always necessary
          // because the browser doesn't accept non-secure websockets.

          if (
            hostname &&
            hostname !== '127.0.0.1' &&
            (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')
          ) {
            protocol = loc.protocol
          } // all of these sock url params are optionally passed in through
          // resourceQuery, so we need to fall back to the default if
          // they are not provided

          var sockHost = query.sockHost || hostname
          var sockPath = query.sockPath || '/sockjs-node'
          var sockPort = query.sockPort || port

          if (sockPort === 'location') {
            sockPort = loc.port
          }

          return url.format({
            protocol: protocol,
            auth: auth,
            hostname: sockHost,
            port: sockPort,
            // If sockPath is provided it'll be passed in via the resourceQuery as a
            // query param so it has to be parsed out of the querystring in order for the
            // client to open the socket to the correct location.
            pathname: sockPath
          })
        }

        module.exports = createSocketUrl

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/getCurrentScriptSource.js':
      /*!***********************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \***********************************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        function getCurrentScriptSource() {
          // `document.currentScript` is the most accurate way to find the current script,
          // but is not supported in all browsers.
          if (document.currentScript) {
            return document.currentScript.getAttribute('src')
          } // Fall back to getting all scripts in the document.

          var scriptElements = document.scripts || []
          var currentScript = scriptElements[scriptElements.length - 1]

          if (currentScript) {
            return currentScript.getAttribute('src')
          } // Fail as there was no script to use.

          throw new Error('[WDS] Failed to get current script source.')
        }

        module.exports = getCurrentScriptSource

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/log.js':
      /*!****************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/log.js ***!
  \****************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        var log = __webpack_require__(
          /*! loglevel */ './node_modules/_loglevel@1.7.1@loglevel/lib/loglevel.js'
        ).getLogger('webpack-dev-server')

        var INFO = 'info'
        var WARN = 'warn'
        var ERROR = 'error'
        var DEBUG = 'debug'
        var TRACE = 'trace'
        var SILENT = 'silent' // deprecated
        // TODO: remove these at major released
        // https://github.com/webpack/webpack-dev-server/pull/1825

        var WARNING = 'warning'
        var NONE = 'none' // Set the default log level

        log.setDefaultLevel(INFO)

        function setLogLevel(level) {
          switch (level) {
            case INFO:
            case WARN:
            case ERROR:
            case DEBUG:
            case TRACE:
              log.setLevel(level)
              break
            // deprecated

            case WARNING:
              // loglevel's warning name is different from webpack's
              log.setLevel('warn')
              break
            // deprecated

            case NONE:
            case SILENT:
              log.disableAll()
              break

            default:
              log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"))
          }
        }

        module.exports = {
          log: log,
          setLogLevel: setLogLevel
        }

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/reloadApp.js':
      /*!**********************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/reloadApp.js ***!
  \**********************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        /* global WorkerGlobalScope self */

        var _require = __webpack_require__(
            /*! ./log */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/log.js'
          ),
          log = _require.log

        function reloadApp(_ref, _ref2) {
          var hotReload = _ref.hotReload,
            hot = _ref.hot,
            liveReload = _ref.liveReload
          var isUnloading = _ref2.isUnloading,
            currentHash = _ref2.currentHash

          if (isUnloading || !hotReload) {
            return
          }

          if (hot) {
            log.info('[WDS] App hot update...')

            var hotEmitter = __webpack_require__(
              /*! webpack/hot/emitter */ './node_modules/_webpack@4.46.0@webpack/hot/emitter.js'
            )

            hotEmitter.emit('webpackHotUpdate', currentHash)

            if (typeof self !== 'undefined' && self.window) {
              // broadcast update to window
              self.postMessage('webpackHotUpdate'.concat(currentHash), '*')
            }
          } // allow refreshing the page only if liveReload isn't disabled
          else if (liveReload) {
            var rootWindow = self // use parent window for reload (in case we're in an iframe with no valid src)

            var intervalId = self.setInterval(function() {
              if (rootWindow.location.protocol !== 'about:') {
                // reload immediately if protocol is valid
                applyReload(rootWindow, intervalId)
              } else {
                rootWindow = rootWindow.parent

                if (rootWindow.parent === rootWindow) {
                  // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
                  applyReload(rootWindow, intervalId)
                }
              }
            })
          }

          function applyReload(rootWindow, intervalId) {
            clearInterval(intervalId)
            log.info('[WDS] App updated. Reloading...')
            rootWindow.location.reload()
          }
        }

        module.exports = reloadApp

        /***/
      },

    /***/ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/sendMessage.js':
      /*!************************************************************************************************!*\
  !*** ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/utils/sendMessage.js ***!
  \************************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict'

        /* global __resourceQuery WorkerGlobalScope self */
        // Send messages to the outside, so plugins can consume it.

        function sendMsg(type, data) {
          if (
            typeof self !== 'undefined' &&
            (typeof WorkerGlobalScope === 'undefined' ||
              !(self instanceof WorkerGlobalScope))
          ) {
            self.postMessage(
              {
                type: 'webpack'.concat(type),
                data: data
              },
              '*'
            )
          }
        }

        module.exports = sendMsg

        /***/
      },

    /***/ './node_modules/_webpack@4.46.0@webpack/buildin/global.js':
      /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        var g

        // This works in non-strict mode
        g = (function() {
          return this
        })()

        try {
          // This works if eval is allowed (see CSP)
          g = g || new Function('return this')()
        } catch (e) {
          // This works if the window reference is available
          if (typeof window === 'object') g = window
        }

        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}

        module.exports = g

        /***/
      },

    /***/ './node_modules/_webpack@4.46.0@webpack/buildin/module.js':
      /*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        module.exports = function(module) {
          if (!module.webpackPolyfill) {
            module.deprecate = function() {}
            module.paths = []
            // module.parent = undefined by default
            if (!module.children) module.children = []
            Object.defineProperty(module, 'loaded', {
              enumerable: true,
              get: function() {
                return module.l
              }
            })
            Object.defineProperty(module, 'id', {
              enumerable: true,
              get: function() {
                return module.i
              }
            })
            module.webpackPolyfill = 1
          }
          return module
        }

        /***/
      },

    /***/ './node_modules/_webpack@4.46.0@webpack/hot/emitter.js':
      /*!********************************!*\
  !*** (webpack)/hot/emitter.js ***!
  \********************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var EventEmitter = __webpack_require__(
          /*! events */ './node_modules/_events@3.3.0@events/events.js'
        )
        module.exports = new EventEmitter()

        /***/
      },

    /***/ './node_modules/_webpack@4.46.0@webpack/hot/log-apply-result.js':
      /*!*****************************************!*\
  !*** (webpack)/hot/log-apply-result.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
        module.exports = function(updatedModules, renewedModules) {
          var unacceptedModules = updatedModules.filter(function(moduleId) {
            return renewedModules && renewedModules.indexOf(moduleId) < 0
          })
          var log = __webpack_require__(
            /*! ./log */ './node_modules/_webpack@4.46.0@webpack/hot/log.js'
          )

          if (unacceptedModules.length > 0) {
            log(
              'warning',
              "[HMR] The following modules couldn't be hot updated: (They would need a full reload!)"
            )
            unacceptedModules.forEach(function(moduleId) {
              log('warning', '[HMR]  - ' + moduleId)
            })
          }

          if (!renewedModules || renewedModules.length === 0) {
            log('info', '[HMR] Nothing hot updated.')
          } else {
            log('info', '[HMR] Updated modules:')
            renewedModules.forEach(function(moduleId) {
              if (
                typeof moduleId === 'string' &&
                moduleId.indexOf('!') !== -1
              ) {
                var parts = moduleId.split('!')
                log.groupCollapsed('info', '[HMR]  - ' + parts.pop())
                log('info', '[HMR]  - ' + moduleId)
                log.groupEnd('info')
              } else {
                log('info', '[HMR]  - ' + moduleId)
              }
            })
            var numberIds = renewedModules.every(function(moduleId) {
              return typeof moduleId === 'number'
            })
            if (numberIds)
              log(
                'info',
                '[HMR] Consider using the NamedModulesPlugin for module names.'
              )
          }
        }

        /***/
      },

    /***/ './node_modules/_webpack@4.46.0@webpack/hot/log.js':
      /*!****************************!*\
  !*** (webpack)/hot/log.js ***!
  \****************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        var logLevel = 'info'

        function dummy() {}

        function shouldLog(level) {
          var shouldLog =
            (logLevel === 'info' && level === 'info') ||
            (['info', 'warning'].indexOf(logLevel) >= 0 &&
              level === 'warning') ||
            (['info', 'warning', 'error'].indexOf(logLevel) >= 0 &&
              level === 'error')
          return shouldLog
        }

        function logGroup(logFn) {
          return function(level, msg) {
            if (shouldLog(level)) {
              logFn(msg)
            }
          }
        }

        module.exports = function(level, msg) {
          if (shouldLog(level)) {
            if (level === 'info') {
              console.log(msg)
            } else if (level === 'warning') {
              console.warn(msg)
            } else if (level === 'error') {
              console.error(msg)
            }
          }
        }

        /* eslint-disable node/no-unsupported-features/node-builtins */
        var group = console.group || dummy
        var groupCollapsed = console.groupCollapsed || dummy
        var groupEnd = console.groupEnd || dummy
        /* eslint-enable node/no-unsupported-features/node-builtins */

        module.exports.group = logGroup(group)

        module.exports.groupCollapsed = logGroup(groupCollapsed)

        module.exports.groupEnd = logGroup(groupEnd)

        module.exports.setLogLevel = function(level) {
          logLevel = level
        }

        module.exports.formatError = function(err) {
          var message = err.message
          var stack = err.stack
          if (!stack) {
            return message
          } else if (stack.indexOf(message) < 0) {
            return message + '\n' + stack
          } else {
            return stack
          }
        }

        /***/
      },

    /***/ './node_modules/_webpack@4.46.0@webpack/hot/only-dev-server.js':
      /*!****************************************!*\
  !*** (webpack)/hot/only-dev-server.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
        /*globals __webpack_hash__ */
        if (true) {
          var lastHash
          var upToDate = function upToDate() {
            return lastHash.indexOf(__webpack_require__.h()) >= 0
          }
          var log = __webpack_require__(
            /*! ./log */ './node_modules/_webpack@4.46.0@webpack/hot/log.js'
          )
          var check = function check() {
            module.hot
              .check()
              .then(function(updatedModules) {
                if (!updatedModules) {
                  log(
                    'warning',
                    '[HMR] Cannot find update. Need to do a full reload!'
                  )
                  log(
                    'warning',
                    '[HMR] (Probably because of restarting the webpack-dev-server)'
                  )
                  return
                }

                return module.hot
                  .apply({
                    ignoreUnaccepted: true,
                    ignoreDeclined: true,
                    ignoreErrored: true,
                    onUnaccepted: function(data) {
                      log(
                        'warning',
                        'Ignored an update to unaccepted module ' +
                          data.chain.join(' -> ')
                      )
                    },
                    onDeclined: function(data) {
                      log(
                        'warning',
                        'Ignored an update to declined module ' +
                          data.chain.join(' -> ')
                      )
                    },
                    onErrored: function(data) {
                      log('error', data.error)
                      log(
                        'warning',
                        'Ignored an error while updating module ' +
                          data.moduleId +
                          ' (' +
                          data.type +
                          ')'
                      )
                    }
                  })
                  .then(function(renewedModules) {
                    if (!upToDate()) {
                      check()
                    }

                    __webpack_require__(
                      /*! ./log-apply-result */ './node_modules/_webpack@4.46.0@webpack/hot/log-apply-result.js'
                    )(updatedModules, renewedModules)

                    if (upToDate()) {
                      log('info', '[HMR] App is up to date.')
                    }
                  })
              })
              .catch(function(err) {
                var status = module.hot.status()
                if (['abort', 'fail'].indexOf(status) >= 0) {
                  log(
                    'warning',
                    '[HMR] Cannot check for update. Need to do a full reload!'
                  )
                  log('warning', '[HMR] ' + log.formatError(err))
                } else {
                  log(
                    'warning',
                    '[HMR] Update check failed: ' + log.formatError(err)
                  )
                }
              })
          }
          var hotEmitter = __webpack_require__(
            /*! ./emitter */ './node_modules/_webpack@4.46.0@webpack/hot/emitter.js'
          )
          hotEmitter.on('webpackHotUpdate', function(currentHash) {
            lastHash = currentHash
            if (!upToDate()) {
              var status = module.hot.status()
              if (status === 'idle') {
                log('info', '[HMR] Checking for updates on the server...')
                check()
              } else if (['abort', 'fail'].indexOf(status) >= 0) {
                log(
                  'warning',
                  '[HMR] Cannot apply update as a previous update ' +
                    status +
                    'ed. Need to do a full reload!'
                )
              }
            }
          })
          log('info', '[HMR] Waiting for update signal from WDS...')
        } else {
        }

        /***/
      },

    /***/ './node_modules/webpack/hot sync ^\\.\\/log$':
      /*!**************************************************************!*\
  !*** ./node_modules/webpack/hot sync nonrecursive ^\.\/log$ ***!
  \**************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var map = {
          './log': './node_modules/_webpack@4.46.0@webpack/hot/log.js'
        }

        function webpackContext(req) {
          var id = webpackContextResolve(req)
          return __webpack_require__(id)
        }
        function webpackContextResolve(req) {
          if (!__webpack_require__.o(map, req)) {
            var e = new Error("Cannot find module '" + req + "'")
            e.code = 'MODULE_NOT_FOUND'
            throw e
          }
          return map[req]
        }
        webpackContext.keys = function webpackContextKeys() {
          return Object.keys(map)
        }
        webpackContext.resolve = webpackContextResolve
        module.exports = webpackContext
        webpackContext.id = './node_modules/webpack/hot sync ^\\.\\/log$'

        /***/
      },

    /***/ './playground/main.js':
      /*!****************************!*\
  !*** ./playground/main.js ***!
  \****************************/
      /*! no exports provided */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        'use strict'
        __webpack_require__.r(__webpack_exports__)
        /* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! vue */ './dist/vue.runtime.esm-bundler.js'
        )
        /* harmony import */ var _dist_vue_runtime_esm_browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ../dist/vue.runtime.esm-browser.js */ './dist/vue.runtime.esm-browser.js'
        )

        var app = Object(
          _dist_vue_runtime_esm_browser_js__WEBPACK_IMPORTED_MODULE_1__[
            'createApp'
          ]
        )({
          data: function data() {
            return {
              title: 'hello'
            }
          },
          render: function render() {
            return Object(vue__WEBPACK_IMPORTED_MODULE_0__['createVNode'])(
              'span',
              null,
              [this.title]
            )
          }
        }) // do some necessary preparations

        app.mount('#app')

        /***/
      },

    /***/ 0:
      /*!***********************************************************************************************************************************************************!*\
  !*** multi ./node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client?http://0.0.0.0:8989 (webpack)/hot/only-dev-server.js ./playground/main.js ***!
  \***********************************************************************************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        __webpack_require__(
          /*! /Users/yangjiang/dev/git_repo/vue-next/packages/vue/node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/index.js?http://0.0.0.0:8989 */ './node_modules/_webpack-dev-server@3.11.2@webpack-dev-server/client/index.js?http://0.0.0.0:8989'
        )
        __webpack_require__(
          /*! /Users/yangjiang/dev/git_repo/vue-next/packages/vue/node_modules/_webpack@4.46.0@webpack/hot/only-dev-server.js */ './node_modules/_webpack@4.46.0@webpack/hot/only-dev-server.js'
        )
        module.exports = __webpack_require__(
          /*! ./playground/main.js */ './playground/main.js'
        )

        /***/
      }

    /******/
  }
)
//# sourceMappingURL=mini-vue.js.map
